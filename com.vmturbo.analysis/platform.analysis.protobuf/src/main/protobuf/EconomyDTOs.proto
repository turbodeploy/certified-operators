syntax = "proto2";
package com.vmturbo.platform.analysis.protobuf;

import "CommodityDTOs.proto";
import "QuoteFunctionDTOs.proto";
import "CostDTOs.proto";
import "BalanceAccountDTOs.proto";

// The settings associated with the Economy.
// The acceptable commodity utilization range used in resize engage criteria.
message EconomySettingsTO {
    // Resize up only if utilization is above the upper watermark.
    required float rightsize_upper_watermark = 1;

    // Do not resize down if utilization is above the lower watermark.
    required float rightsize_lower_watermark = 2;

    // Use expense metric in termination criterion for placement.
    required bool use_expense_metric_for_termination = 3;

    // The minimum percent to be used for the expenses metric termination criterion.
    required float expense_metric_factor = 4;

    // Support user configured rate of resize.
    required float rate_of_resize = 5;

    // flag to enable estimates
    required bool estimates = 6 [default = false];

    // The quote factor is a number (between 0 and 1), so that Move actions are
    // only generated if best-quote < quote-factor * current-quote. That means that if we only want
    // Moves that result in at least 25% improvement we should use a quote-factor of 0.75.
    required float quote_factor = 7 [default = 0.75];
}

// A list of commodities that must be bought from the same provider, with some additional information.
message ShoppingListTO {
    // The unique identifier of this shopping list. Used to control individual volumes.
    required int64 oid = 1;

    // The current supplier for this shopping list. Assumed null if missing.
    optional int64 supplier = 2;

    // Whether the analysis engine can move this shopping list. Intended to be true only for VM and
    // Container shopping lists.
    optional bool movable = 3;

    // The list of commodities that are currently bought from this supplier or need to be bought by
    // some supplier if supplier is missing.
    repeated CommodityBoughtTO commodities_bought = 4;

    // The cost of moving a shopping list to a new storage. Used for VM and Container shopping lists
    optional float storage_move_cost = 5;

}

// A group of parameters effecting how a trader will be treated by the analysis engine.
message TraderSettingsTO {
    // Whether the analysis engine can use this as a template to create new traders.
    optional bool clonable = 1;

    // Whether the analysis engine can deactivate this trader.
    optional bool suspendable = 2;

    // Min and max desired utilizations together define the desired zone for a trader.
    // The relationship min_desired_utilization <= max_desired_utilization must hold.
    optional float min_desired_utilization = 3;
    optional float max_desired_utilization = 4 [default = 1.0];

    // Whether the trader should consume the clone of provider
    optional bool guaranteed_buyer = 5;

	// Whether the trader can accept consumer move in or out
    optional bool can_accept_new_customers = 6;

    // This field specifies if we can do resize down in the real time market
    optional bool isEligibleForResizeDown = 7;

    // This field specifies if a trader should shop together or not
    optional bool isShopTogether = 8;

	// This field specifies which function to use for computing quote
    optional QuoteFunctionDTO quote_function = 9;

    // This field refers to the balance account that the trader associated with
    optional BalanceAccountDTO balance_account = 10;
}

// The different states a trader can be in. The intention is to make this a boolean once we confirm
// no more states are needed by the analysis engine.
enum TraderStateTO {
    ACTIVE = 1; // The trader is participating in the economy and has expenses and revenues.
    INACTIVE = 2; // The trader isn't participating in the economy and has zero expenses and revenues.
    IDLE = 3; // VMs can be in an IDLE state. they behave like active traders in M2
}

// An entity that trades goods in a market. Can buy and sell goods simultaneously.
// Virtual machines, data centers and applications are examples of entities that can be modeled as
// a trader.
message TraderTO {
    // The unique identifier of this trader. Used to send back actions for it.
    required int64 oid = 1;

    // Analysis is currently not using this field, but may be used for debugging.
    optional int32 type = 2;

    // Whether this trader participates in the economy and has expenses and revenues.
    optional TraderStateTO state = 3;

    // A list of commodities offered by this trader.
    repeated CommoditySoldTO commodities_sold = 4;

    // A list of integers representing the k-partite cliques this trader is a member of.
    repeated int64 cliques = 5 [packed = true];

    // A list of shopping lists this trader sets out to buy.
    repeated ShoppingListTO shopping_lists = 6;

    // The settings affecting how the analysis engine should treat this trader.
    optional TraderSettingsTO settings = 7;

    // The field contains info about trader's eclass and uuid, it is used for debugging only
    optional string debug_info_never_use_in_code = 8;

    // This field contains the economicIndex of the modelSeller if this host was cloned
    optional int64 clone_of = 9;

    // The number of buyers that consuming the trader
    optional int32 num_of_produces = 10;

    // This field specifies weather a trader is a clone of a sampleSE from a template used
    // for headroom plans
    optional bool templateForHeadroom = 11 [default = false];

    // This field specifies whether we will print debug info for a trader
    optional bool debugEnabled = 12 [default = false];

    // This field specifies if this is a templateProvider
    optional bool templateProvider = 13 [default = false];

}