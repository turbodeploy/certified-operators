package com.vmturbo.platform.analysis.protobuf;

import "ActionDTOs.proto";
import "EconomyDTOs.proto";
import "UpdatingFunctionDTOs.proto";

// Market 2.0 isn't concerned with segments, groups, etc. because it's enough to know about
// commodities. Thus we need a limited number of messages.

// The intention is that the client (Validator or other component) sends a StartDiscoveredTopology
// message when it has a new validated topology, followed by a TraderTO message for each trader in
// the topology, followed by an EndDiscoveredTopology message. This will incur a 2-4 byte overhead
// per trader, but will guarantee WebSocket messages don't exceed the size supported by the
// implementation and allow the sender to start sending without converting the whole topology to
// Protobuf in memory first.

// The communication messages are expected to evolve as we change the way the analysis server and
// other XL components communicate with each other. e.g. if we change from sending a full topology
// to sending incremental changes.

// The message to send before any trader of a new full topology.
message StartDiscoveredTopology {
    // The flag to indicate if the flag to indicate if shoptogether placement decisions for
    // the economy should be used
    required bool enableShopTogether = 1;

    // Economy Settings
    required EconomySettingsTO economySettings = 2;
}

// The message to force a running plan to stop
message ForcePlanStop {
}

// The intention is that the Analysis server will keep information in a staging area and atomically
// replace the old real-time topology with the new when it receives the EndDiscoveredTopology
// message. That way the Analysis server will have a valid topology at any time.

// The message to send after the last trader is sent, to finalize a new full topology.
message EndDiscoveredTopology {
    // A map entry message to use for sending a map from commodity specifications to quantity
    // updating functions since Protobuf maps don't support keys of non-scalar type. Protobuf won't
    // check that the same key doesn't appear twice though...
    message MapEntry {
        optional CommoditySpecificationTO key = 1;
        optional UpdatingFunctionTO value = 2;
    }

    // The type of dependent commodity.
    // If it is to be set to the minimum of its and the resized commodity's value
    // otherwise it is set to the resized commodity value.
    message CommodityResizeDependency {
        required int32 dependentCommodityType = 1;
        required UpdatingFunctionTO incrementFunction = 2;
        required UpdatingFunctionTO decrementFunction = 3;
    }

    // An entry of dependent commodity in map.
    message CommodityResizeDependencyEntry {
        required int32 commodityType = 1;
        repeated CommodityResizeDependency commodityResizeDependency = 2;
    }

    // An entry in raw to processed commodity map. The raw (bought) commodity
    // is the key and the processed (sold) commodity is the value.
    message CommodityRawMaterialEntry {
        required int32 processedCommodityType = 1;
        repeated int32 rawCommodityType = 2;
    }

    // A map from commodity specifications to functions to use when updating the quantities sold
    // of commodities with that specification when a customer moves in or out. No MapEntry.keys
    // should be the same.
    repeated MapEntry updating_function_entry = 1;

    // We need a map from commodity type to a list of dependent commodities for use in resize down.
    // For the dependent commodity we also need to know if it should be a min of its and the resized value
    // or has to be set to the resized value.
    repeated CommodityResizeDependencyEntry resize_dependency = 2;

    // A map from the raw (bought) commodity to the processed (sold) commodity.
    // This map links the bought commodity to the sold commodity
    repeated CommodityRawMaterialEntry raw_material_entry = 3;

	// A flag to indicate if provision algorithm should be triggered or not
    optional bool enableProvision = 4;
    // A flag to indicate if suspension algorithm should be triggered or not
    optional bool enableSuspension = 5;
    // A flag to indicate if resize algorithm should be triggered or not
    optional bool enableResize = 6;
}

// A compound message to encapsulate any one of command messages.
message AnalysisCommand {
    // Which one of the available commands this message contains.
    oneof command_type {
        StartDiscoveredTopology start_discovered_topology = 1;
        TraderTO discovered_trader = 2;
        EndDiscoveredTopology end_discovered_topology = 3;
        ForcePlanStop force_plan_stop = 4;
    }
}

// It shouldn't matter if the connection is dropped and reestablished at any point between messages.

// Since in M2 there is no distinction between actions generated by the real-time market and by
// plans, we have a single results message for both

// The client (e.g. Validator) shouldn't expect this as a response to an EndDiscoveredTopology
// message, but rather be prepared to accept it at any time. This will allow analysis to choose
// whether it is best to run every time it has new data, or at specified intervals, or both.
message AnalysisResults {
    // The list of actions proposed by the economic decision engine.
    repeated ActionTO actions = 1;
	// The boolean to indicate if plan is forced to stop state
	optional bool plan_stopped = 2;
    // Just-for-fun field to allow showing how long it took to compute the results. (Like the
    // indication in Google Search) The value is in nanoseconds.
    optional int64 time_to_analyze_ns = 3;
}
