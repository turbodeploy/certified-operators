package com.vmturbo.stitching;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Sets;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.vmturbo.platform.common.dto.CommonDTO.EntityDTO.EntityType;
import com.vmturbo.stitching.StitchingScope.StitchingScopeFactory;

/**
 * Stitching Operation that caches external signatures between calls to
 * initializeOperationBeforeStitching.
 *
 * @param <InternalSignatureT> the internal signature type of the operation.
 * @param <ExternalSignatureT> the external signature type of the operation.
 * @param <ExternalSignatureContextT>> the type of the external signature context.
 */
public abstract class AbstractExternalSignatureCachingStitchingOperation<InternalSignatureT,
        ExternalSignatureT, ExternalSignatureContextT>
    implements StitchingOperation<InternalSignatureT, ExternalSignatureT> {
    private static final Logger logger = LogManager.getLogger();

    /**
     * Get set of external signatures for an external entity. External signatures will be matched
     * against internal signatures using a map from signature to internal entity to identify
     * entities that should be stitched with each other.
     * The {@link EntityType} of the external entities will be guaranteed to match the entity type
     * returned by {@link #getExternalEntityType()}. If {@link #getExternalEntityType()} returned
     * {@link Optional#empty()}, this method will never be called.
     * External entities are defined as the entities discovered by targets other than the target
     * that invoked the stitching operation.
     * Return an empty collection to skip this {@link StitchingEntity} when stitching.
     *
     * @param externalEntity The external entity whose signature should be retrieved.
     * @param signatureContext A context object used to potentially aid in the generation
     *                         of external signatures. The value passed for this parameter
     *                         is guaranteed to be the value generated by calling the
     *                         {@link #createExternalSignatureContext(StitchingScopeFactory)} method.
     *                         A new signature context is created distinct for each time
     *                         stitching runs.
     * @return The collection of signatures for the external entity. Return an empty collection
     *         to skip considering this entity during matching.
     */
    protected abstract Collection<ExternalSignatureT> getExternalSignature(
            @Nonnull StitchingEntity externalEntity,
            @Nullable ExternalSignatureContextT signatureContext);

    /**
     * Create the external signature context to be passed to the
     * {@link #createExternalSignatureContext(StitchingScopeFactory)} getExternalSignature}
     * method calls. Classes that require no additional context can have a {@link Void}
     * {@code ExternalSignatureT} and return null when this method is called.
     *
     * @param stitchingScopeFactory The scope factory that can be used to retrieve entities in
     *                              a given scope.
     * @return The context object to be passed to calls to
     *         {@link #getExternalSignature(StitchingEntity, Object)} on this operation.
     */
    protected abstract ExternalSignatureContextT createExternalSignatureContext(
        @Nonnull StitchingScopeFactory<StitchingEntity> stitchingScopeFactory);

    @Nonnull
    @Override
    public Map<ExternalSignatureT, Collection<StitchingEntity>> getExternalSignatures(
            @Nonnull StitchingScopeFactory<StitchingEntity> stitchingScopeFactory,
            @Nonnull ExternalSignatureCache signatureCache, long targetId) {
        // if caching is disabled, clear the cache
        if (!isCachingEnabled()) {
            return createNewExternalSignatureMap(stitchingScopeFactory, targetId);
        } else {
            return signatureCache.computeSignaturesIfAbsent(this,
                () -> createNewExternalSignatureMap(stitchingScopeFactory, targetId));
        }
    }

    /**
     * Create a new map of external signatures. This map may be cached to avoid having to
     * recreate the map on further stitching calls to this operation within the same
     * run of stitching.
     *
     * @param stitchingScopeFactory The scope factory that can be used to retrieve entities in
     *                              a given scope.
     * @param targetId The ID of the target being stitched with.
     * @return The map of external signatures to the associated stitching entities that have
     *         that signature.
     */
    protected Map<ExternalSignatureT, Collection<StitchingEntity>> createNewExternalSignatureMap(
        @Nonnull StitchingScopeFactory<StitchingEntity> stitchingScopeFactory, long targetId) {
        logger.debug("Generating external signatures for operation {}",
            getOperationName());

        // Generate the map of external signatures from the entities is the scope, or, if
        // there is no scope, use all entities of the correct entity type
        final ExternalSignatureContextT signatureContext = createExternalSignatureContext(stitchingScopeFactory);
        final Map<ExternalSignatureT, Collection<StitchingEntity>> externalSignatures
            = new HashMap<>();

        getScope(stitchingScopeFactory, targetId).orElseGet(
                () -> stitchingScopeFactory.entityTypeScope(getExternalEntityType().get()))
            .entities()
            .forEach(entity -> getExternalSignature(entity, signatureContext).forEach(
                signature -> externalSignatures.computeIfAbsent(
                    signature, key -> Sets.newHashSet()).add(entity)));

        return externalSignatures;
    }

    @VisibleForTesting
    public boolean isCachingEnabled() {
        return true;
    }

    /**
     * A small abstract class for stitching operations that require no additional context for generating
     * their external signatures.
     *
     * @param <InternalSignatureT> the internal signature type of the operation.
     * @param <ExternalSignatureT> the external signature type of the operation.
     */
    public abstract static class ContextlessSignatureCachingStitchingOperation<InternalSignatureT,
        ExternalSignatureT> extends AbstractExternalSignatureCachingStitchingOperation<InternalSignatureT,
        ExternalSignatureT, Void> {

        @Override
        protected Void createExternalSignatureContext(
            @Nonnull StitchingScopeFactory<StitchingEntity> stitchingScopeFactory) {
            return null;
        }
    }
}
