package com.vmturbo.stitching.vdi;

import java.util.Collection;
import java.util.Collections;
import java.util.Optional;

import javax.annotation.Nonnull;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.util.CollectionUtils;

import com.vmturbo.platform.common.dto.CommonDTO.EntityDTO;
import com.vmturbo.platform.common.dto.CommonDTO.EntityDTO.Builder;
import com.vmturbo.platform.common.dto.CommonDTO.EntityDTO.DesktopPoolData;
import com.vmturbo.platform.common.dto.CommonDTO.EntityDTO.EntityType;
import com.vmturbo.platform.common.dto.CommonDTO.EntityDTO.VirtualDatacenterData;
import com.vmturbo.platform.sdk.common.util.SDKProbeType;
import com.vmturbo.stitching.AbstractExternalSignatureCachingStitchingOperation;
import com.vmturbo.stitching.StitchingEntity;
import com.vmturbo.stitching.StitchingPoint;
import com.vmturbo.stitching.StitchingScope;
import com.vmturbo.stitching.StitchingScope.StitchingScopeFactory;
import com.vmturbo.stitching.TopologicalChangelog;
import com.vmturbo.stitching.TopologicalChangelog.StitchingChangesBuilder;

/**
 * Stitching Operation to resolve the vm reference id in the desktop pool. The probe sends in the master image
 * as the uuid of underlying VC Virtual Machine and this needs to be resolved to the OID
 * generated by the Topology Processor. In addition, we will be adding the master image source
 * property to entity properties to identify if the UID was a VM.
 */
public class DesktopPoolMasterImageStitchingOperation extends
        AbstractExternalSignatureCachingStitchingOperation<String, String> {
    private static final String SEPARATOR = "_";
    private final Logger logger = LogManager.getLogger();

    // master image VM id -> associated desktop pools
    private final Multimap<String, String> masterVMToDesktopPools = HashMultimap.create();

    private Optional<String> getMasterImage(@Nonnull StitchingEntity internalEntity) {
        final EntityDTO.Builder builder = internalEntity.getEntityBuilder();
        if (builder.hasVirtualDatacenterData()) {
            final VirtualDatacenterData vcData = builder.getVirtualDatacenterData();
            if (vcData.hasDesktopPoolData()) {
                final DesktopPoolData dpData = vcData.getDesktopPoolData();
                if (dpData.hasMasterImage()) {
                    return Optional.of(dpData.getMasterImage());
                }
            }
        }
        return Optional.empty();
    }

    private String generateInternalSignature(@Nonnull String masterImage, @Nonnull String id) {
        return id + SEPARATOR + masterImage;
    }

    @Override
    public void initializeOperationBeforeStitching(
            @Nonnull StitchingScopeFactory<StitchingEntity> stitchingScopeFactory) {
        // clear and rebuild the Multimap that is needed to create external entity signatures
        masterVMToDesktopPools.clear();
        stitchingScopeFactory.probeEntityTypeScope(SDKProbeType.VMWARE_HORIZON_VIEW.getProbeType(),
                EntityType.DESKTOP_POOL).entities()
                .forEach(internalEntity -> getMasterImage(internalEntity)
                        .ifPresent(master -> masterVMToDesktopPools.put(master,
                                generateInternalSignature(master,
                                        internalEntity.getEntityBuilder().getId()))));
        super.initializeOperationBeforeStitching(stitchingScopeFactory);
    }

    @Nonnull
    @Override
    public Optional<StitchingScope<StitchingEntity>>
    getScope(@Nonnull final StitchingScopeFactory<StitchingEntity> stitchingScopeFactory,
            long targetId) {
        return Optional.of(
                stitchingScopeFactory.probeEntityTypeScope(SDKProbeType.VCENTER.getProbeType(),
                        EntityType.VIRTUAL_MACHINE));
    }

    @Nonnull
    @Override
    public EntityType getInternalEntityType() {
        return EntityType.DESKTOP_POOL;
    }

    @Nonnull
    @Override
    public Optional<EntityType> getExternalEntityType() {
        return Optional.of(EntityType.VIRTUAL_MACHINE);
    }

    @Override
    public Collection<String> getInternalSignature(@Nonnull final StitchingEntity internalEntity) {
        return getMasterImage(internalEntity).map(master -> Collections.singleton(
                generateInternalSignature(master, internalEntity.getEntityBuilder().getId())))
                .orElse(Collections.emptySet());
    }

    @Override
    protected Collection<String> getExternalSignature(@Nonnull final StitchingEntity externalEntity) {
        final String entityId = externalEntity.getEntityBuilder().getId();
        final Collection<String> desktopPoolIds = masterVMToDesktopPools.removeAll(entityId);
        if (CollectionUtils.isEmpty(desktopPoolIds)) {
            return Collections.emptySet();
        }
        return desktopPoolIds;
    }

    @Nonnull
    @Override
    public TopologicalChangelog stitch(@Nonnull final Collection<StitchingPoint> stitchingPoints,
                                       @Nonnull final StitchingChangesBuilder<StitchingEntity> resultBuilder) {

        for (StitchingPoint stitchingPoint : stitchingPoints) {
            if (stitchingPoint.getExternalMatches().size() == 0) {
                logger.error("No external matches found for internal entity {}",
                        stitchingPoint.getInternalEntity().getEntityBuilder().toString());
                continue;
            }
            if (stitchingPoint.getExternalMatches().size() > 1) {
                logger.warn("Encountered more than one VM with the same uuid for stitching point" +
                        " and will continue stitching with the first match {}.",
                        stitchingPoint.getInternalEntity().getEntityBuilder().toString());
            }
            final Optional<? extends StitchingEntity> vmEntity = stitchingPoint.getExternalMatches()
                    .stream().findFirst();
            if (!vmEntity.isPresent()) {
                return resultBuilder.build();
            }
            resultBuilder.queueUpdateEntityAlone(stitchingPoint.getInternalEntity(),
                    entityToUpdate -> updateMasterImage(entityToUpdate, vmEntity.get()));
        }
        return resultBuilder.build();

    }

    private void updateMasterImage(final StitchingEntity entityToUpdate,
                                   final StitchingEntity vmEntity) {
        final Builder dpBuilder = entityToUpdate.getEntityBuilder();
        VirtualDatacenterData.Builder vdcDataBuilder = dpBuilder.getVirtualDatacenterDataBuilder();
        DesktopPoolData.Builder dpPoolDataBuilder = vdcDataBuilder.getDesktopPoolDataBuilder();
        dpPoolDataBuilder.setMasterImage(String.valueOf(vmEntity.getOid())).build();
        vdcDataBuilder.setDesktopPoolData(dpPoolDataBuilder.build());
        dpBuilder.setVirtualDatacenterData(vdcDataBuilder.build()).build();
    }
}
