package com.vmturbo.stitching.vdi;

import java.util.Collection;
import java.util.Collections;
import java.util.Optional;

import javax.annotation.Nonnull;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.util.CollectionUtils;

import com.vmturbo.platform.common.dto.CommonDTO.EntityDTO.Builder;
import com.vmturbo.platform.common.dto.CommonDTO.EntityDTO.DesktopPoolData;
import com.vmturbo.platform.common.dto.CommonDTO.EntityDTO.EntityType;
import com.vmturbo.platform.common.dto.CommonDTO.EntityDTO.VirtualDatacenterData;
import com.vmturbo.platform.sdk.common.util.SDKProbeType;
import com.vmturbo.stitching.StitchingEntity;
import com.vmturbo.stitching.StitchingOperation;
import com.vmturbo.stitching.StitchingPoint;
import com.vmturbo.stitching.StitchingScope;
import com.vmturbo.stitching.StitchingScope.StitchingScopeFactory;
import com.vmturbo.stitching.TopologicalChangelog;
import com.vmturbo.stitching.TopologicalChangelog.StitchingChangesBuilder;

/**
 * Stitching Operation to resolve the vm reference id in the desktop pool. The probe sends in the master image
 * as the uuid of underlying VC Virtual Machine and this needs to be resolved to the OID
 * generated by the Topology Processor. In addition, we will be adding the master image source
 * property to entity properties to identify if the UID was a VM.
 */
public class DesktopPoolMasterImageStitchingOperation implements StitchingOperation<String, String> {
    private static final String SEPARATOR = "_";
    private final Logger logger = LogManager.getLogger();

    // master image VM id -> associated desktop pools
    private final Multimap<String, String> masterVMToDesktopPools = HashMultimap.create();

    @Nonnull
    @Override
    public Optional<StitchingScope<StitchingEntity>>
    getScope(@Nonnull final StitchingScopeFactory<StitchingEntity> stitchingScopeFactory,
            long targetId) {
        return Optional.of(
                stitchingScopeFactory.probeEntityTypeScope(SDKProbeType.VCENTER.getProbeType(),
                        EntityType.VIRTUAL_MACHINE));
    }

    @Nonnull
    @Override
    public EntityType getInternalEntityType() {
        return EntityType.DESKTOP_POOL;
    }

    @Nonnull
    @Override
    public Optional<EntityType> getExternalEntityType() {
        return Optional.of(EntityType.VIRTUAL_MACHINE);
    }

    @Override
    public Collection<String> getInternalSignature(@Nonnull final StitchingEntity internalEntity) {
        if (!internalEntity.getEntityBuilder().hasVirtualDatacenterData() ||
                !internalEntity.getEntityBuilder().getVirtualDatacenterData().hasDesktopPoolData()
                || !internalEntity.getEntityBuilder().getVirtualDatacenterData()
                .getDesktopPoolData().hasMasterImage()) {
            return Collections.emptySet();
        }
        final Builder entityBuilder = internalEntity.getEntityBuilder();
        final String entityId = entityBuilder.getId();
        final String masterImage = entityBuilder
            .getVirtualDatacenterData().getDesktopPoolData().getMasterImage();
        // composite signature comprising desktop pool id and master image id, as there may be more
        // than one desktop pool associated with given master image
        final String signature = entityId + SEPARATOR + masterImage;
        // keep track of signatures associated with master image, so that lookup key can be retrieved
        // later for master image
        masterVMToDesktopPools.put(masterImage, signature);
        return Collections.singleton(signature);
    }

    /** {@inheritDoc}
     * <p></p>
     * NOTE: this implementation assumes
     * {@link DesktopPoolMasterImageStitchingOperation#getInternalSignature }
     * is called first to populate the map that tracks desktop pools associated with master image.
     */
    @Override
    public Collection<String> getExternalSignature(@Nonnull final StitchingEntity externalEntity) {
        final String entityId = externalEntity.getEntityBuilder().getId();
        final Collection<String> desktopPoolIds = masterVMToDesktopPools.removeAll(entityId);
        if (CollectionUtils.isEmpty(desktopPoolIds)) {
            return Collections.emptySet();
        }
        return desktopPoolIds;
    }

    @Nonnull
    @Override
    public TopologicalChangelog stitch(@Nonnull final Collection<StitchingPoint> stitchingPoints,
                                       @Nonnull final StitchingChangesBuilder<StitchingEntity> resultBuilder) {

        for (StitchingPoint stitchingPoint : stitchingPoints) {
            if (stitchingPoint.getExternalMatches().size() == 0) {
                logger.error("No external matches found for internal entity {}",
                        stitchingPoint.getInternalEntity().getEntityBuilder().toString());
                continue;
            }
            if (stitchingPoint.getExternalMatches().size() > 1) {
                logger.warn("Encountered more than one VM with the same uuid for stitching point" +
                        " and will continue stitching with the first match {}.",
                        stitchingPoint.getInternalEntity().getEntityBuilder().toString());
            }
            final Optional<? extends StitchingEntity> vmEntity = stitchingPoint.getExternalMatches()
                    .stream().findFirst();
            if (!vmEntity.isPresent()) {
                return resultBuilder.build();
            }
            resultBuilder.queueUpdateEntityAlone(stitchingPoint.getInternalEntity(),
                    entityToUpdate -> updateMasterImage(entityToUpdate, vmEntity.get()));
        }
        return resultBuilder.build();

    }

    private void updateMasterImage(final StitchingEntity entityToUpdate,
                                   final StitchingEntity vmEntity) {
        final Builder dpBuilder = entityToUpdate.getEntityBuilder();
        VirtualDatacenterData.Builder vdcDataBuilder = dpBuilder.getVirtualDatacenterDataBuilder();
        DesktopPoolData.Builder dpPoolDataBuilder = vdcDataBuilder.getDesktopPoolDataBuilder();
        dpPoolDataBuilder.setMasterImage(String.valueOf(vmEntity.getOid())).build();
        vdcDataBuilder.setDesktopPoolData(dpPoolDataBuilder.build());
        dpBuilder.setVirtualDatacenterData(vdcDataBuilder.build()).build();
    }
}
