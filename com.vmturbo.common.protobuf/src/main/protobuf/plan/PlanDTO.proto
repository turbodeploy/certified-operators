syntax = "proto2";
package plan;

option java_package = "com.vmturbo.common.protobuf.plan";

import "cost/CostNotification.proto";
import "topology/TopologyDTO.proto";
import "plan/PlanProject.proto";
import "plan/Scenario.proto";

// NB Informational (most) messages in this set of declarations are serialized in rdbms.
// They are not modifiable, only extendable.

message PlanInstance {
    // The plan ID. Plan ID is used as TopologyContextId.
    required int64 plan_id = 1;

    // ID of the plan input topology
    // This is generally the plan source topology output by the Market after performing
    // plan market scoping (but before running actual Market analysis).
    // In the case of plan-over-plan, this will be set to the projected_topology_id of the
    // previous plan which this plan is using as a starting point.
    optional int64 source_topology_id = 3;

    // The scenario to be applied over existing topology before running a plan
    // This is a deep-copy of the scenario at the creation time of the
    // plan instance. Subsequent changes to the scenario will not affect
    // this.
    optional Scenario scenario = 4;

    // ID of the projected topology generated by the market when the plan was run
    // (empty until the plan completes successfully)
    optional int64 projected_topology_id = 5;

    // ID of the action plan produced by the market (An action plan is a set of actions produced by
    // the market as a result of analyzing the topology or by cost component as a result of buy ri
    // recommendation)
    repeated int64 action_plan_id = 6;

    // If true, the history component has stats available for this plan instance.
    // TODO (roman, Jan 20 2016): This is more of an internal record, so maybe we can keep
    // track of it somewhere else.
    optional bool stats_available = 11;

    // The status of the notifications received by the plan orchestrator.
    optional PlanProgress plan_progress = 13;

    // The current status of the plan
    required PlanStatus status = 7;

    // The plan start time
    optional int64 start_time = 8;

    // The plan completion time
    optional int64 end_time = 9;

    // Message, describing the current status of the plan. Must be filled when status is FAILED
    // May be filled when status is IN_PROGRESS
    // Must not be filled when status is SUCCEEDED
    optional string status_message = 10;

    // The type of the plan project that this plan belongs to.
    optional PlanProjectType project_type = 12 [default = USER];

    // the user id that created the plan, if triggered by a human user. Will be set to "SYSTEM" if
    // the plan was created by the system.
    optional string created_by_user = 20;

    enum PlanStatus {
        // Plan is ready to be executed, but has not been
        // triggered.
        READY = 1;

        // Plan has been triggered, but execution has not started.
        QUEUED = 2;

        // Execution has started - retrieving topology, and preparing
        // it for analysis.
        CONSTRUCTING_TOPOLOGY = 3;

        // Plan execution is in progress
        RUNNING_ANALYSIS = 4;

        // Plan analysis completed. Waiting to collect results.
        WAITING_FOR_RESULT = 5;

        // Plan calculation succeeded
        SUCCEEDED = 6;

        // Plan calculation failed
        FAILED = 7;

        // Buy RI algorithm start
        STARTING_BUY_RI = 8;

        // Buy RI completed
        BUY_RI_COMPLETED = 9;

        // plan has been force-stopped by user
        STOPPED = 10;
    }
}

// The status of the notifications received by the plan orchestrator.
message PlanProgress {

    // The status of the notifications received by the plan orchestrator related to cost.
    optional cost.CostNotification.Status projected_cost_status = 1 [default = UNKNOWN];

    // The status of the notifications received by the plan orchestrator realted to RI Coverage.
    optional cost.CostNotification.Status projected_ri_coverage_status = 2 [default = UNKNOWN];

}

// A request to create a plan.
message CreatePlanRequest {
    //  ID of the plan input topology
    optional int64 topology_id = 2;

    // The id of scenario to be applied over existing topology before running a plan
    optional int64 scenario_id = 3;
}

message PlanId {
    required int64 plan_id = 1;
}

// Message that specifies a plan and associated scenario
message PlanScenario {
    // ID of the plan
    required int64 plan_id = 1;

    // ID of the scenario for the plan
    optional int64 scenario_id = 2;
}

message Empty {}

// Message that can hold plan instance, or may not.
message OptionalPlanInstance {
    // The plan instance, that is held.
    optional PlanInstance plan_instance = 1;
}

// Options for looking up plan instances.
message GetPlansOptions {
    // TODO: Support for pagination and filtering by user
}

// A service responsible for CRUD operations for plan instances.
service PlanService {
    // Create a runnable PlanInstance given the id of the topology to begin with
    // and the id of the Scenario to run. The resulting PlanInstance is persisted to the database.
    // Both the The scenario must already exist in the database or a Status.INTERNAL will be
    // signalled.
    //
    // @param createPlanRequest indicates the source topology id and the ID of a scenario to apply
    // @throws Status.INTERNAL if either the source topology or the scenario are not found
    rpc CreatePlan (CreatePlanRequest) returns (PlanInstance);

    // Update the scenario for an existing PlanInstance and persist the result back to the database.
    // The update does not impact the plan if currently running.
    //
    // @param PlanScenario the plan ID to update and the scenario id to store
    // @returns the updated PlanInstance
    // @throws Status.NOT_FOUND if the plan to be updated does not exist
    rpc UpdatePlanScenario (PlanScenario) returns (PlanInstance);

    // Get a PlanInstance from the Plan database by its ID.
    //
    // @param PlanId the ID of the PlanInstance to look for
    // @returns the PlanInstance for the given ID if found, or if not found the PlanInstance
    // will be "unset"
    rpc GetPlan(PlanId) returns (OptionalPlanInstance);

    // Delete a PlanInstance from the Plan database given the ID.
    // Also calls the Repository API to delete the "projected" topology ID, if any.
    //
    // @param PlanId the ID of the PlanInstance to delete
    // @throws Status.NOT_FOUND if there is no PlanInstance with the given ID
    // @throws Status.FAILED_PRECONDITION if the scenario to with the PlanInstance refers cannot
    // be deleted
    rpc DeletePlan(PlanId) returns (PlanInstance);

    // Get all the existing plan instances from the Plan database.
    //
    // @param GetPlansOptions TODO: Support for filtering by user
    // @returns a stream of all known PlanInstances filtered by the GetPlansOptions
    rpc GetAllPlans(GetPlansOptions) returns (stream PlanInstance);

    // Run an existing plan with the given info - topology id and scenario id
    // Put the plan instance in QUEUED state if criteria are met and initiate the analysis process.
    // The plan instance may remain in READY state if the maximum number
    // of concurrent plans has reached, or it may be executed by another process.
    //
    // @param PlanId the unique ID of the PlanInstance to run
    // @returns the PlanInstance for the given plan updated with the given
    // topologyId and scenarioId
    rpc RunPlan(PlanId) returns (PlanInstance);

    // Cancel an existing plan with the given info - topology id
    // Put the plan instance in STOPPED state if criteria are met and send a message to stop the analysis process.
    //
    // @param PlanId the unique ID of the PlanInstance to cancel
    // @returns the PlanInstance for the given plan updated with the given
    // topologyId
    rpc CancelPlan(PlanId) returns (PlanInstance);

    // Update a PlanInstance to implement plan-over-plan, based on a previous PlanInstance
    // updated with the given ScenarioId.
    //
    // Note:  The name is "CreatePlanOverPlan" even though the semantics are curently to update
    // the existing PlanInstance. There is discussion whether this should update or add a new entry
    // to a higher-level plan-list.  This depends on requirements not yet set by the UX team
    // for plan-over-plan operation, and so this implementation Update Existing Plan Instance,
    // will likely change.
    //
    // The topologyId for the plan is taken from the previous projectedTopologyId, and the
    // projectedTopologyId is reset to '0'.
    //
    // The updated PlanInstance is persisted to the database.
    //
    // @param PlanScenario the ID of the PlanInstance and the ID of the Scenario to apply
    // @returns a PlanInstance reflecting the given ScenarioID, and the new topologyId.
    rpc CreatePlanOverPlan(PlanScenario) returns (PlanInstance);

}
