syntax = "proto2";
package plan;

option java_package = "com.vmturbo.common.protobuf.plan";

import "cost/CostNotification.proto";
import "topology/TopologyDTO.proto";
import "plan/PlanProject.proto";
import "plan/PlanProgressStatusEnum.proto";
import "plan/Scenario.proto";

// NB Informational (most) messages in this set of declarations are serialized in rdbms.
// They are not modifiable, only extendable.
message PlanInstance {
    // The plan ID. Plan ID is used as TopologyContextId.
    required int64 plan_id = 1;

    // ID of the plan input topology
    // This is generally the plan source topology output by the Market after performing
    // plan market scoping (but before running actual Market analysis).
    // In the case of plan-over-plan, this will be set to the projected_topology_id of the
    // previous plan which this plan is using as a starting point.
    optional int64 source_topology_id = 3;

    // The scenario to be applied over existing topology before running a plan
    // This is a deep-copy of the scenario at the creation time of the
    // plan instance. Subsequent changes to the scenario will not affect
    // this.
    optional Scenario scenario = 4;

    // ID of the projected topology generated by the market when the plan was run
    // (empty until the plan completes successfully)
    optional int64 projected_topology_id = 5;

    // ID of the action plan produced by the market (An action plan is a set of actions produced by
    // the market as a result of analyzing the topology or by cost component as a result of buy ri
    // recommendation)
    repeated int64 action_plan_id = 6;

    // If true, the history component has stats available for this plan instance.
    // TODO (roman, Jan 20 2016): This is more of an internal record, so maybe we can keep
    // track of it somewhere else.
    optional bool stats_available = 11;

    // The status of the notifications received by the plan orchestrator.
    optional PlanProgress plan_progress = 13;

    // The current status of the plan
    required PlanStatus status = 7;

    // The plan start time
    optional int64 start_time = 8;

    // The plan completion time
    optional int64 end_time = 9;

    // Message, describing the current status of the plan. Must be filled when status is FAILED
    // May be filled when status is IN_PROGRESS
    // Must not be filled when status is SUCCEEDED
    optional string status_message = 10;

    // The type of the plan project that this plan belongs to.
    optional PlanProjectType project_type = 12 [default = USER];

    // the user id that created the plan, if triggered by a human user. Will be set to "SYSTEM" if
    // the plan was created by the system.
    optional string created_by_user = 20;

    // Plan name, on creation derived from Scenario.ScenarioInfo.Name
    optional string name = 21;

    // The ID of the plan project that this plan belongs to
    optional int64 plan_project_id = 22;

    enum PlanStatus {
        // Plan is ready to be executed, but has not been
        // triggered.
        READY = 1;

        // Plan has been triggered, but execution has not started.
        QUEUED = 2;

        // Execution has started - retrieving topology, and preparing
        // it for analysis.
        CONSTRUCTING_TOPOLOGY = 3;

        // Plan execution is in progress
        RUNNING_ANALYSIS = 4;

        // Plan analysis completed. Waiting to collect results.
        WAITING_FOR_RESULT = 5;

        // Plan calculation succeeded
        SUCCEEDED = 6;

        // Plan calculation failed
        FAILED = 7;

        // Buy RI algorithm start
        STARTING_BUY_RI = 8;

        // Buy RI completed
        BUY_RI_COMPLETED = 9;

        // plan has been force-stopped by user
        STOPPED = 10;
    }
}

// A notification about a change to a plan, broadcast from the plan orchestrator to any components
// that care to listen.
message PlanStatusNotification {
    // The plan changed status. This happens as the plan continues through its stages of execution,
    // until it eventually reaches a terminal state (SUCCEEDED, FAILED, or STOPPED).
    message StatusUpdate {
        // The id of the plan with the new status.
        required int64 plan_id = 1;

        // The new status of the plan.
        required PlanInstance.PlanStatus new_plan_status = 2;
    }

    // The plan was deleted. This can be user-triggered (clicked delete in UI) or system-triggered
    // (e.g. plan retention period exceeded). The plan no longer exists in the plan orchestrator.
    message PlanDeleted {
        // The id of the plan that got deleted.
        // Note - at the time the client receives the notification, this ID will no longer refer
        // to an actual plan known to the plan orchestrator.
        required int64 plan_id = 1;

        // The status of the plan before it was deleted.
        required PlanInstance.PlanStatus status_before_delete = 2;
    }

    // The type of notification.
    oneof type {
        // The plan changed state/status.
        StatusUpdate update = 1;

        // The plan got deleted and no longer exists.
        PlanDeleted delete = 2;
    }
}

// The status of the notifications received by the plan orchestrator.
message PlanProgress {
    // The status of the notifications received by the plan orchestrator related to cost.
    optional Status projected_cost_status = 1 [default = UNKNOWN];

    // The status of the notifications received by the plan orchestrator realted to RI Coverage.
    optional Status projected_ri_coverage_status = 2 [default = UNKNOWN];

    // The status of the market analysis run.  Re-using statuses defined in CostNotification.proto
    optional Status analysis_status = 3 [default = UNKNOWN];

    // If set, summary describing the source topology broadcast for this plan - including whether
    // or not it failed.
    //
    // If unset, the source topology for this plan is still being processed in the topology
    // processor.
    optional .topology.TopologySummary source_topology_summary = 10;
}

// A request to create a plan.
message CreatePlanRequest {
    //  ID of the plan input topology
    optional int64 topology_id = 2;

    // The id of scenario to be applied over existing topology before running a plan
    optional int64 scenario_id = 3;

    // Type of project that this plan is part of, e.g, cloud_migration.
    optional PlanProjectType project_type = 4;

    // Id of project that this plan is part of
    optional int64 plan_project_id = 5;

    // Name of the plan.
    optional string name = 6;
}

message PlanId {
    required int64 plan_id = 1;
}

// Message that specifies a plan and associated scenario
message PlanScenario {
    // ID of the plan
    required int64 plan_id = 1;

    // ID of the scenario for the plan
    optional int64 scenario_id = 2;
}


// Message that can hold plan instance, or may not.
message OptionalPlanInstance {
    // The plan instance, that is held.
    optional PlanInstance plan_instance = 1;
}

// Options for looking up plan instances.
message GetPlansOptions {
    // TODO: Support for pagination and filtering by user
}


//Message to update the PlanInstance
//Currently only support updating a plan's name
message UpdatePlanRequest {
    // ID of the plan
    required int64 plan_id = 1;

    // New name of the plan
    optional string name = 2;
}

// A service responsible for CRUD operations for plan instances.
service PlanService {
    // Create a runnable PlanInstance given the id of the topology to begin with
    // and the id of the Scenario to run. The resulting PlanInstance is persisted to the database.
    // Both the The scenario must already exist in the database or a Status.INTERNAL will be
    // signalled.
    //
    // @param createPlanRequest indicates the source topology id and the ID of a scenario to apply
    // @throws Status.INTERNAL if either the source topology or the scenario are not found
    rpc CreatePlan (CreatePlanRequest) returns (PlanInstance);

    // Update a PlanInstance and persist in DB.
    //
    // @param UpdatePlanRequest the plan ID to information to update
    // @returns the updated PlanInstance
    rpc UpdatePlan (UpdatePlanRequest) returns (PlanInstance);

    // Update the scenario for an existing PlanInstance and persist the result back to the database.
    // The update does not impact the plan if currently running.
    //
    // @param PlanScenario the plan ID to update and the scenario id to store
    // @returns the updated PlanInstance
    // @throws Status.NOT_FOUND if the plan to be updated does not exist
    rpc UpdatePlanScenario (PlanScenario) returns (PlanInstance);

    // Get a PlanInstance from the Plan database by its ID.
    //
    // @param PlanId the ID of the PlanInstance to look for
    // @returns the PlanInstance for the given ID if found, or if not found the PlanInstance
    // will be "unset"
    rpc GetPlan(PlanId) returns (OptionalPlanInstance);

    // Delete a PlanInstance from the Plan database given the ID.
    // Also calls the Repository API to delete the "projected" topology ID, if any.
    //
    // @param PlanId the ID of the PlanInstance to delete
    // @throws Status.NOT_FOUND if there is no PlanInstance with the given ID
    // @throws Status.FAILED_PRECONDITION if the scenario to with the PlanInstance refers cannot
    // be deleted
    rpc DeletePlan(PlanId) returns (PlanInstance);

    // Get all the existing plan instances from the Plan database.
    //
    // @param GetPlansOptions TODO: Support for filtering by user
    // @returns a stream of all known PlanInstances filtered by the GetPlansOptions
    rpc GetAllPlans(GetPlansOptions) returns (stream PlanInstance);

    // Run an existing plan with the given info - topology id and scenario id
    // Put the plan instance in QUEUED state if criteria are met and initiate the analysis process.
    // The plan instance may remain in READY state if the maximum number
    // of concurrent plans has reached, or it may be executed by another process.
    //
    // @param PlanId the unique ID of the PlanInstance to run
    // @returns the PlanInstance for the given plan updated with the given
    // topologyId and scenarioId
    rpc RunPlan(PlanId) returns (PlanInstance);

    // Cancel an existing plan with the given info - topology id
    // Put the plan instance in STOPPED state if criteria are met and send a message to stop the analysis process.
    //
    // @param PlanId the unique ID of the PlanInstance to cancel
    // @returns the PlanInstance for the given plan updated with the given
    // topologyId
    rpc CancelPlan(PlanId) returns (PlanInstance);

    // Update a PlanInstance to implement plan-over-plan, based on a previous PlanInstance
    // updated with the given ScenarioId.
    //
    // Note:  The name is "CreatePlanOverPlan" even though the semantics are curently to update
    // the existing PlanInstance. There is discussion whether this should update or add a new entry
    // to a higher-level plan-list.  This depends on requirements not yet set by the UX team
    // for plan-over-plan operation, and so this implementation Update Existing Plan Instance,
    // will likely change.
    //
    // The topologyId for the plan is taken from the previous projectedTopologyId, and the
    // projectedTopologyId is reset to '0'.
    //
    // The updated PlanInstance is persisted to the database.
    //
    // @param PlanScenario the ID of the PlanInstance and the ID of the Scenario to apply
    // @returns a PlanInstance reflecting the given ScenarioID, and the new topologyId.
    rpc CreatePlanOverPlan(PlanScenario) returns (PlanInstance);

}
