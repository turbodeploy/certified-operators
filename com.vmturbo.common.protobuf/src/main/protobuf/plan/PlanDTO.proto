syntax = "proto2";
package plan;

option java_package = "com.vmturbo.common.protobuf.plan";

import "setting/Setting.proto";

// A scenario specifies the changes to the topology, and changes to configuration
// to be used when running a plan.
message Scenario {
    // The ID of the scenario
    optional int64 id = 1;

    // Information describing the scenario
    optional ScenarioInfo scenario_info = 2;
}

// Information describing the scenario.
message ScenarioInfo {
    // The name of the scenario
    optional string name = 1;

    // The list of changes to be made
    repeated ScenarioChange changes = 2;

    // The "type" of the scenario - for example "ADD_WORKLOAD", "DECOMMISION_HOST" - as specified
    // in the API.
    // We use a string instead of an enum because at the time of this writing the source of truth
    // for available types is the UI (!!!), and the type of a scenario has no server-side effect.
    // Its main purpose is to limit the UI options presented to the user (e.g. with DECOMMISION_HOST
    // the user will only see changes related to removing hosts).
    //
    // (roman, June 1 2017): In the future, if there are many of these strings that we only need
    // to preserve for the UI, we can add a "metadata" message (or map), where "type" would be
    // one of the fields.
    optional string type = 3;
}

// A plan project is a container that acts as a context for a series of related (and/or interrelated)
// plan runs that happen on some schedule.
message PlanProject {
    // The ID of the plan project
    optional int64 plan_project_id = 1;

    // Information describing the plan project
    optional PlanProjectInfo plan_project_info = 2;
}

// Information describing the plan project.
message PlanProjectInfo {
    enum PlanProjectType {
        // A custom plan project is created by the user
        // and has no special behaviour/server-side code.
        CUSTOM = 0;

        // A headroom plan project is responsible for calculating
        // per-cluster headroom (i.e. how many VMs can still fit into the cluster).
        // There is always exactly one headroom plan project in the system.
        CLUSTER_HEADROOM = 1;
     }

    // The name of the plan project. Names should be unique.
    // This field should always be present.
    optional string name = 1;

    // How often to run the plan project.
    // Running the plan project involves running all the different plans required
    // to get the project's results.
    //
    // If this is not set, run this plan project on demand only.
    optional Recurrence recurrence = 3;

    // The type of the plan project
    optional PlanProjectType type = 4 [default = CUSTOM];

    // Create one plan for each cluster in the system.
    //
    // IMPORTANT:
    // If set, there should be no scenario in "scenarios" with "scope" set.
    //
    // When set:
    //    For each planProjScenario in "scenarios"
    //       For each cluster in the system
    //            Create a PlanProjectScenario with scope = cluster.id and
    //            scenario = planProjScenario.scenario
    //
    // Then run each of the created scenarios.
    optional bool per_cluster_scope = 10 [default = false];

    // The scenarios involved in this plan project.
    // Each scenario will run independently of the other.
    repeated PlanProjectScenario scenarios = 11;

    // A wrapper around a "regular" scenario to allow separate scopes
    // (and other properties) for the different scenarios that are part of
    // a plan project.
    message PlanProjectScenario {
        // Static scope to apply this scenario to.
        // If set, apply the changes in the scenario to whatever entities the scope
        // resolves to (which will be some subset of the topology).
        // If not set, apply the changes in the scenario to the entire topology.
        optional StaticScope scope = 1;

        // The scenario changes to apply. This captures the topology and settings-related changes
        // that need to be made to the entities in the selected scope.
        repeated ScenarioChange changes = 2;
    }

    // A statically configured scope.
    // The scope can be resolved to a specific subset of a topology.
    message StaticScope {
        // The oids of groups in the scope.
        repeated int64 id = 1;
    }
}

// Used to deserialize a collection of SPlanProjectInfo from a single JSON file
message PlanProjectInfoCollection {
    repeated PlanProjectInfo plan_project_info = 1;
}

// The Recurrence of the execution
message Recurrence {
    // The schedule of the recurrence.
    // This determines the days on which to run the project.
    optional Schedule schedule = 1;

    // The time of the run in the days determined by schedule.
    optional TimeOfRun time_of_run = 2;

    message Daily {}

    enum DayOfWeek {
        MON = 1;
        TUE = 2;
        WED = 3;
        THU = 4;
        FRI = 5;
        SAT = 6;
        SUN = 7;
    }

    message Weekly {
        // specify the day(s) of the week, default to Sunday
        optional DayOfWeek day_of_week = 1;
    }

    message Monthly {
        // specify the day(s) of the month (1-31). default to first day of the month
        optional int32 day_of_month = 1 [default = 1];
    }

    message TimeOfRun {
        // specify the hour in a day (0-23), default to 4AM
        optional int32 hour = 1 [default = 4];
    }

    message Schedule {
        oneof recurrence {
            Daily daily = 1;
            Weekly weekly = 2;
            Monthly monthly = 3;
        }
    }
}

message GetPlanProjectRequest {
    required int64 project_id = 1;
}

message GetPlanProjectResponse {
    // If set, the get the plan project
    // Will be unset if the project_id in
    // the request referred to a non-existing plan project.
    optional PlanProject project = 1;
}

message DeletePlanProjectRequest {
    required int64 project_id = 1;
}

message DeletePlanProjectResponse {
    // If set, the deleted project_id.
    // Will be unset if the project_id in
    // the request referred to a non-existing plan project.
    optional int64 project_id = 1;
}

message ScenarioChange {
    // Specific details about the change that should be made. Can be one of many different cases.
    oneof details {
        TopologyAddition topology_addition = 15;
        TopologyRemoval topology_removal = 16;
        TopologyReplace topology_replace = 17;

        SettingOverride setting_override = 21;
    };

    // A change to supply or demand made by cloning an entity in the topology
    message TopologyAddition {
        // How many days in the future to apply the change. More than one value in the list means that the change
        // will be repeated, once at each time in the list. The list should be in ascending order and all members
        // should be >= 0.
        repeated int32 change_application_days = 1;

        // The number of times the entity will be cloned. Should be a positive number.
        optional int32 addition_count = 2;

        // The id of the entity or template to be cloned addition_count times
        oneof entity_or_template_or_group_id {
            int64 entity_id = 16;
            int64 template_id = 17;
            int64 group_id = 18;
        }
    }

    // A change to supply or demand made by removing an entity from the topology
    message TopologyRemoval {
        // How many days in the future to apply the change. More than one value in the list means that the change
        // will be repeated, once at each time in the list. The list should be in ascending order and all members
        // should be >= 0.
        optional int32 change_application_day = 1;

        // The id of the entity or group to be removed
        oneof entity_or_group_id {
            int64 entity_id = 16;
            int64 group_id = 17;
        }
    }

    // A change to supply or demand made by cloning an entity in the topology
    // With a replace, commodity constraints and relationships are copied from the removed entity
    // onto the entity being added.
    message TopologyReplace {
        // How many days in the future to apply the change. More than one value in the list means that the change
        // will be repeated, once at each time in the list. The list should be in ascending order and all members
        // should be >= 0.
        optional int32 change_application_day = 1;

        // The id of the template to replace the items being removed in the change.
        optional int64 add_template_id = 2;

        // The id of the entity or template to be cloned addition_count times
        oneof entity_or_group_removal_id {
            int64 remove_entity_id = 16;
            int64 remove_group_id = 17;
        }
    }

    // A change to set the value of some setting to some particular value.
    message SettingOverride {
        // The setting to override.
        optional .setting.Setting setting = 1;

        // If present, the entity type to override the setting for.
        // This is one of the ways to narrow down setting overrides.
        optional int32 entity_type = 2;
    }
}

message ScenarioList {
    repeated Scenario scenarios = 1;
}

message ScenarioId {
    optional int64 scenario_id = 1;
}

message PlanInstance {
    // The plan ID. Plan ID is used as TopologyContextId.
    required int64 plan_id = 1;

    //  ID of the plan input topology
    optional int64 topology_id = 3;

    // The scenario to be applied over existing topology befor run a plan
    // This is a deep-copy of the scenario at the creation time of the
    // plan instance. Subsequent changes to the scenario will not affect
    // this.
    optional Scenario scenario = 4;

    // ID of the projected topology generated by the market when the plan was run
    // (empty until the plan completes successfully)
    optional int64 projected_topology_id = 5;

    // ID of the action plan produced by the market (An action plan is a set of actions produced by
    // the market as a result of analyzing the topology)
    optional int64 action_plan_id = 6;

    // If true, the history component has stats available for this plan instance.
    // TODO (roman, Jan 20 2016): This is more of an internal record, so maybe we can keep
    // track of it somewhere else.
    optional bool stats_available = 11;

    // The current status of the plan
    required PlanStatus status = 7;

    // The plan start time
    optional int64 start_time = 8;

    // The plan completion time
    optional int64 end_time = 9;

    // Message, describing the current status of the plan. Must be filled when status is FAILED
    // May be filled when status is IN_PROGRESS
    // Must not be filled when status is SUCCEEDED
    optional string status_message = 10;

    enum PlanStatus {
        // Plan is ready to be executed, but has not been
        // triggered.
        READY = 1;

        // Plan has been triggered, but execution has not started.
        QUEUED = 2;

        // Execution has started - retrieving topology, and preparing
        // it for analysis.
        CONSTRUCTING_TOPOLOGY = 3;

        // Plan execution is in progress
        RUNNING_ANALYSIS = 4;

        // Plan analysis completed. Waiting to collect results.
        WAITING_FOR_RESULT = 5;

        // Plan calculation succeeded
        SUCCEEDED = 6;

        // Plan calculation failed
        FAILED = 7;
    }
}

// A request to create a plan.
message CreatePlanRequest {
    //  ID of the plan input topology
    optional int64 topology_id = 2;

    // The id of scenation to be applied over existing topology befor run a plan
    optional int64 scenario_id = 3;
}

message PlanId {
    required int64 plan_id = 1;
}

// Message that specifies a plan and associated scenario
message PlanScenario {
    // ID of the plan
    required int64 plan_id = 1;

    // ID of the scenario for the plan
    optional int64 scenario_id = 2;
}

message Empty {}

// Message that can hold plan instance, or may not.
message OptionalPlanInstance {
    // The plan instance, that is held.
    optional PlanInstance plan_instance = 1;
}

// Options for looking up plan instances.
message GetPlansOptions {
    // TODO: Support for pagination and filtering by user
}

// Options for looking up scenarios.
message GetScenariosOptions {
    // TODO: Support for pagination and filtering by user
}

message UpdateScenarioRequest {
    required int64 scenario_id = 1;

    // If set, overrides the scenario's info with
    // this info.
    optional ScenarioInfo new_info = 2;

    // (roman, Dec 8 2016): If necessary we can provide
    // other options to allow partial edits of the scenario
    // info. Addition of new ScenarioChanges is easy. Deletion
    // of ScenarioChanges is a bit more difficult.
}

message UpdateScenarioResponse {
    // If set, the updated scenario.
    // Will be unset if the scenario_id in
    // the request refers to a non-existing scenario.
    optional Scenario scenario = 1;
}

message DeleteScenarioRequest {
    // The ID of the scenario to delete.
    required int64 scenario_id = 1;
}

message DeleteScenarioResponse {
    // If set, the deleted scenario.
    // Will be unset if the scenario_id in
    // the request referred to a non-existing scenario.
    optional Scenario scenario = 1;
}

// A service responsible for CRUD operations for plan scenarios.
// A PlanScenario contains a list, possibly empty, of ScenarioChange objects to be applied to
// a topology prior to execution. PlanScenarios are persisted to the Plan database.
service ScenarioService {

    // Create a scenario given the information about a scenario.
    // The newly created Scenario will be persisted to the Plan database.
    //
    // @returns the newly created scenario
    rpc CreateScenario (ScenarioInfo) returns (Scenario);

    // Get a scenario by its ID.
    // Searches the scenarios persisted previously to the Plan database.
    //
    // @parameter ScenarioId indicates the ID of the scenario to search for.
    // @returns the Scenario with the given ID; if not found, the scenario_info will not be set
    rpc GetScenario(ScenarioId) returns (Scenario);

    // Get scenarios from the Plan database, filtered by certain options.
    // Currently there are no filter options, and so this call returns all the known scenarios.
    //
    // @parameter GetScenarioOptions options for paginating and filtering known scenarios - not impl.
    // @returns a stream of Scenario objects that match the filters.
    rpc GetScenarios(GetScenariosOptions) returns (stream Scenario);

    // Update an existing scenario given the ID and a new ScenarioInfo.
    // Replaces all the fields of the scenario from the new ScenarioInfo.
    // The ScenarioInfo is persisted to the database with the same ID as before.
    //
    // @param UpdateScenarioRequest the ID of the scenario to be updated, and the ScenarioInfo
    // to be stored
    // @returns the ID of the Scenario updated if found; else the ID in the response will be unset
    rpc UpdateScenario(UpdateScenarioRequest) returns (UpdateScenarioResponse);

    // Delete an existing scenario from the Plan database.
    // Note that, since we store the PlanInstances as blobs, we cannot check that no PlanInstance
    // depends on the Scenario to be deleted.
    //
    // @param ScenarioId the unique ID of the scenario to be deleted
    // @returns the ID of the Scenario that was deleted, if found,
    // or the ID in the response will be unset if not found.
    rpc DeleteScenario(ScenarioId) returns (DeleteScenarioResponse);
}

// A service responsible for CRUD operations for plan project.
// A plan project contains:
// * An ID
// * A name
// * A list of Plan Scenarios
// * Recurrence information - when and how often the plan project will be executed
// Plan project will be persisted to the Plan database.
service PlanProjectService {

    // Create a project given the information about a project.
    // The newly created Project will be persisted to the Plan database.
    //
    // @returns the newly created project
    rpc CreatePlanProject (PlanProjectInfo) returns (PlanProject);

    // Get a project by its ID.
    // Searches the plan project persisted previously to the Plan database.
    //
    // @parameter GetPlanProjectRequest indicates the ID of the plan project to search for.
    // @returns the Project with the given ID; if not found, the PlanProject will not be set
    rpc GetPlanProject(GetPlanProjectRequest) returns (GetPlanProjectResponse);

    // Delete an existing plan project from the Plan database.
    //
    // @param DeletePlanProjectRequest the unique ID of the project to be deleted
    // @returns the ID of the Project that was deleted, if found,
    // or the ID in the response will be unset if not found.
    rpc DeletePlanProject(DeletePlanProjectRequest) returns (DeletePlanProjectResponse);
}

// A service responsible for CRUD operations for plan instances.
service PlanService {
    // Create a runnable PlanInstance given the id of the topology to begin with
    // and the id of the Scenario to run. The resulting PlanInstance is persisted to the database.
    // Both the The scenario must already exist in the database or a Status.INTERNAL will be
    // signalled.
    //
    // @param createPlanRequest indicates the source topology id and the ID of a scenario to apply
    // @throws Status.INTERNAL if either the source topology or the scenario are not found
    rpc CreatePlan (CreatePlanRequest) returns (PlanInstance);

    // Update the scenario for an existing PlanInstance and persist the result back to the database.
    // The update does not impact the plan if currently running.
    //
    // @param PlanScenario the plan ID to update and the scenario id to store
    // @returns the updated PlanInstance
    // @throws Status.NOT_FOUND if the plan to be updated does not exist
    rpc UpdatePlanScenario (PlanScenario) returns (PlanInstance);

    // Get a PlanInstance from the Plan database by its ID.
    //
    // @param PlanId the ID of the PlanInstance to look for
    // @returns the PlanInstance for the given ID if found, or if not found the PlanInstance
    // will be "unset"
    rpc GetPlan(PlanId) returns (OptionalPlanInstance);

    // Delete a PlanInstance from the Plan database given the ID.
    // Also calls the Repository API to delete the "projected" topology ID, if any.
    //
    // @param PlanId the ID of the PlanInstance to delete
    // @throws Status.NOT_FOUND if there is no PlanInstance with the given ID
    // @throws Status.FAILED_PRECONDITION if the scenario to with the PlanInstance refers cannot
    // be deleted
    rpc DeletePlan(PlanId) returns (PlanInstance);

    // Get all the existing plan instances from the Plan database.
    //
    // @param GetPlansOptions TODO: Support for filtering by user
    // @returns a stream of all known PlanInstances filtered by the GetPlansOptions
    rpc GetAllPlans(GetPlansOptions) returns (stream PlanInstance);

    // Run an existing plan with the given info - topology id and scenario id
    //
    // @param PlanId the unique ID of the PlanInstance to run
    // @returns the PlanInstance for the given plan updated with the given
    // topologyId and scenarioId
    rpc RunPlan(PlanId) returns (PlanInstance);

    // Update a PlanInstance to implement plan-over-plan, based on a previous PlanInstance
    // updated with the given ScenarioId.
    //
    // Note:  The name is "CreatePlanOverPlan" even though the semantics are curently to update
    // the existing PlanInstance. There is discussion whether this should update or add a new entry
    // to a higher-level plan-list.  This depends on requirements not yet set by the UX team
    // for plan-over-plan operation, and so this implementation Update Existing Plan Instance,
    // will likely change.
    //
    // The topologyId for the plan is taken from the previous projectedTopologyId, and the
    // projectedTopologyId is reset to '0'.
    //
    // The updated PlanInstance is persisted to the database.
    //
    // @param PlanScenario the ID of the PlanInstance and the ID of the Scenario to apply
    // @returns a PlanInstance reflecting the given ScenarioID, and the new topologyId.
    rpc CreatePlanOverPlan(PlanScenario) returns (PlanInstance);

}
