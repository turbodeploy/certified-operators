syntax = "proto2";
package plan;

option java_package = "com.vmturbo.common.protobuf.plan";

// A scenario specifies the changes to the topology, and changes to configuration
// to be used when running a plan.
message Scenario {
    // The ID of the scenario
    optional int64 id = 1;

    // Information describing the scenario
    optional ScenarioInfo scenario_info = 2;
}

// Information describing the scenario.
message ScenarioInfo {
    // The name of the scenario
    optional string name = 1;

    // The list of changes to be made
    repeated ScenarioChange changes = 2;

    // The "type" of the scenario - for example "ADD_WORKLOAD", "DECOMMISION_HOST" - as specified
    // in the API.
    // We use a string instead of an enum because at the time of this writing the source of truth
    // for available types is the UI (!!!), and the type of a scenario has no server-side effect.
    // Its main purpose is to limit the UI options presented to the user (e.g. with DECOMMISION_HOST
    // the user will only see changes related to removing hosts).
    //
    // (roman, June 1 2017): In the future, if there are many of these strings that we only need
    // to preserve for the UI, we can add a "metadata" message (or map), where "type" would be
    // one of the fields.
    optional string type = 3;
}

message ScenarioChange {
    // Specific details about the change that should be made. Can be one of many different cases.
    oneof details {
        TopologyAddition topology_addition = 15;
        TopologyRemoval topology_removal = 16;
        TopologyReplace topology_replace = 17;
    };

    // A change to supply or demand made by cloning an entity in the topology
    message TopologyAddition {
        // How many days in the future to apply the change. More than one value in the list means that the change
        // will be repeated, once at each time in the list. The list should be in ascending order and all members
        // should be >= 0.
        repeated int32 change_application_days = 1;

        // The number of times the entity will be cloned. Should be a positive number.
        optional int32 addition_count = 2;

        // The id of the entity or template to be cloned addition_count times
        oneof entity_or_template_or_group_id {
            int64 entity_id = 16;
            int64 template_id = 17;
            int64 group_id = 18;
        }
    }

    // A change to supply or demand made by removing an entity from the topology
    message TopologyRemoval {
        // How many days in the future to apply the change. More than one value in the list means that the change
        // will be repeated, once at each time in the list. The list should be in ascending order and all members
        // should be >= 0.
        optional int32 change_application_day = 1;

        // The id of the entity or group to be removed
        oneof entity_or_group_id {
            int64 entity_id = 16;
            int64 group_id = 17;
        }
    }

    // A change to supply or demand made by cloning an entity in the topology
    // With a replace, commodity constraints and relationships are copied from the removed entity
    // onto the entity being added.
    message TopologyReplace {
        // How many days in the future to apply the change. More than one value in the list means that the change
        // will be repeated, once at each time in the list. The list should be in ascending order and all members
        // should be >= 0.
        optional int32 change_application_day = 1;

        // The id of the template to replace the items being removed in the change.
        optional int64 add_template_id = 2;

        // The id of the entity or template to be cloned addition_count times
        oneof entity_or_group_removal_id {
            int64 remove_entity_id = 16;
            int64 remove_group_id = 17;
        }
    }

}

message ScenarioList {
    repeated Scenario scenarios = 1;
}

message ScenarioId {
    optional int64 scenario_id = 1;
}

message PlanInstance {
    // The plan ID. Plan ID is used as TopologyContextId.
    required int64 plan_id = 1;

    //  ID of the plan input topology
    optional int64 topology_id = 3;

    // The scenario to be applied over existing topology befor run a plan
    // This is a deep-copy of the scenario at the creation time of the
    // plan instance. Subsequent changes to the scenario will not affect
    // this.
    optional Scenario scenario = 4;

    // ID of the projected topology generated by the market when the plan was run
    // (empty until the plan completes successfully)
    optional int64 projected_topology_id = 5;

    // ID of the action plan produced by the market (An action plan is a set of actions produced by
    // the market as a result of analyzing the topology)
    optional int64 action_plan_id = 6;

    // If true, the history component has stats available for this plan instance.
    // TODO (roman, Jan 20 2016): This is more of an internal record, so maybe we can keep
    // track of it somewhere else.
    optional bool stats_available = 11;

    // The current status of the plan
    required PlanStatus status = 7;

    // The plan start time
    optional int64 start_time = 8;

    // The plan completion time
    optional int64 end_time = 9;

    // Message, describing the current status of the plan. Must be filled when status is FAILED
    // May be filled when status is IN_PROGRESS
    // Must not be filled when status is SUCCEEDED
    optional string status_message = 10;

    enum PlanStatus {
        // Plan is ready to be executed, but has not been
        // triggered.
        READY = 1;

        // Plan has been triggered, but execution has not started.
        QUEUED = 2;

        // Execution has started - retrieving topology, and preparing
        // it for analysis.
        CONSTRUCTING_TOPOLOGY = 3;

        // Plan execution is in progress
        RUNNING_ANALYSIS = 4;

        // Plan analysis completed. Waiting to collect results.
        WAITING_FOR_RESULT = 5;

        // Plan calculation succeeded
        SUCCEEDED = 6;

        // Plan calculation failed
        FAILED = 7;
    }
}

// A request to create a plan.
message CreatePlanRequest {
    //  ID of the plan input topology
    optional int64 topology_id = 2;

    // The id of scenation to be applied over existing topology befor run a plan
    optional int64 scenario_id = 3;
}

message PlanId {
    required int64 plan_id = 1;
}

// Message that specifies a plan and associated scenario
message PlanScenario {
    // ID of the plan
    required int64 plan_id = 1;

    // ID of the scenario for the plan
    optional int64 scenario_id = 2;
}

message Empty {}

// Message that can hold plan instance, or may not.
message OptionalPlanInstance {
    // The plan instance, that is held.
    optional PlanInstance plan_instance = 1;
}

// Options for looking up plan instances.
message GetPlansOptions {
    // TODO: Support for pagination and filtering by user
}

// Options for looking up scenarios.
message GetScenariosOptions {
    // TODO: Support for pagination and filtering by user
}

message UpdateScenarioRequest {
    required int64 scenario_id = 1;

    // If set, overrides the scenario's info with
    // this info.
    optional ScenarioInfo new_info = 2;

    // (roman, Dec 8 2016): If necessary we can provide
    // other options to allow partial edits of the scenario
    // info. Addition of new ScenarioChanges is easy. Deletion
    // of ScenarioChanges is a bit more difficult.
}

message UpdateScenarioResponse {
    // If set, the updated scenario.
    // Will be unset if the scenario_id in
    // the request refers to a non-existing scenario.
    optional Scenario scenario = 1;
}

message DeleteScenarioRequest {
    // The ID of the scenario to delete.
    required int64 scenario_id = 1;
}

message DeleteScenarioResponse {
    // If set, the deleted scenario.
    // Will be unset if the scenario_id in
    // the request referred to a non-existing scenario.
    optional Scenario scenario = 1;
}

// A service responsible for CRUD operations for plan scenarios.
// A PlanScenario contains a list, possibly empty, of ScenarioChange objects to be applied to
// a topology prior to execution. PlanScenarios are persisted to the Plan database.
service ScenarioService {

    // Create a scenario given the information about a scenario.
    // The newly created Scenario will be persisted to the Plan database.
    //
    // @returns the newly created scenario
    rpc CreateScenario (ScenarioInfo) returns (Scenario);

    // Get a scenario by its ID.
    // Searches the scenarios persisted previously to the Plan database.
    //
    // @parameter ScenarioId indicates the ID of the scenario to search for.
    // @returns the Scenario with the given ID; if not found, the scenario_info will not be set
    rpc GetScenario(ScenarioId) returns (Scenario);

    // Get scenarios from the Plan database, filtered by certain options.
    // Currently there are no filter options, and so this call returns all the known scenarios.
    //
    // @parameter GetScenarioOptions options for paginating and filtering known scenarios - not impl.
    // @returns a stream of Scenario objects that match the filters.
    rpc GetScenarios(GetScenariosOptions) returns (stream Scenario);

    // Update an existing scenario given the ID and a new ScenarioInfo.
    // Replaces all the fields of the scenario from the new ScenarioInfo.
    // The ScenarioInfo is persisted to the database with the same ID as before.
    //
    // @param UpdateScenarioRequest the ID of the scenario to be updated, and the ScenarioInfo
    // to be stored
    // @returns the ID of the Scenario updated if found; else the ID in the response will be unset
    rpc UpdateScenario(UpdateScenarioRequest) returns (UpdateScenarioResponse);

    // Delete an existing scenario from the Plan database.
    // Note that, since we store the PlanInstances as blobs, we cannot check that no PlanInstance
    // depends on the Scenario to be deleted.
    //
    // @param ScenarioId the unique ID of the scenario to be deleted
    // @returns the ID of the Scenario that was deleted, if found,
    // or the ID in the response will be unset if not found.
    rpc DeleteScenario(ScenarioId) returns (DeleteScenarioResponse);
}

// A service responsible for CRUD operations for plan instances.
service PlanService {
    // Create a runnable PlanInstance given the id of the topology to begin with
    // and the id of the Scenario to run. The resulting PlanInstance is persisted to the database.
    // Both the The scenario must already exist in the database or a Status.INTERNAL will be
    // signalled.
    //
    // @param createPlanRequest indicates the source topology id and the ID of a scenario to apply
    // @throws Status.INTERNAL if either the source topology or the scenario are not found
    rpc CreatePlan (CreatePlanRequest) returns (PlanInstance);

    // Update the scenario for an existing PlanInstance and persist the result back to the database.
    // The update does not impact the plan if currently running.
    //
    // @param PlanScenario the plan ID to update and the scenario id to store
    // @returns the updated PlanInstance
    // @throws Status.NOT_FOUND if the plan to be updated does not exist
    rpc UpdatePlanScenario (PlanScenario) returns (PlanInstance);

    // Get a PlanInstance from the Plan database by its ID.
    //
    // @param PlanId the ID of the PlanInstance to look for
    // @returns the PlanInstance for the given ID if found, or if not found the PlanInstance
    // will be "unset"
    rpc GetPlan(PlanId) returns (OptionalPlanInstance);

    // Delete a PlanInstance from the Plan database given the ID.
    // Also calls the Repository API to delete the "projected" topology ID, if any.
    //
    // @param PlanId the ID of the PlanInstance to delete
    // @throws Status.NOT_FOUND if there is no PlanInstance with the given ID
    // @throws Status.FAILED_PRECONDITION if the scenario to with the PlanInstance refers cannot
    // be deleted
    rpc DeletePlan(PlanId) returns (PlanInstance);

    // Get all the existing plan instances from the Plan database.
    //
    // @param GetPlansOptions TODO: Support for filtering by user
    // @returns a stream of all known PlanInstances filtered by the GetPlansOptions
    rpc GetAllPlans(GetPlansOptions) returns (stream PlanInstance);

    // Run an existing plan with the given info - topology id and scenario id
    //
    // @param PlanId the unique ID of the PlanInstance to run
    // @returns the PlanInstance for the given plan updated with the given
    // topologyId and scenarioId
    rpc RunPlan(PlanId) returns (PlanInstance);

    // Update a PlanInstance to implement plan-over-plan, based on a previous PlanInstance
    // updated with the given ScenarioId.
    //
    // Note:  The name is "CreatePlanOverPlan" even though the semantics are curently to update
    // the existing PlanInstance. There is discussion whether this should update or add a new entry
    // to a higher-level plan-list.  This depends on requirements not yet set by the UX team
    // for plan-over-plan operation, and so this implementation Update Existing Plan Instance,
    // will likely change.
    //
    // The topologyId for the plan is taken from the previous projectedTopologyId, and the
    // projectedTopologyId is reset to '0'.
    //
    // The updated PlanInstance is persisted to the database.
    //
    // @param PlanScenario the ID of the PlanInstance and the ID of the Scenario to apply
    // @returns a PlanInstance reflecting the given ScenarioID, and the new topologyId.
    rpc CreatePlanOverPlan(PlanScenario) returns (PlanInstance);

}
