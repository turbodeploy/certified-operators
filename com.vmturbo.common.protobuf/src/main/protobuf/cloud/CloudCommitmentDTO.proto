syntax = "proto2";
package cloud_commitment_dto;

option java_package = "com.vmturbo.common.protobuf.cloud";
option java_outer_classname = "CloudCommitmentDTO";

import "CommonCost.proto";
import "CommonDTO.proto";
import "topology/TopologyDTO.proto";

enum CloudCommitmentType {
    RESERVED_INSTANCE = 1;
    TOPOLOGY_COMMITMENT = 2;
}

enum CloudCommitmentLocationType {
    AVAILABILITY_ZONE = 1;
    REGION = 2;
    GLOBAL = 3;


    CLOUD_COMMITMENT_LOCATION_UNKNOWN = 2047;
}

enum CloudCommitmentCoverageType {
    COUPONS = 1;
    SPEND_COMMITMENT = 2;
    COMMODITY = 3;
}

enum AccountReferenceType {
    // Filter for cloud commitments purchased by/in the reference in the filter.
    PURCHASED_BY = 0;

    // Filter for CCs that are covering entities in the reference (e.g. account/region) of the filter.
    USED_BY = 1;

    // Union of the previous two types.
    USED_AND_PURCHASED_BY = 2;
}

message AccountReferenceFilter {
    // A list of account ids need to filter by.
    repeated int64 account_id = 1;
    // describes the semantics of the passed account Ids.
    optional AccountReferenceType account_filter_type = 2 [default = PURCHASED_BY];
}

// a quantity of coupons or money
message CloudCommitmentAmount {
    oneof value {
        double coupons = 1;
        common_dto.CurrencyAmount amount = 2;
        common_dto.EntityDTO.CloudCommitmentData.CommittedCommoditiesBought commodities_bought = 3;
    }
}


enum CloudCommitmentCoverageGroupBy {
    COMMITMENT_COVERAGE_GROUP_BY_ACCOUNT = 1;
    COMMITMENT_COVERAGE_GROUP_BY_REGION = 2;
    COMMITMENT_COVERAGE_GROUP_BY_SERVICE_PROVIDER = 3;
    COMMITMENT_COVERAGE_GROUP_BY_CLOUD_SERVICE = 4;
}

enum CloudCommitmentUtilizationGroupBy {
    COMMITMENT_UTILIZATION_GROUP_BY_COMMITMENT = 1;
    COMMITMENT_UTILIZATION_GROUP_BY_ACCOUNT = 2;
    COMMITMENT_UTILIZATION_GROUP_BY_REGION = 3;
    COMMITMENT_UTILIZATION_GROUP_BY_SERVICE_PROVIDER = 4;
}

// Contains the (coverage type, coverage subtype) tuple, where coverage type with be
// spend amount, coupons, commodity capacity, etc and hte subtype meaning will be dependent on
// the coverage type. For spend-based coverage, the subtype will indicate the currency. For
// commodity capacity (e.g. GCP CUDs), the subtype will be the commodity type.
message CloudCommitmentCoverageTypeInfo {

    optional CloudCommitmentCoverageType coverage_type = 1;

    optional int32 coverage_subtype = 2;
}

message CloudCommitmentCoverage {
    //the coupons needed for the tier.
    optional CloudCommitmentAmount capacity = 1;
    // the coupons covered for the tier
    optional CloudCommitmentAmount used = 2;
}

message CloudCommitmentCoverageVector {

    optional CloudCommitmentCoverageTypeInfo vector_type = 1;

    optional double used = 2;

    optional double capacity = 3;
}

message ScopedCommitmentCoverage {

    optional int64 entity_oid = 1;

    optional int64 entity_type = 2;

    optional int64 account_oid = 3;

    optional int64 region_oid = 4;

    optional int64 zone_oid = 5;

    optional int64 cloud_service_oid = 6;

    optional int64 service_provider_oid = 7;

    repeated CloudCommitmentCoverageVector coverage_vector = 20;
}

message CloudCommitmentUtilization {

    // Used within scope of the current analysis (e.g. RT or by entities within the plan scope).
    optional CloudCommitmentAmount used = 1;

    // Used by undiscovered accounts or accounts/entities outside of a plan scope.
    optional CloudCommitmentAmount overhead = 2;

    optional CloudCommitmentAmount capacity = 3;
}

message CloudCommitmentUtilizationVector {

    optional CloudCommitmentCoverageTypeInfo vector_type = 1;

    optional double used = 2;

    optional double overhead = 3;

    optional double capacity = 4;
}

message CloudCommitmentUtilizationVectors {

    repeated CloudCommitmentUtilizationVector utilization_vector = 1;
}

message ScopedCommitmentUtilization {

    optional int64 cloud_commitment_oid = 1;

    optional int64 account_oid = 2;

    optional int64 region_oid = 3;

    optional int64 service_provider_oid = 4;

    repeated CloudCommitmentUtilizationVector utilization_vector = 21;
}

message CloudCommitmentMapping {
    optional int64 cloud_commitment_oid = 1;

    optional int64 entity_oid = 2;

    optional int32 entity_type = 3;

    optional CloudCommitmentAmount commitment_amount = 4;
}

message ProjectedCloudCommitmentMapping {

    // The ID of the projected topology the cost is for.
    optional int64 projected_topology_id = 1;

    oneof segment {
        Start start = 2;
        Data data = 3;
        End end = 4;
    }

    // Marker message, declaring the start of the broadcast
    message Start {
        // The basic information of the source topology
        optional .topology.TopologyInfo source_topology_info = 1;
    };

    // Message to hold real data of the commitment mappings
    message Data {
        // Some number of projected entity costs.
        repeated CloudCommitmentMapping projected_committed_mappings = 1;
    }

    // Message to appear at the very end of the broadcast
    message End {
        // Total number of costs sent (can be used for integrity checks)
        required uint64 total_count = 1;
    }
}

message CloudCommitmentEntityScope {

    optional common_dto.EntityDTO.CloudCommitmentData.CloudCommitmentScope scope_type = 1;

    oneof scope {
        EntityScope entity_scope = 10;
        GroupScope group_scope = 11;
    }

    message EntityScope {
        repeated int64 entity_oid = 1;
    }

    message GroupScope {
        repeated int64 group_id = 1;
    }
}

message CloudCommitmentLocation {

    optional CloudCommitmentLocationType location_type = 1 [default = CLOUD_COMMITMENT_LOCATION_UNKNOWN];

    optional int64 location_oid = 2;
}
