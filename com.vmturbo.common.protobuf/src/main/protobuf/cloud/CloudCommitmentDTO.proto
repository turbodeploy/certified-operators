syntax = "proto2";
package cloud_commitment_dto;

option java_package = "com.vmturbo.common.protobuf.cloud";
option java_outer_classname = "CloudCommitmentDTO";

import "CommonCost.proto";

enum CloudCommitmentType {
    RESERVED_INSTANCE = 1;
}

enum CloudCommitmentScope {
    BILLING_FAMILY = 1;
    ACCOUNT = 2;
}

enum CloudCommitmentLocation {
    AVAILABILITY_ZONE = 1;
    REGION = 2;
    GLOBAL = 3;
}

enum CloudCommitmentCoverageType {
    COUPONS = 1;
    SPEND_COMMITMENT = 2;
}

enum AccountReferenceType {
    // Filter for cloud commitments purchased by/in the reference in the filter.
    PURCHASED_BY = 0;

    // Filter for CCs that are covering entities in the reference (e.g. account/region) of the filter.
    USED_BY = 1;

    // Union of the previous two types.
    USED_AND_PURCHASED_BY = 2;
}

message AccountReferenceFilter {
    // A list of account ids need to filter by.
    repeated int64 account_id = 1;
    // describes the semantics of the passed account Ids.
    optional AccountReferenceType account_filter_type = 2 [default = PURCHASED_BY];
}

// a quantity of coupons or money
message CloudCommitmentAmount {
    oneof value {
        common_dto.CurrencyAmount amount = 1;
        double coupons = 2;
    }
}

message CloudCommitmentCoverage {
    //the coupons needed for the tier.
    optional CloudCommitmentAmount capacity = 1;
    // the coupons covered for the tier
    optional CloudCommitmentAmount used = 2;
}

message CloudCommitmentUtilization {

    // Used within scope of the current analysis (e.g. RT or by entities within the plan scope).
    optional CloudCommitmentAmount used = 1;

    // Used by undiscovered accounts or accounts/entities outside of a plan scope.
    optional CloudCommitmentAmount overhead = 2;

    optional CloudCommitmentAmount capacity = 3;
}

message CloudCommitmentMapping {
    optional int64 cloud_commitment_oid = 1;

    optional int64 entity_oid = 2;

    optional int32 entity_type = 3;

    optional CloudCommitmentAmount commitment_amount = 4;
}