syntax = "proto2";
package action;

option java_package = "com.vmturbo.common.protobuf.action";

import "common/EnvironmentTypeEnum.proto";
import "common/Pagination.proto";
import "topology/TopologyDTO.proto";
import "CloudCostDTO.proto";
import "CommonCost.proto";
import "cost/EntityUptime.proto";
import "cloud/CloudCommitmentDTO.proto";
import "cloud/CloudCommon.proto";

// NB All messages in this set of declarations are serialized in rdbms.
// They are not modifiable, only extendable.

// Action explanation.
message Explanation {
    oneof action_explanation_type {
        MoveExplanation move = 1;
        ResizeExplanation resize = 2;
        ActivateExplanation activate = 3;
        DeactivateExplanation deactivate = 4;
        ReconfigureExplanation reconfigure = 5;
        ProvisionExplanation provision = 6;
        DeleteExplanation delete = 7;
        BuyRIExplanation buyRI = 8;
        ScaleExplanation scale = 9;
        AllocateExplanation allocate = 10;
        AtomicResizeExplanation atomicResize = 11;
    }

    // A list of explanations for move action.
    message MoveExplanation {
        repeated ChangeProviderExplanation change_provider_explanation = 1;
        optional string scaling_group_id = 2;
    }

    // An explanation for Scale action.
    message ScaleExplanation {
        repeated ChangeProviderExplanation change_provider_explanation = 1;
        optional string scaling_group_id = 2;
    }

    message ChangeProviderExplanation {

        oneof change_provider_explanation_type {
            Compliance compliance = 1;
            Congestion congestion = 2;
            Evacuation evacuation = 3;
            InitialPlacement initialPlacement = 4;
            Performance performance = 5;
            Efficiency efficiency = 6;
        }

        enum WastedCostCategory {
            COMPUTE = 1;
            STORAGE = 2;
        }

        // This boolean should be set to true for simple moves, which have only one change provider.
        // In case of compound moves, we can have multiple change providers and multiple
        // change provider explanations. Generally, if a PM move is accompanied by a storage move,
        // the PM move is considered primary.
        // Indicates if this change provider explanation is the primary one.
        optional bool isPrimaryChangeProviderExplanation = 7;

        // A move explanation suggesting unavailability of commodities.
        message Compliance {
            // Deprecated - use missing_commodities.
            repeated topology.CommodityType __deprecated_missing_commodities = 1 [deprecated = true];

            // A list of commodities' base type which are missing in current supplier.
            repeated ReasonCommodity missing_commodities = 2;

            // A list of setting policy oids which caused this compliance action.
            // For ex. compliance actions that can be caused by template exclusion settings
            repeated int64 reason_settings = 3;

            // True if the compliance action is SOLELY because of CSG. We currently set this for
            // cloud VMs only. If a cloud action cannot be explained by itself, then we check if it
            // is a part of CSGs and set this flag.
            optional bool is_csg_compliance = 4;
        }

        // A move explanation suggesting commodity congestion.
        message Congestion {
            // Deprecated - use congested_commodities.
            repeated topology.CommodityType __deprecated_congested_commodities = 1 [deprecated = true];

            // Deprecated - use under_utilized_commodities.
            repeated topology.CommodityType __deprecated_under_utilized_commodities = 2 [deprecated = true];

            // For the cloud, true if increasing RI coverage is the main reason for the move
            optional bool __deprecated_is_ri_coverage_increased = 3 [deprecated = true];

            // A list of commodities' base type which are cheaper at the destination.
            // For the cloud, these are the commodities sold by the target entity which are
            // congested / over-utilized
            repeated ReasonCommodity congested_commodities = 4;

            // For the cloud, these are the commodities sold by the target entity which are
            // under-utilized
            repeated ReasonCommodity under_utilized_commodities = 5;

            optional bool is_wasted_cost = 6;

            optional WastedCostCategory wasted_cost_category = 7;
        }

        // A move explanation suggesting evacuation of buyers.
        message Evacuation {
            // A trader which was suspended so buyers of it should move out.
            required int64 suspended_entity = 1;

            // False if original supplier is in MAINTENANCE or FAILOVER state.
            optional bool is_available = 2 [default = true];

            // the reason for the evacuation.
            optional EvacuationExplanation evacuation_explanation = 3;
        }

        // list of explanations for evacuation.
        message EvacuationExplanation {
            oneof evacuation_type {
                Suspension suspension = 1;
                ReconfigureRemoval reconfigureRemoval = 2;
            }
        }

        // an evacuation explanation due to Suspension.
        message Suspension {}

        // an evacuation explanation due to ReconfigureRemoval.
        message ReconfigureRemoval {}

        // A move explanation suggesting initial placement of buyer.
        message InitialPlacement {}

        // A move explanation suggesting an overall performance improvement.
        message Performance {}

        // Efficiency messages are currently generated for the cloud.
        // We generate an efficiency message when we move the on-demand cost is cheaper at destination.
        message Efficiency {
            // Deprecated - use congested_commodities.
            repeated topology.CommodityType __deprecated_congested_commodities = 1 [deprecated = true];

            // Deprecated - use under_utilized_commodities.
            repeated topology.CommodityType __deprecated_under_utilized_commodities = 2 [deprecated = true];

            // True if increasing RI coverage is the main reason for the move
            optional bool is_ri_coverage_increased = 3;

            // These are the commodities sold by the target entity which are
            // congested / over-utilized
            // Efficiency category is only if all the commodities are under-utilized.
            // Under-utilized commodities are the drivers of efficiency action. So we are
            // deprecating congested_commodities which is part of Effciency.
            repeated ReasonCommodity __deprecated_congested_reason_commodities = 4 [deprecated = true];

            // These are the commodities sold by the target entity which are
            // under-utilized
            repeated ReasonCommodity under_utilized_commodities = 5;

            // If the action was purely because destination was cheaper
            optional bool is_wasted_cost = 6;

            // In many scenario even with an efficiency action, the destination commodity scales up.
            // This list captures those commodities.
            repeated topology.CommodityType scale_up_commodity = 7;

            optional WastedCostCategory wasted_cost_category = 8;
        }
    }

    // A resize explanation contains start and end utilization of the resize commodity.
    message ResizeExplanation {
        required float _deprecated_start_utilization = 1 [deprecated=true];
        required float _deprecated_end_utilization = 2 [deprecated=true];
        optional string scaling_group_id = 3;

        // The reason for the commodity being resized is populated for commodities with byProducts while resizing up.
        optional topology.CommodityType reason = 4;
    }

    // Explanation for the atomic resize action
    message AtomicResizeExplanation {
        // entity which executes the merged actions
        required string merge_group_id = 1;

        //target entities of each of the merged resize info object
        repeated int64 entity_ids = 2;

        // explanation for the individual resize info objects in the atomic resize
        repeated ResizeExplanationPerEntity per_entity_explanation = 3;

        message ResizeExplanationPerEntity {
            // original resize entities - multiple if the resize actions of all these entities
            // are de-duplicated and reduced to one resize
            repeated int64 resize_entity_ids = 2;

            // explanation for each commodity resize
            optional ResizeExplanationPerCommodity per_commodity_explanation = 3;

            // Id of entity
            optional int64 target_id = 4;

            message ResizeExplanationPerCommodity {
                 required topology.CommodityType commodity_type = 1;

                 // The reason for the commodity being resized is populated for commodities with byProducts while resizing up.
                 optional topology.CommodityType reason = 2;
            }

            // deprecated entity_id of type string.
            reserved 1;
            reserved "entity_id";
        }
    }

    // An activate explanation contains the base type of the most expensive commodity.
    message ActivateExplanation {
        optional int32 most_expensive_commodity = 1;
    }

    // Deactivate explanation will always be improve overall efficiency.
    message DeactivateExplanation {
        // Reconfigurable commodities of entity that is Deactivated.
        repeated topology.CommodityType reconfig_comm_types = 1;

        // Entity responsible for this suspend. This is the case for daemon suspensions.
        optional int64 reason_entity = 3;
    }

    // Delete - right now used for wasted files only
    message DeleteExplanation {
        // The size of the file to delete (needed for ON_PREM only)
        optional int64 size_kb = 1;

        // Modification time in UTC milliseconds since epoch (needed for ON_PREM only)
        optional int64 modification_time_ms = 2;
    }

    // Reconfigure explanation contains the base type of the reconfigure commodity.
    message ReconfigureExplanation {
        // Deprecated - use reconfigure_commodity.
        repeated topology.CommodityType __deprecated_reconfigure_commodity = 1 [deprecated = true];

        repeated ReasonCommodity reconfigure_commodity = 2;

        // A list of setting policy oids which caused this reconfigure action.
        // For ex. reconfigure actions that can be caused by template exclusion settings.
        repeated int64 reason_settings = 3;

        optional string scaling_group_id = 4;
    }

    message ProvisionExplanation {
        oneof provision_explanation_type {
            ProvisionBySupplyExplanation provision_by_supply_explanation = 1;
            ProvisionByDemandExplanation provision_by_demand_explanation = 2;
        }

        // Reconfigurable commodities of entity that is Provisioned.
        repeated topology.CommodityType reconfig_comm_types = 3;

        // Entity responsible for this clone. This is the case for daemon clones.
        optional int64 reason_entity = 4;

        // Provision by supply explanation contains the base type of the most expensive commodity.
        message ProvisionBySupplyExplanation {
            optional int32 most_expensive_commodity = 1 [deprecated=true];
            required ReasonCommodity most_expensive_commodity_info = 2;
        }

        // Provision by demand explanation
        message ProvisionByDemandExplanation {
            // The OID of the entity which has a shopping list that can't be satisfied by any provider.
            required int64 buyer_id = 1;

            // A list of entries keep information about commodities whose capacity needs to be changed to accommodate
            // the demand and their new capacity.
            repeated CommodityNewCapacityEntry commodity_new_capacity_entry = 2;

            // A list of entries keep commodities whose requested quantity can not be satisfied and
            // the max amount from any provider in market.
            repeated CommodityMaxAmountAvailableEntry commodity_max_amount_available = 5;

            // An entry in commodity to new capacity map. The key is base type of a commodity whose
            // capacity needs to be changed to satisfy the demand. The value is the new capacity for
            // that commodity.
            message CommodityNewCapacityEntry {
                // TODO: Change this to topology.CommodityType when M2 provides sufficient information to do so.
                required int32 commodity_base_type = 1;
                required float new_capacity = 2;
            }

            // An entry in commodity to max amount available from sellers map. The key is base type of a
            // commodity whose requested quantity can not be satisfied. The value is the max amount that
            // from any provider in market and the requested amount from the buyer.
            message CommodityMaxAmountAvailableEntry {
                // TODO: Change this to topology.CommodityType when M2 provides sufficient information to do so.
                required int32 commodity_base_Type = 1;
                required float max_amount_available = 2;
                required float requested_amount = 3;
            }
        }
    }

    message BuyRIExplanation {
        // How much demand of a particular context we have in terms of coupons.
        optional double totalAverageDemand = 1;

        // How much demand out of totalAverageDemand is covered in terms of coupons.
        optional double coveredAverageDemand = 2;

        // Estimated on demand cost of RI for the term of the RI
        optional double estimatedOnDemandCost = 3;
    }

    message AllocateExplanation {
        // Instance size family of the workload that is relocated to RI
        optional string instanceSizeFamily = 1;
        // TODO: Consider adding some details here, e.g. other scaling actions that freed up RI.
    }

    // Reference to a commodity causing the action, with extended per-commodity information.
    message ReasonCommodity {
        required topology.CommodityType commodity_type = 1;
        oneof reason_information {
            TimeSlotReasonInformation time_slot = 2;
        }
        // Slot info when action is caused by a time-slot analysis
        message TimeSlotReasonInformation {
            // the slot within a day
            required int32 slot = 1;
            // total number of slots in a day
            required int32 totalSlotNumber = 2;
        }
        //The reason may have a compound suffix, eg, if a move action is caused by the reservation
        //of CPU, not just usage of CPU, we show CPU reservation as action reason in UI.
        optional Suffix suffix = 3;
        enum Suffix {
            RESERVATION = 0;
        }
    }
}

// Merge a set of resize actions and generate one action.
// Market does not generate AtomicResizes.
// Action Orchestrator will receive resize actions from market and convert to AtomicResize actions
// based on the AtomicActionSpec received from the topology processor.
message AtomicResize {
    // Target entity that will execute all the resizes.
    // This entity corresponds to the aggregate entity in the AtomicActionSpec
    //
    // As an example, if a set of containers or VMs that are controlled by workload controllers,
    // then that workload controller is the execution target entity.
    // 1. VMs VM1, VM2, VM3 --> aggregated by -> VMSpecs VMS1 --> controlled by --> WorkloadController W1
    // Workload Controller W1 will execute the merged resize on the VMSpec VMS1 for VM1, VM2, VM3
    // 2. VMs VM4, VM5, VM6 --> controlled by -->  WorkloadController W2
    // Workload Controller W1 will execute the merged resize for VM4, VM5, VM6
    // 3. For a basic case of merging commodity resizes on an entity,
    // the entity itself is also the execution target
    //
    required ActionEntity execution_target = 1;

    // List of individual resizes
    // The original or de-duplicated resizes that will be executed by this action
    repeated ResizeInfo resizes = 2;
}

// Resize object that is created when one or more resize actions are to be merged..
message ResizeInfo {
    // the original resize entities
    repeated ActionEntity source_entities = 1;

    // Entity where the resize should take place
    // typically the entity that will de-duplicate the resize for a set of entities
    // or the original entity itself
    //
    // In the example of Container -> ContainerSpec -> WorkloadController,
    // actions of containers belonging to the container spec will be de-duplicated to a single action
    // and the resize will be performed on the container spec.
    // WorkloadController W1 --> owns -> ContainerSpecs CS1 --> aggregates --> Containers C1, C2, C3
    // Then the actions of C1,C2,C3 will be de-duplicated by CS1 and created as one action item
    // and the resize target is CS1.
    // In the basic case of merging commodity resizes on an entity,
    // where there is no de-duplication entity, the original resize entity is the target
    optional ActionEntity target = 2;

    // The commodity that is being resized.
    optional topology.CommodityType commodity_type = 3;

    // This may be old capacity/reservation/limit/etc, depending on commodity_attribute.
    optional float old_capacity = 4;

    // This may be new capacity/reservation/limit/etc, depending on commodity_attribute.
    optional float new_capacity = 5;

    // which specific attribute of the commodity should be resized? defaults to "capacity".
    optional topology.CommodityAttribute commodity_attribute = 6 [default = CAPACITY];

    // scaling group ID that the source entities belong to
    optional string scaling_group_id = 7;

    // currently configured cores per socket value
    optional int32 old_cpsr = 8 [default = 1];

    // desired cores per socket value
    optional int32 new_cpsr = 9 [default = 1];
}

// Change one or more providers of an entity.
message Move {
    // Entity whose providers are being changed.
    required ActionEntity target = 1;

    // Details of the providers changes
    repeated ChangeProvider changes = 2;

    // scaling group ID
    optional string scaling_group_id = 3;

    optional CloudSavingsDetails cloud_savings_details = 4;
}

// Scale an entity. Currently this action type is used to represent Cloud Move actions for
// workloads when they are moved from one template to another. Market doesn't generate Scale
// actions but Action Orchestrator translates Cloud Moves to Scale actions.
message Scale {
    // Entity that is scaled.
    required ActionEntity target = 1;

    // Details of each provider change.
    repeated ChangeProvider changes = 2;

    // Details of each commodity change.
    repeated ResizeInfo commodity_resizes = 3;

    // scaling group ID
    optional string scaling_group_id = 4;

    // Market can recommend scale volume actions where we the diskSize, IOPS or Throughput can be
    // scaled without tier change.
    // In this case we don't have information about current tier in change provider and we need to
    // get this information to be added to the action explanation.
    optional ActionEntity primary_provider = 5;

    // Defines the cloud cost details
    optional CloudSavingsDetails cloud_savings_details = 6;
}

message CloudSavingsDetails {
    // cost details of the source provider.
    optional TierCostDetails source_tier_cost_details = 1;
    //cost details of the projected provider.
    optional TierCostDetails projected_tier_cost_details = 2;

    message TierCostDetails {
        //on-demand rate of the tier.
        optional common_dto.CurrencyAmount on_demand_rate  = 1;
        //on demand cost of the tier.
        optional common_dto.CurrencyAmount on_demand_cost  = 2;
        //the cloud commitment info of the tier.
        optional cloud_commitment_dto.CloudCommitmentCoverage cloud_commitment_coverage = 3;
        // Commitment discounted rate (compute + on-demand-license + ri-license), without uptime.
        optional common_dto.CurrencyAmount discounted_rate = 4;
    }

    //the entity uptime.
    optional cost.EntityUptimeDTO entity_uptime = 3;
}

message ChangeProvider {

    // Market can recommend a move action with an empty source. In this case,
    // the action is generated in order to start the entity in the destination provider.
    // Current provider.
    optional ActionEntity source = 1;

    // New provider.
    optional ActionEntity destination = 2;

    // Resource moving. For ex. volume of a VirtualMachine - deprecated, use repeated resource
    optional ActionEntity __deprecated_resource = 3 [deprecated = true];

    // Related resources participating in the move. For ex. volumes of a VirtualMachine.
    repeated ActionEntity resource = 4;
}

message ActionEntity {
    // Both the fields are required.
    // ID of the entity provider.
    required int64 id = 1;

    // Type of the entity provider.
    required int32 type = 2;

    // The environment type of the entity.
    // This is used to infer which actions apply to which environments.
    optional .common.EnvironmentType environment_type = 3;
}

// Resize a commodity on a specific
// entity.
message Resize {
    // Entity where the resize should take place.
    required ActionEntity target = 1;

    // The commodity that's being resized.
    optional topology.CommodityType commodityType = 2;

    // This may be old capacity/reservation/limit/etc, depending on commodity_attribute.
    optional float old_capacity = 3;

    // This may be new capacity/reservation/limit/etc, depending on commodity_attribute.
    optional float new_capacity = 4;

    // which specific attribute of the commodity should be resized? defaults to "capacity".
    optional topology.CommodityAttribute commodity_attribute = 5 [default = CAPACITY];

    // whether or not this commodity supports hot add
    optional bool hot_add_supported = 6 [default = false];

    // whether or not this commodity supports hot remove
    optional bool hot_remove_supported = 7 [default = false];

    // scaling group ID
    optional string scaling_group_id = 8;

    // The supplier who triggers the resize
    // This field is not used now. Should be removed if the tests show that diags for 7.22.3-7.22.5 are loaded correctly.
    optional ActionEntity resize_trigger_trader = 9;

    // deprecated reason commodity being resized.
    reserved 10;
    reserved "reason";

    // currently configured cores per socket value
    optional int32 old_cpsr = 11 [default = 1];
    // desired cores per socket value
    optional int32 new_cpsr = 12 [default = 1];
}

// Activate an existing deactivated entity.
message Activate {
    // Entity to activate.
    required ActionEntity target = 1;

    // The in-demand commodities that triggered the activation
    // recommendation. These are guaranteed to be a subset of
    // the commodities sold by the entity.
    repeated topology.CommodityType triggering_commodities = 2;
}

// Deactivate an existing active entity.
message Deactivate {
    // Entity to deactivate.
    required ActionEntity target = 1;

    // The not-in-demand commodities that triggered the deactivation
    // recommendation. These are guaranteed to be a subset of
    // the commodities sold by the entity.
    repeated topology.CommodityType triggering_commodities = 2;
}

message Delete {
    // The oid of the entity going be deleted in the Action.
    // In case of storage, it is the Storage or Virtual Volume that the virtual volume that is wasted (for cloud)
    //   or the virtual volume which contains the wasted file (for on prem) is connected to.
    optional ActionEntity target = 1;

    // The path to the wasted file (on prem) or volume (cloud)
    optional string file_path = 2;

    // The oid of the Storage Tier which the wasted virtual volume belongs to (for cloud)
    optional ActionEntity source = 3;
}

// Represents an action to reconfigure an entity shopping list of a trader that contains a mix of
// commodities no trader is able to provide.
// An example of a Reconfigure action is when a VM is configured to run with some network (say "VLAN-1")
// but the host it is currently running on doesn't have this network configured (i.e. doesn't provide
// access to that network). From a market perspective, the VM is buying a NetworkCommodity with key "VLAN-1"
// but the host doesn't sell this commodity. The Reconfigure action tells the user that s/he needs to
// (re)configure the host to provide access to that network. It should be possible to automate the execution
// of this action, but I am not sure we have. Similarly when a VM is configured to use some storage that is
// not mounted on the host that the VM is currently running on. For both configuration issues, another remedy
// is to move the VM to a host that does have access to the network/storage.
message Reconfigure {
    // Entity to reconfigure.
    required ActionEntity target = 1;

    // The current supplier. Assumed null if missing. It is included for the cases where
    // a trader is buying a particular shopping list from a supplier that isn't supplying the
    // complete list and no supplier can supply the complete list.
    optional ActionEntity source = 2;

    // TODO (davidblinn, July 2016): We also need to record the shopping list that caused the change.

    // scaling group ID
    optional string scaling_group_id = 3;

    // If it is a provider reconfigure or consumer.
    optional bool is_provider = 4 [default = false];

    // If it is a reconfigure to add commodity or remove.
    optional bool is_addition = 5;

    // TODO this should not be here, it is describing semantics orthogonal to other Reconfigure actions
    repeated SettingChange setting_change = 6;

    message SettingChange {
        required float current_value = 1;
        required float new_value = 2;
        required topology.EntityAttribute entity_attribute = 3;
    }
}

// An action to provision an entity that matches another entity already existing in the system.
message Provision {
    // Entity to clone.
    required ActionEntity entity_to_clone = 1;

    // The OID of the newly provisioned entity (that does not yet exist in the system).
    // TODO: Make this non-negative per feedback from Jerry. Need to coordinate this with the market folks.
    // Since this is a special case, we will just use the EntityId. The entity
    // type will be the same as the entity_to_clone.
    optional sint64 provisioned_seller = 2;

    // There could be more than one provision action on an entity, this field is the index
    // (starting from zero) associated with each of those actions.
    optional int32 provision_index = 3;
}

// An action to Buy a reserved instance
message BuyRI {
    // The id of the buy ri. The id refers to the primary key in buy_reserved_instance table of
    // the cost database. The cost-component generates Buy RI recommendations and stores these
    // recommendations in the database.
    optional int64 buy_ri_id = 1;

    // The tier of the buy ri. For ex. for a Buy RI action like "Buy 2 t2.small RIs", the
    // compute_tier will be the t2.small entity
    optional ActionEntity compute_tier = 2;

    // The number of RI's recommended.
    optional int32 count = 3;

    // The master account for which we are buying this RI.
    optional ActionEntity masterAccount = 4;

    // The region in which we are buying this RI.
    optional ActionEntity region = 5;

    // MPC Buy RI Actions should be purchased for a target entity, not by an account
    optional ActionEntity targetEntity = 6;
}

// Reserved instance reallocation action (aka Accounting action). These actions are generated
// for VMs that are moved to reserved instances that became available because some other VMs were
// moved to different templates.
message Allocate {
    // Workload entity that benefits from RI reallocation.
    required ActionEntity target = 1;

    // Workload tier that workload belongs to. It can be Compute Tier, Database Tier or Database
    // Server Tier.
    required ActionEntity workloadTier = 2;

    // Defines the cloud cost details
    optional CloudSavingsDetails cloud_savings_details = 3;

    optional bool is_buy_recommendation_coverage = 4 [default = false];
}

// Contains the information describing the recommendation for what
// action should be executed in the environment.
message ActionInfo {
    // You can infer the ActionType enum to describe this action
    // based on which oneof field is set.
    oneof action_type {
        Move move = 1;
        Reconfigure reconfigure = 2;
        Provision provision = 3;
        Resize resize = 4;
        Activate activate = 5;
        Deactivate deactivate = 6;
        Delete delete = 7;
        BuyRI buyRi = 8;
        Scale scale = 9;
        Allocate allocate = 10;
        AtomicResize atomicResize = 11;
    }
}

// Used to specify the user executing an external action such as PMC suspend action.
// Only to be used for audit purposes. Should never use to provide Authorization.
message UserDetails{
    // Used to identify the username of the user triggering the action.
    required string user_name = 1;

    // Used to identify the uid of the user triggering the action.
    required string user_id = 2;
}

// Used to specify the Schedule executing an external action such as PMC suspend action.
// Only to be used for audit purposes. Should never use to provide Authorization.
message ScheduleDetails{
    // Used to identify the name of the schedule triggering the action.
    required string schedule_name = 1;

    // Used to identify the id of the schedule triggering the action.
    required string schedule_id = 2;
}

message ExecutorInfo{
    // Type-specific info depending on what is executing the Action.
    oneof executor_type{
        UserDetails user = 1;
        ScheduleDetails schedule = 2;
     }
}

message Action {
    // ID for the action.
    required int64 id = 1;

    required ActionInfo info = 2;

    // This field is deprecated - No longer used.
    // The importance signifies a relative weight of the action. The one with the higher
    // importance should be taken first.
    required double __deprecated__importance = 3 [deprecated=true];

    // The explanation for the action
    required Explanation explanation = 4;

    // Indicates whether the market considers the action to be executable based on its dependency
    // ordering of actions. There is a high likelihood of non-executable actions not succeeding
    // because another action should be executed first.
    optional bool executable = 5;

    // Indicates level of supporting of action by probe or not, depends on action
    // capabilities (policies) of probe.
    optional SupportLevel supportingLevel = 6;

    // Hourly savings if the action is taken.
    optional common_dto.CurrencyAmount savings_per_hour = 7;

    // Levels of supporting action by probe
    enum SupportLevel {
        // Unknown support level - up to the application to decide how to interpret this.
        // (note - we added this after UNSUPPORTED, so that unknown support levels wouldn't default
        // to SUPPORTED. But realistically it's probably best to treat this as equivalent to
        // UNSUPPORTED when encountering it in the code).
        UNKNOWN = 0;

        // Full support - will be shown an UI and may be executed
        SUPPORTED = 1;

        // Should be only shown in the UI, cannot be executed
        SHOW_ONLY = 2;

        // Shouldn't be shown, cannot be executed
        UNSUPPORTED = 3;
    }

    // A list of pre-requisites.
    // Pre-requisites of an action means that some pre-requisites need to be satisfied
    // in order to execute an action.
    repeated Prerequisite prerequisite = 8;

    message Prerequisite {
        // The type of pre-requisite
        optional PrerequisiteType prerequisite_type = 1;

        // The region in which a quota increase is requested, only apply to CORE_QUOTAS
        optional int64 region_id = 2;

        // The quota name for which a quota increase is requested, only apply to CORE_QUOTAS
        optional string quota_name = 3;

        // Read-only locks related message preventing (Azure) VM writes.
        optional string locks = 4;

        // Count of attached ephemeral disks - only used for GCP VM scaling for which execution
        // within Turbo is disallowed for VMs with Local SSDs attached, because VM guest OS
        // needs to be manually stopped.
        optional int32 attached_ephemeral_volumes = 5;

        // Minimum CPU platform for the VM.
        optional string min_cpu_platform = 6;
    }

    // The pre-requisite types supported
    enum PrerequisiteType {
        // AWS execution pre-requisites
        // ENA (Elastic Network Adapter) driver is necessary for access to
        // Enhanced Networking on AWS EC2 instances.
        ENA = 1;
        // NVMMe (non-volatile memory express) driver is necessary for access to
        // NVMMe block device such as EBS volumes and instance store volumes.
        NVME = 2;
        // Architecture can be 32-bit, 64-bit or arm64.
        ARCHITECTURE = 3;
        // Virtualization type can be HVM or PVM.
        VIRTUALIZATION_TYPE = 4;
        // Azure execution pre-requisites
        CORE_QUOTAS = 5;
        // Azure read-only locks preventing writes.
        LOCKS = 6;
        // Azure Scale Set preventing execution.
        SCALE_SET = 7;
        // Failed availability set preventing execution
        AVAILABILITY_SET = 8;
        // GCP restriction: Cannot execute action because of local SSDs attached (cannot stop VM).
        LOCAL_SSD_ATTACHED = 9;
        // GCP restriction: minimum compatible CPU platform set.
        MIN_CPU_PLATFORM = 10;
    }

    // Defines if actions is disruptive.
    optional bool disruptive = 9 [default = false];

    // Defines if actions is reversible.
    optional bool reversible = 10 [default = true];

    // Specifies the user information, because an external action such as a PMC suspend action
    // will not have a security context associated.
    // Only to be used for audit purposes.
    optional UserDetails __deprecated_user = 11 [deprecated = true];

    // Specifies the user information, because an external action such as a PMC suspend action
    // will not have a security context associated.
    // Only to be used for audit purposes.
    optional ExecutorInfo executor_info = 12;
}

// Auxiliary information for an action plan.
message ActionPlanInfo {
    // Type-specific info depending on which action plan this message describes.
    oneof type_info {
        // For actions generated by the market component every topology broadcast.
        MarketActionPlanInfo market = 7;

        // For actions generated by the Buy-RI algorithm in the cost component.
        BuyRIActionPlanInfo buy_ri = 8;

        // For actions send by  PMC to suspend/start a virtual machine.
        StartSuspendActionPlanInfo start_suspend = 9;
    }

    // Information about actions generated by the market component's analysis.
    message MarketActionPlanInfo {

        // Information about the topology the market analysis was applied to to generate the
        // actions.
        optional .topology.TopologyInfo source_topology_info = 1;
    }

    // Information about actions generated by the Buy-RI algorithm.
    message BuyRIActionPlanInfo {

        // The topology context ID these buy-RI actions apply to.
        // Used to distinguish between buy-RI actions in a plan vs. realtime.
        // TODO (roman, Feb 15 2019): It may be better to add TopologyType here.
        optional int64 topology_context_id = 1;
    }

    message StartSuspendActionPlanInfo {

        // The topology context ID these suspend actions apply to.
        optional int64 topology_context_id = 1;
    }
}

// Actions the market recommends.
message ActionPlan {
    // The ID of the plan.
    required int64 id = 1;

    // The timestamp at which the analysis that generated this action plan began.
    //
    // This timestamp is captured prior to constructing the economy for analysis.
    //
    // The time is in "system time" and not necessarily UTC, however, times on action plans
    // are comparable. See documentation in Java's System#currentTimeMillis() for further details.
    optional int64 analysis_start_timestamp = 4;

    // The timestamp at which the analysis that generated this action plan completed.
    //
    // The difference between this timestamp and the analysis_start_timestamp approximates
    // the time it took the market component to construct the economy and perform analysis.
    //
    // Note that these timestamps do NOT provide an indication of the time at which data for
    // the analysis was captured from the customer's infrastructure.
    optional int64 analysis_complete_timestamp = 5;

    // Additional information about the plan.
    // Should be set for every plan.
    optional ActionPlanInfo info = 7;

    // The actions in the action plan.
    repeated Action action = 17;

    // The ID of the topology this action plan applies to.
    // Deprecated - find the topology ID in the MarketActionPlanInfo.
    optional int64 __deprecated__topology_id = 2 [deprecated = true];

    // The ID of the topology context. Used to differentiate, for example, between real and plan contexts.
    //
    // If not set, it is an error.
    // Deprecated - Use ActionDTOUtil.getActionPlanContextId() or find the context ID in
    // MarketActionPlanInfo.source_topology_info or in BuyRIActionPlanInfo.topology_context_id.
    optional int64 __deprecated__topology_context_id = 3 [deprecated = true];

    // The type of action plan.
    // Deprecated - use type_info case and the ActionDTOUtil.getActionPlanType() method.
    optional ActionPlanType __deprecated__action_plan_type = 6 [deprecated = true];

    enum ActionPlanType {
        // Action Plan with Actions generated by Market.
        MARKET = 1;
        // Action Plan with Buy RI actions generated by Cost component.
        BUY_RI = 2;

        START_SUSPEND = 3;
    }

    // Map of action ID to list of corresponding MarketRelatedActions.
    //
    // For example, a map with the following contents:
    // {
    //  1234: [related_action_1, related_action_2],
    //  5678: [related_action_3]
    // }
    // indicates that the Action with ID 1234 contains related_action_1 and related_action_2, and
    // that the Action with ID 5678 contains related_action_3.
    //
    // We store related actions in a separate map rather than directly having the actions contain
    // their related actions because they are often generated and processed separately from the rest
    // of the action data.
    map<int64, MarketRelatedActionsList> related_actions_by_action_id = 18;

    // MarketRelatedActions list.
    message MarketRelatedActionsList {
        repeated MarketRelatedAction related_actions = 1;
    }
}

// A market related action is another action that has some relation to a given action.
//
// This includes related action data directly converted from RelatedActionTO in ActionTO from
// analysis in market component, and stored in ActionPlan to be sent to action-orchestrator. Note
// that the action_relation_type includes only one side of the relation, for example
// CausedByRelation, BlockedByRelation, etc. The other side (like CausingRelation and
// BlockingRelation) can be generated implicitly.
message MarketRelatedAction {
    // The ID of the related action.
    //
    // This references the original ID of the action. Note This action ID may only have meaning
    // within the original action plan context and is different from action recommendation ID
    // (not populated until the action is received by the action orchestrator), which is durable
    // and meaningful across many action plans.
    optional int64 action_id = 1;

    // Target entity this related action is generated on.
    optional ActionEntity action_entity = 2;

    // The type of relation.
    oneof action_relation_type {
        // Signifies that an action is caused by the related action.
        CausedByRelation caused_by_relation = 100;

        // Signifies that an action execution is blocked by the related action.
        BlockedByRelation blocked_by_relation = 101;
    }
}

// A related action is another action that has some relation to this one.

// This includes related action data converted from MarketRelatedAction from market component and
// populated in ActionSpec in action-orchestrator to be sent to api. Note that the
// action_relation_type includes symmetric relations, for example CausedByRelation and
// CausingRelation, BlockedByRelation and BlockingRelation, etc.
message RelatedAction {
    // The "stable" recommendation ID of the related action. This is the "stable" id shared by all
    // action instances that represent the same logical action. For example, all moves of VM 1
    // from Host 2 to Host 3 will have the same recommendation ID.
    //
    // Not populated until the action is received by the action orchestrator.
    optional int64 recommendation_id = 1;

    // Target entity this related action is generated on.
    optional ActionEntity action_entity = 2;

    // Target entity display name.
    optional string action_entity_display_name = 3;

    // Description of this related action.
    optional string description = 4;

    // The type of relation.
    oneof action_relation_type {
        // Signifies that an action is caused by the related action. This is symmetric to the
        // CausingRelation.
        CausedByRelation caused_by_relation = 100;

        // Signifies that an action causes the related action. This is symmetric to the
        // CausedByRelation.
        CausingRelation causing_relation = 101;

        // Signifies that an action execution is blocked by the related action. This is
        // symmetric to the BlockingRelation.
        BlockedByRelation blocked_by_relation = 102;

        // Signifies that this action blocks the execution of the related action. This is
        // symmetric to the BlockedByRelation.
        BlockingRelation blocking_relation = 103;
    }
}

// A causedBy relation signifies that an action is caused by the related action. Sometimes we
// generate an action caused by another action generation. For example, when a node (VM) in a
// container cluster are required to run a certain type of daemon pod, when we create an
// action to suspend this node in the cluster, we also generate a suspension on the daemon
// pod because daemon pod cannot be moved off the node. Likewise when we provision a node
// with a daemon pod, we will have an action to provision the daemon pod. In each case,
// daemon pod action will have a CausedByRelation to the node action.
// Note this is symmetric to the CausingRelation.
message CausedByRelation {
    oneof caused_by_relation_type {
        CausedBySuspension suspension = 1;
        CausedByProvision provision = 2;
    }

    // An action is caused by the related suspension action.
    message CausedBySuspension {}

    // An action is caused by the related provision action.
    message CausedByProvision {}
}

// A causing relation signifies that an action is causing the related action. Sometimes we
// generate an action which causes another action generation. For example, when a node (VM) in a
// container cluster are required to run a certain type of daemon pod, when we create an
// action to suspend this node in the cluster, we also generate a suspension on the daemon
// pod because daemon pod cannot be moved off the node. Likewise when we provision a node
// with a daemon pod, we will have an action to provision the daemon pod. In each case,
// the node action will have a CausingRelation to the daemon pod action.
// Note this is symmetric to the CausingRelation.
message CausingRelation {
    oneof causing_relation_type {
        CausingSuspension suspension = 1;
        CausingProvision provision = 2;
    }

    // An action causes the related suspension action.
    message CausingSuspension {}

    // An action causes the related provision action.
    message CausingProvision {}
}

// A blockedBy related signifies that an action execution is blocked by the related action.
// Sometimes we generate an action with executable false because the execution is blocked by
// the related action. For example, some non-executable container resizing up actions are
// blocked by namespace resizing actions.
// Note this is symmetric to the BlockingRelation.
message BlockedByRelation {
    oneof blocked_by_relation_type {
        BlockedByResize resize = 1;
    }

    // An action execution is blocked by the related resize action.
    message BlockedByResize {
        optional topology.CommodityType commodity_type = 1;
    }
}

// A blocking related signifies that an action blocks the related action execution.
// Sometimes we generate an action to unblock the execution of the related action. For example,
// namespace resizing actions are blocking some non-executable container resizing up.
// Note this is symmetric to the BlockingRelation.
message BlockingRelation {
    oneof blocking_relation_type {
        BlockingResize resize = 1;
    }

    // An action blocks the related resize action execution.
    message BlockingResize {
        optional topology.CommodityType commodity_type = 1;
    }
}

// ActionMode must be nested in a message type because the DISABLED variant otherwise clashes
// with the DISABLED variant in ActionState
// The ActionMode determines the automation status of a class of actions.
enum ActionMode {
    // The recommendation and execution of this action is disabled. The user
    // credited with disabling a disabled action is the user that created the policy
    // that assigned this mode to the action.
    DISABLED = 0;

    // The recommendation will be shown to the user in the UI but cannot be executed
    // by the system.
    RECOMMEND = 1;

    // Indicates that the actions that have this mode must be approved in an external system before
    // we will execute it (in addition to an execution windows required).
    // EXTERNAL_APPROVAL is more conservative than MANUAL, as a result, this enum value must come
    // before MANUAL so that the default enum comparison considers EXTERNAL_APPROVAL to be smaller.
    // The number 4 is because protobuf requires a new integer for new enum values.
    EXTERNAL_APPROVAL = 4;

    // The recommendation will be shown to the user in the UI and can be optionally
    // executed or dismissed. The user credited with accepting or rejecting the action
    // is the user that made the decision, not the user that set the policy.
    MANUAL = 2;

    // The recommendation will be automatically executed by the system. The user credited
    // with executing an automated action is the user that created the policy that
    // assigned this mode to the action.
    AUTOMATIC = 3;
}

// The ActionType describes what type of action should be performed.
enum ActionType {
    // An unknown action type
    NONE = 0;

    // Start a service entity. May be recommended by the market as a move from nothing to something.
    START = 1;

    // Move a service entity from one provider to another.
    MOVE = 2;

    // Suspend a service entity. Suspended service entities may be subsequently restarted via a START command.
    SUSPEND = 3;

    // Provision a new service entity.
    PROVISION = 4;

    // Supply a service entity with a new configuration.
    RECONFIGURE = 5;

    // Resize (either up or down) a service entity.
    RESIZE = 6;

    // Activate a non-active service entity.
    ACTIVATE = 7;

    // Deactivate an active service entity.
    DEACTIVATE = 8;

    // Delete a wasted file associated with a Storage or StorageTier
    DELETE = 9;

    // Buy a reserved instance of the specification.
    BUY_RI = 10;

    // Scale a service entity. Currently this action type is used to represent Cloud Move actions
    // for workloads when they are moved from one template to another. Market doesn't generate
    // Scale actions but Action Orchestrator translates Cloud Moves to Scale actions.
    SCALE = 11;

    // Reserved instance reallocation action (aka Accounting action). These actions are generated
    // for VMs that are moved to reserved instances that became available because some other VMs were
    // moved to different templates.
    ALLOCATE = 12;
}

//           ----------------------------------------------
//           |                                             |
//          READY ----------> CLEARED                      |
//           ^  ^               ^^^                        |
//           |  |               |||                        |
//           |  v               |||                        |
//           |  REJECTED ------- ||                        |
//           v                   ||                        |
//        ACCEPTED---------------||                        |
//           ^                    |                        |
//           |                    |                        |
//           v                    |                        |
//        QUEUED------------------                         |
//           |                                             |
//           v                                             |
//        PRE_IN_PROGRESS--------------------------------- |
//           |                                           | |
//           V                                           | |
//   -----IN_PROGRESS----------------------              | |
//  |  ___/  |                             |             | |
//  | |      v                             v             | |
//  | |   POST_IN_PROGRESS -----         FAILING         | |
//  | |      |                  |           |            | |
//  | |      v                  |           v            | |
//  |  -->SUCCEEDED              -------> FAILED <---------
//  |                                       ^
//  |                                       |
//   ---------------------------------------
enum ActionState {
    // An action that is READY is one that has not yet been decided by the system.
    // Changes in policy or capability that affect actions in the READY state will be applied to
    // those actions and potentially cause them to be decided at that point.
    READY = 0;

    // An action that has been CLEARED is one that was at one time recommended by the market but
    // is now no longer. Actions in DISABLED mode are not immediately CLEARED. Instead, they
    // stay in the READY state but are not shown in the UI or executed.
    CLEARED = 1;

    // An action that has been rejected.
    REJECTED = 8;

    // An action that has been accepted. An action can be accepted by turbo (manually by user or
    // policy - AUTOMATIC mode) or by third-party orchestrator platform.
    ACCEPTED = 9;

    // An accepted action that waits start of executing. Action can stays in queue because of,
    // for example, the target associated with the action is busy processing
    // many other actions and would be overwhelmed by sending additional requests.
    // Action with execution window can be rolled back from QUEUED state if it wasn't executed during
    // active period of execution window.
    QUEUED = 2;

    // An action that is currently being executed.
    IN_PROGRESS = 3;

    // A completed action that has completed successfully.
    SUCCEEDED = 4;

    // A completed action that has completed but had errors.
    FAILED = 5;

    // Actions in the PREP state are preparing to run. Depending on automation policies, this
    // may involve invoking a workflow, or it may do nothing.
    PRE_IN_PROGRESS = 6;

    // Actions in the POST state are cleaning up after execution. Depending on automation policies,
    // this may involve invoking a workflow, or it may do nothing.
    // Note: The POST state is entered regardless of whether the action succeeded or failed
    POST_IN_PROGRESS = 7;

    // An execution step failed. We are running the configured execution steps to clean up the action.
    // For instance, a native for REPLACE action failing still needs to run the POST stage.
    FAILING = 10;
}

enum ActionPhase {
    // Actions may have Action Scripts that are attached through policy. These scripts execute in
    // phases relative to the primary action itself.

    // Action has been generated by market, and action orchestration decided it does not need to
    // be filtered.
    ON_GENERATION = 3;

    // How an action should be approved.
    APPROVAL = 4;

    // A PRE phase script executes before primary action execution
    PRE = 0;

    // A REPLACE phase script executes in place of the normal primary action implementation
    REPLACE = 1;

    // A POST phase script executes after the primary action execution
    POST = 2;

    // When an action reaches SUCCEEDED or FAILED. For instance, auditing failed and succeeded
    // action in an external system. This is separate from POST because POST only deals with the
    // transition from a succeeded action.
    AFTER_EXECUTION = 5;

}

enum ActionCostType {
    // Actions will have a cost type based on whether they provide savings or if they require
    // an investment.

    // A cost type whose savings and investments are both 0
    // 'NONE' must have a prefix as there is a sibling enum with 'NONE' already defined
    ACTION_COST_TYPE_NONE = 0;

    // A cost type where the action provides savings.
    SAVINGS = 1;

    // A cost type where the action requires investment.
    INVESTMENT = 2;
}

enum ActionDisruptiveness {
    // Actions can be either disruptive or non-disruptive.

    // Disruptive actions are those that would cause disruption.
    // Action is disruptive, eg: Azure volume scale actions require VM deallocation as prerequisite
    DISRUPTIVE = 0;

    // Non disruptive actions are those that would not cause disruption.
    NON_DISRUPTIVE = 1;
}

enum ActionReversibility {
    // Actions can be either reversible or irreversible.

    // Reversible actions are those that would can be reversed.
    // Action is reversible, eg: cloud volume actions which don't change disk size.
    REVERSIBLE = 0;

    // Irreversible actions are those that cannot be reversed.
    // Action is irreversible, eg: increasing cloud volume size. Cloud volume size can only
    // be increased, and cannot be decreased.
    IRREVERSIBLE = 1;
}

// Enum to represent the values for filtering actions
// based on what type(s) of relationships they have to other actions.
enum ActionRelationType {
    // Action is not related to any other actions
    RELATION_NONE = 0;

    // Action is related to other actions via the BlockedByRelation
    BLOCKED_BY = 1;

    // Action is related to other actions via the BlockingRelation
    BLOCKING = 2;

    // Action is related to other actions via the CausedByRelation
    CAUSED_BY = 3;

    // Action is related to other actions via the CausingRelation
    CAUSING = 4;
}

// The ActionDecision provides information about why OperationsManager
// decided to execute or not to execute a particular action.
message ActionDecision {

    // The time at which the decision was made. Milliseconds since the unix epoch.
    optional int64 decisionTime = 1;

    // An action may be undecided, executed, or cleared.
    oneof decision {
        ExecutionDecision execution_decision = 2;
        ClearingDecision clearing_decision = 3;
    }

    // Explains why an action was executed and who accepted the action to execute it.
    message ExecutionDecision {
        enum Reason {
            MANUALLY_ACCEPTED = 1;
            AUTOMATICALLY_ACCEPTED = 2;
        }

        // The reason why the action was decided to be executed.
        required Reason reason = 1;

        // Executed actions may only be attributed to users.
        // When manually accepted, this will be the UUID of the user who manually accepted it.
        // When automatically accepted, this will be the UUID of the user who configured the
        // setting to automatically accept it.
        required string userUuid = 2;
    }

    // Explains why an action was not executed and what in the system caused it
    // to not be executed.
    message ClearingDecision {
        enum Reason {
            NO_LONGER_RECOMMENDED = 1;
            PROBE_UNABLE_TO_EXECUTE = 2;
        }

        // The reason why the action was decided NOT to be executed.
        required Reason reason = 1;

        // Describes what in the system in the system caused the action not to be executed.
        oneof attributionId {
            // When NO_LONGER_RECOMMENDED, this will be the ID of the first action plan
            // after the initial recommendation that did not recommend the action anymore.
            int64 actionPlanId = 2;

            // When PROBE_UNABLE_TO_EXECUTE, this will be the ID of that probe.
            int64 probeId = 3;
        }
    }
}

// Severity categories express the urgency a user should apply in addressing a particular
// action recommendation. In the context of an entity, severity is calculated as the most severe
// action for all actions that apply to a particular service entity.
enum Severity {
    NORMAL = 1;     // Indicates a normal state. An entity in a normal state is considered healthy.
    MINOR = 2;      // The action will improve the situation in the user's environment,
    // but if not addressed, unlikely to have serious consequences.
    MAJOR = 3;      // The action has some urgency.
    CRITICAL = 4;   // The most critical category, these actions should be addressed immediately.
}

// The state of an action step.
// Composite or multi-step actions may have multiple execution steps.
message ExecutionStep {
    enum Status {
        // Indicates the operation is waiting for earlier steps to complete before
        // it can be executed.
        QUEUED = 1;

        // Indicates the operation is in progress.
        IN_PROGRESS = 2;

        // Indicates the operation has completed and succeeded.
        SUCCESS = 3;

        // Indicates the operation has completed and failed.
        FAILED = 4;
    }

    // The time at which this step of the action was queued to be executed.
    // If an action is ready to execute as soon as it is queued, the transition will be immediate.
    // Milliseconds since the unix epoch.
    optional int64 enqueueTime = 1;

    // The time at which this step of the action started execution.
    // Milliseconds since the unix epoch.
    optional int64 startTime = 2;

    // The time at which this step of the action completed.
    // Initialized to null, and set to the current time when the action completes.
    optional int64 completionTime = 3;

    // The status of this step in the action's execution.
    optional Status status = 4;

    // Any errors that occurred with the action step. The list will be empty if there have been no errors.
    repeated string errors = 5;

    // The ID of the target assigned to execute the action.
    optional int64 targetId = 6;

    // The progress of the execution step. A percentage (0-100). Only meaningful for steps that are IN_PROGRESS.
    optional int32 progressPercentage = 7;

    // A description of what the probe is currently executing as part of this step (ie "Moving VM...").
    // Only meaningful on actiosn that are IN_PROGRESS.
    optional string progressDescription = 8;
}

// The category of the action is a short-form explanation of the reason for the action.
// It's derived from the full explanation.
enum ActionCategory {
    // Unknown - kept at the lowest index so that any categories a service
    // doesn't know about (e.g. due to a different version of the enum) take on
    // this value.
    UNKNOWN = 0;

    // The action is required to ensure an entity has the resources it needs for optimal performance
    // (e.g. sizing up in order to address overutilization).
    PERFORMANCE_ASSURANCE = 1;

    // The action is required in order to improve the efficiency of the system - i.e. how well
    // it utilizes resources (e.g. moving a VM to a less-utilized provider, or shutting down
    // a PM if it's VMs can be moved to other hosts without sacrificing performance)
    EFFICIENCY_IMPROVEMENT = 2;

    // This action is required to prevent future risks.
    PREVENTION = 3;

    // This action is required in order to comply with a placement policy (e.g. a VM needs
    // to be in a certain cluster).
    COMPLIANCE = 4;

    // This is for the Deactivate Actions triggered by PMC.
    SAVING = 5;
}

// An ActionSpec maintains the state of an action in the system.
// It contains information necessary to execute the action as well as the
// execution state of the action.
message ActionSpec {
    // The recommended steps to take in the environment.
    optional Action recommendation = 1;

    // ID of the recommendation. This is the "stable" id shared by all action instances that
    // represent the same logical action. For example, all moves of VM 1 from Host 2 to Host 3 will
    // have the same recommendation ID.
    optional int64 recommendation_id = 15;

    // The execution step associated with an action that is being executed.
    // If the action has not begun to be executed, will be empty.
    //
    // TODO: composite or multi-step actions may require more than one step to complete execution.
    // TODO: (per Roman) Perhaps this can be an "optional ActionExecutionSpec" then, where the
    // TODO: ActionExecutionSpec will currently just have an optional ExecutionStep for the current execution step?
    optional ExecutionStep executionStep = 2;

    // The time at which this action was recommended.
    // Milliseconds since the unix epoch.
    optional int64 recommendationTime = 3;

    // The explanation of the action to be displayed to the user.
    // An explanation describes the purpose of the action and how it will improve the user's
    // environment in understandable terms.
    optional string explanation = 4;

    // The ActionDecision provides information about why OperationsManager
    // decided to execute or not to execute a particular action.
    // Not provided if no decision has been made.
    optional ActionDecision decision = 5;

    // The mode of the action. The action mode is established by checking the policy and capability
    // for the action when it is received by the action orchestrator.
    optional ActionMode actionMode = 6;

    // The state of the action. The state of an action may change due to certain user actions or system events.
    // The initial state is determined by the action mode.
    optional ActionState actionState = 7;

    // The ID of the action plan to which this action's recommendation belongs.
    optional int64 actionPlanId = 8;

    // Whether the action is ready to be executed. Actions that require other actions to successfully execute
    // before they can be executed are not considered executable. Actions that are already being executed
    // or have been executed are not considered executable.
    optional bool isExecutable = 9;

    // The category of the action. It is consumed by UI to indicate if the effect of the action is
    // assure performance, improve efficiency, prevention or compliance.
    optional ActionCategory category = 10 [default = UNKNOWN];

    // The action description that will be set by AO and returned to the API.
    optional string description = 11;

    // A list of prerequisite descriptions.
    repeated string prerequisite_description = 12;

    // The severity of the action
    optional Severity severity = 13 [default = NORMAL];

    optional ActionSchedule actionSchedule = 14;

    // The message which keeps information for the execution window
    message ActionSchedule {
        // The start timestamp for the next occurrence of schedule
        optional int64 start_timestamp = 1;

        // The end timestamp of current if the schedule is active or next occurrence if the
        // schedule is not active
        optional int64 end_timestamp = 2;

        // The timezone for the associated schedule
        optional string schedule_timezone_id = 3;

        // The id for the schedule associated to the action
        optional int64 schedule_id = 4;

        // The display name for the schedule associated to the action
        optional string schedule_display_name = 5;

        // Action mode in execution window
        optional ActionMode execution_window_action_mode = 6;

        // The user that has accepted the action for execution window.
        optional string accepting_user = 7;
    }

    // The name under which this action appears in third-party software or external approval backend.
    optional string external_action_name = 16;

    // URL to third-party software showing this action. Suitable for external action approval.
    optional string external_action_url = 17;

    // List of related actions of the action.
    repeated RelatedAction related_actions = 18;
}

// A filter to be supplied with action queries.
// The conditions in the query filter will be AND-ed together, so only actions
// that match all of them will be returned.  This includes one more more scope filters,
// if they were to be set at the same time.
message ActionQueryFilter {
    // If true, include only externally visible actions in the response.
    // If false, include only non-externally visible actions.
    // If not present, the field is not used to filter.
    optional bool visible = 1;

    // Include only actions in the given states.
    repeated ActionState states = 2;

    // Include only actions that involve any of these entities.
    //
    // Involved entities are any entities the action affects, and not just the primary entity.
    // For example, the involved entities in a VM move are the VM, and the hosts.
    //
    // If not set, include any actions.
    // See impact of setting scope filters (Account, ResourceGroups, ..) below.
    optional InvolvedEntities involved_entities = 3;

    // Include only actions that involve entities of the specific type.
    repeated int32 entity_type = 12;

    message InvolvedEntities {
        // The oids of the involved entities.
        // If empty, will return no actions.
        repeated int64 oids = 11;
    }

    // date range for the request; dates are epoch longs, e.g. Unix TimestampLiveAction
    // We currently require both start_date and end_date to be not null.
    // Todo: will work on provide default values.
    optional int64 start_date = 4;

    optional int64 end_date = 5;

    // Include only actions in the given modes.
    repeated ActionMode modes = 6;

    // Include only actions of the given types.
    repeated ActionType types = 7;

    // Include only actions of the given categories.
    repeated ActionCategory categories = 8;

    // Include only actions in a particular environment.
    optional .common.EnvironmentType environment_type = 9;

    // If non-empty, include only actions of the given severities
    repeated Severity severities = 13;

    // If non-empty, include only actions of given cost type
    optional ActionCostType cost_type = 14;

    // If present, include actions which have associated schedule with this id.
    // If not present, the field is not used to filter.
    optional int64 associatedScheduleId = 15;

    // If non-empty, include all actions else match action description to query
    optional string description_query = 16;

    // If non-empty, include all actions else match action risk to query
    optional string risk_query = 17;

    // If non-empty, include all disruptive or non-disruptive actions.
    optional ActionDisruptiveness disruptiveness = 18;

    // If non-empty, include all reversible or irreversible actions.
    optional ActionReversibility reversibility = 19;

    // If true, include only actions with associated with schedule in the response.
    // If false, include only actions without associated with schedule in the response.
    // If not present, the field is not used to filter.
    optional bool has_schedule = 20;

    // If true, include only actions with prerequisites in the response.
    // If false, include only actions without prerequisites in the response.
    // If not present, the field is not used to filter.
    optional bool has_prerequisites = 21;

    // If non-empty, include all actions with savings amount between the min and max range.
    optional ActionSavingsAmountRangeFilter savings_amount_range = 22;

    // Filter to get items from ActionHistory db by Account(s). Ignore InvolvedEntities.
    // Scoped users will have their entities restriction computed independently.
    optional cloud_common.AccountFilter account_filter = 23;

    // Filter to get items from ActionHistory db by ResourceGroup(s). Ignore InvolvedEntities.
    // Scoped users will have their entities restriction computed independently.
    optional ResourceGroupFilter resource_group_filter = 24;

    // If non-empty, include actions that are related to other action via the given relation types.
    // Multiple relationTypes are ORed during filtering, so the action related via any of the
    // given relation types is included.
    // If not present, the field is not used to filter.
    repeated ActionRelationType relationTypes = 25;

    // If non-empty, include actions that are related to the specified cloud service providers.
    repeated int64 related_cloud_service_provider_ids = 26;
}

message ResourceGroupFilter {
    // A list of reource group OIDs
    repeated int64 resource_group_oid = 1;
}

// A filter to be supplied with action query filter.
// The conditions in the query filter will be AND-ed together, so only actions
// that match all of them will be returned.
// This filter will match all actions in a given range.
message ActionSavingsAmountRangeFilter {
    // If provided the action savings amount would be greater than equal to this amount.
    optional double min_value = 1;

    // If provided the action savings amount would be less than equal to this amount.
    optional double max_value = 2;
}

// The number of actions of a specific type that match the criteria in
// the request.
message TypeCount {

    // The type of the action this message pertains to.
    optional ActionType type = 1;

    // The number of actions of the type that match the request criteria.
    optional int64 count = 2;
}

// The number of actions of a specific state and mode that match the criteria in
// the request.
message StateAndModeCount {

    // The type of the action this message pertains to.
    optional ActionState state = 1;

    // The mode of the action this message pertains to.
    optional ActionMode mode = 2;

    // The number of actions of the type that match the request criteria.
    optional int32 count = 3;
}

// A message used to address a single action within a topology context.
message SingleActionRequest {
    // The topology context the action belongs to.
    // There is one real-time topology context, and a context per-plan.
    optional int64 topology_context_id = 1;

    // The ID of the action being addressed.
    optional int64 action_id = 2;
}

// A message used to address multiple actions within a topology context.
message MultiActionRequest {
    // The topology context the actions belongs to.
    // There is one real-time topology context, and a context per-plan.
    optional int64 topology_context_id = 1;

    // The IDs of the actions being addressed.
    repeated int64 action_ids = 2;
}

// A message used to retrieve all actions within a topology context.
message FilteredActionRequest {
    // The topology context for which to retrieve actions.
    // There is one real-time topology context, and a context per-plan.
    optional int64 topology_context_id = 1;

    // The pagination parameters for the request.
    // if enforce_limit in the pagination_params is true (default), it will stream actions in
    // next page in chunks to client, with the first response to be pagination info. (if no fields
    // in pagination_params are set, the service will use the default sort order and limit.)
    // if enforce_limit is set to false, it will stream all actions to client in chunks.
    optional common.PaginationParameters pagination_params = 3;

    // All query filters to be applied to the actions retrieved. Filters are not combined-- each one
    // will be used to retrieve its own independent set of actions. If no query filter is supplied,
    // all actions are returned.
    repeated ActionQuery action_query = 4;

    // Action query containing filter to be applied and metadata for that filter.
    message ActionQuery {
        // To identify this query filter and distinguish its results from those of other filters.
        optional int64 query_id = 1;

        // The filter to be applied.
        optional ActionQueryFilter query_filter = 2;
    }
}

message FilteredActionResponse {
    oneof type {
        // A chunk of actions.
        // The length of this list will not exceed the limit set in the request pagination
        // parameters or the max limit for the service
        // The actions will be ordered according to the order in the request pagination parameters.
        ActionChunk action_chunk = 1;

        // The response message containing pagination-related response parameters.
        // this is only set if pagination_params is set in request
        common.PaginationResponse pagination_response = 2;
    }

    message ActionChunk {
        repeated ActionOrchestratorAction actions = 1;
    }

    // ID to determine which query filter applies to this action response, if any. Should match
    // the query_id of an ActionQuery from the FilteredActionRequest.
    optional int64 query_id = 3;
}

message ActionOrchestratorAction {
    // The ID of the action in the system.
    optional int64 action_id = 1;

    // The description of the action in the system. May not be present
    // if a client requests information about an unknown action id.
    optional ActionSpec action_spec = 2;
}

// Action execution: a set of actions that were accepted for execution in a single request.
message ActionExecution {
    // Unique execution ID: auto-incremented number generated by Action Orchestrator when request
    // is accepted.
    required int64 id = 1;

    // List of action OIDs for execution.
    repeated int64 action_id = 2;

    // List of rejected actions with explanations why they were rejected.
    repeated SkippedAction skipped_action = 3;

    // Time stamp when actions were accepted.
    optional int64 accepted_timestamp = 4;

    // Information about action that was skipped by Action Orchestrator.
    message SkippedAction {
        // Skipped action ID.
        required int64 action_id = 1;

        // Reason why action was skipped by Action Orchestrator.
        optional string reason = 2;
    }
}

// Request to get action execution by its ID.
message ActionExecutionRequest {
    required int64 execution_id = 1;
}

// Request to get all action executions.
message AllActionExecutionsRequest {
}

// Response for all action executions request.
message AllActionExecutionsResponse {
    repeated ActionExecution executions = 1;
}

// A request for information about topology contexts known to the action service.
message TopologyContextInfoRequest {
    // Currently empty.
}

// Information about the actions within a given topology context.
message TopologyContextResponse {
    // The topology context the actions belongs to.
    // There is one real-time topology context, and a context per-plan.
    optional int64 topology_context_id = 1;

    // The number of actions known for this context.
    optional int32 action_count = 2;
}

// The request message to delete all actions associated with a topology context.
message DeleteActionsRequest {
    // The topology context for which to delete actions.
    // This may be the context for a live or plan topology context.
    optional int64 topology_context_id = 1;
}

// The response message to delete all actions associated with a topology context.
// An error may be thrown if the context is not found or the operation fails.
message DeleteActionsResponse {
    // The topology context for which actions were deleted.
    optional int64 topology_context_id = 1;

    // The number of actions deleted.
    optional int32 action_count = 2;
}

// The request message to GetActionCounts.
// Allows the user to specify criteria that will affect the number
// of actions in the response.
message GetActionCountsRequest {
    // The topology context for which to retrieve actions.
    // There is one real-time topology context, and a context per-plan.
    optional int64 topology_context_id = 1;

    // A filter to be applied to the actions retrieved. If no filter is supplied
    // all actions are returned.
    optional ActionQueryFilter filter = 2;
}

// The response message to GetActionCounts.
message GetActionCountsResponse {
    // The total number of actions matching the criteria in the request.
    optional int64 total = 1;

    // The actions in the request organized by type.
    // Each ActionType will appear at most once in this list, so the maximum size of the list
    // is the number of distinct ActionType values.
    // The order of the list (w.r.t. TypeCount.type) is not guaranteed.
    repeated TypeCount counts_by_type = 2;
}

// The response message to GetActionCountsByDate.
message GetActionCountsByDateResponse {

    message ActionCountsByDateEntry {
        // date of the actions recommended
        optional int64 date = 1;

        // The actions in the request organized by state and mode. And they are belong to a date.
        repeated StateAndModeCount counts_by_state_and_mode = 2;
    }
    repeated  ActionCountsByDateEntry action_counts_by_date= 1;
}

// The request message to get actions counts by each entity.
message GetActionCountsByEntityRequest {
    // The topology context for which to retrieve actions.
    optional int64 topology_context_id = 1;

    // A filter to be applied to the actions retrieved. It is required in order to call
    // GetActionCountsByEntity function.
    optional ActionQueryFilter filter = 2;
}

// The response message to GetActionCountsByEntity.
message GetActionCountsByEntityResponse {
    // Contains relationship from a entity to related list of action TypeCount. One entity could
    // multiple action type and each action type could have multiple actions.
    message ActionCountsByEntity {
        // Id of entity
        optional int64 entity_id = 1;

        // The actions in the request organized by type. And they are belong to a entity.
        // Each ActionType will appear at most once in this list. so the maximum size of the list
        // is the number of distinct ActionType values. And the sum of the list action counts will
        // be the total action counts of this entity.
        repeated TypeCount counts_by_type = 2;
    }

    // List of ActionCountsByEntity, it contains all requested entities.
    repeated ActionCountsByEntity action_counts_by_entity = 1;
}

message CancelQueuedActionsRequest {
}

message CancelQueuedActionsResponse {
    // Number of actions that were cancelled from execution.
    optional int32 cancelled_count = 1;
}

message GetActionCategoryStatsRequest{
    // The topology context for which to retrieve the actions category stats.
    optional int64 topology_context_id = 1;

    // Type of entities to include in the stats
    repeated int32 entity_type = 2;
}

message GetActionCategoryStatsResponse {

    repeated ActionCategoryStats action_stats_by_category = 1;
}

// Stats for actions based on ActionCategory type.
message ActionCategoryStats {

    optional ActionCategory action_category = 1;

    // Number of actions of 'action_category' type.
    optional int32 actions_count = 2;

    // Number of target entities which are affected by the the actions
    // of 'action_category' type.
    optional int32 entities_count = 3;

    optional double savings = 4;

    optional double investment = 5;
}

// A query for current actions (i.e. the most recent actions)
message CurrentActionStatsQuery {

    // Filter for the kinds of actions to return stats for.
    // If not present, results for all action kinds will be returned.
    optional ActionGroupFilter action_group_filter = 1;

    // Filter for the scope to return stats for. If set, will only retrieve actions affecting
    // entities in the scope. If not set, will retrieve actions affecting any entities in
    // the realtime topology.
    optional ScopeFilter scope_filter = 2;

    // Grouping criteria for the action stats.
    // If not set, action stats for each found time will be combined into a single value.
    repeated GroupBy group_by = 10;

    // The filter to apply to the actions considered for the counts.
    //
    // This is pretty much the same as the one in HistoricalActionCountsQuery, but it's kept
    // separate for future-proofing. The live version is much more flexible because we're dealing
    // with in-memory objects. Given the breadth of the API it's very possible that we will need
    // to add other properties here. However, adding a property here shouldn't confuse users of
    // the historical interface.
    message ActionGroupFilter {
        // Match action groups with any of these action types.
        // An empty list means match all action types.
        repeated ActionType action_type = 1;

        // Match action groups with any of these action modes.
        // An empty list means match all action modes.
        repeated ActionMode action_mode = 2;

        // Match action groups with any of these action categories.
        // An empty list means match all action categories.
        repeated ActionCategory action_category = 3;

        // Match action groups with any of these action states.
        // An empty list means match all action states.
        repeated ActionState action_state = 4;

        // If true, include only externally visible actions in the response.
        // If false, include only non-externally visible actions.
        // If not present, the field is not used to filter.
        optional bool visible = 5;

        // If non-empty, include only actions of given cost type
        optional ActionCostType cost_type = 6;

        // If non-empty, include all actions else match action description to query
        optional string description_query = 7;

        // If non-empty, include all actions else match action risk to query
        optional string risk_query = 8;

        // If non-empty, include all disruptive or non-disruptive actions.
        optional ActionDisruptiveness disruptiveness = 9;

        // If non-empty, include all reversible or irreversible actions.
        optional ActionReversibility reversibility = 10;

        // If true, include only actions with associated with schedule in the response.
        // If false, include only actions without associated with schedule in the response.
        // If not present, the field is not used to filter.
        optional bool has_schedule = 11;

        // If true, include only actions with prerequisites in the response.
        // If false, include only actions without prerequisites in the response.
        // If not present, the field is not used to filter.
        optional bool has_prerequisites = 12;

        // If non-empty, include all actions with savings amount between the min and max range.
        optional ActionSavingsAmountRangeFilter savings_amount_range = 13;

        // If empty or HYBRID, include all actions
        // If CLOUD, include all cloud actions
        // If ONPREM, include all on-prem actions
        optional .common.EnvironmentType environment_type = 14;
    }

    // The entities involved in an action must match this filter in order for the action to be
    // considered for the counts.
    //
    // If any entity involved in an action matches this filter, the action will be counted.
    // However, only the matching entity will be counted towards the "numEntities" in the returned
    // stats. For example, suppose there is a move of VM 1 from Host 1 to Host 2. If the scope
    // filter targets VM 1, the returned stats will be:
    //    numActions: 1
    //    numEntities: 1 (the VM)
    // On the other hand, if the scope filter targets all three entities the returned stats will be:
    //    numActions: 1
    //    numEntities: 3
    message ScopeFilter {
        // The topology context for the scope.
        // If unset, use the default realtime context - i.e. get the live actions.
        optional int64 topology_context_id = 1;

        oneof scope {
            // A subset of entities in the most recent topology for the context.
            GlobalScope global = 2;

            // A list of entity IDs.
            EntityScope entity_list = 3;
        }

        // The scope is all entities in the specific topology context,
        // with some optional high-level filters to allow targeting a subset of the entities.
        message GlobalScope {
            // Restrict to a particular environment type.
            // If not set, include entities of all environment types.
            optional .common.EnvironmentType environment_type = 1;

            // Restrict to a particular list of entity types.
            // If empty, get the value across all entity types.
            repeated int32 entity_type = 2;
        }

        // The scope is a specific list of entity IDs.
        message EntityScope {
            repeated int64 oids = 1;
        }

    }

    // Group and aggregate/combine action stats according to this property.
    // This is similar to the SQL "GROUP BY" statement.
    enum GroupBy {
        // No grouping - aggregate all matching action stats into a single set of values.
        NONE = 0;

        // Group by action state - action stats will be grouped by the action state. For example,
        // if we have 1 READY "MOVE" action, 1 READY "RESIZE" action, and 1 QUEUED "MOVE" action,
        // the returned action count will be 2 for the "READY" state and 1 for the "QUEUED" state.
        ACTION_STATE = 1;

        // Group by action state - action stats will be grouped by the action state. For example,
        // if we have 1 "MOVE" action and 1 "RESIZE action for performance, and 1 "MOVE" action for
        // compliance, the returned action count will be 2 for the "performance" category and
        // 1 for the "compliance" category.
        ACTION_CATEGORY = 2;

        // Group by action type.
        ACTION_TYPE = 3;

        // Group by the reason commodity (e.g. VMem, CPU, etc)
        REASON_COMMODITY = 4;

        // Entity type of the primary entity for the action.
        TARGET_ENTITY_TYPE = 5;

        // Explanation of the risk that led to the recommendation of the action (e.g. "CPU
        // congestion", "Mem Provisioned congestion", etc.)
        ACTION_RELATED_RISK = 6;

        // Id of the target entity for the action.
        TARGET_ENTITY_ID = 7;

        // The ID of the business account associated with the action.
        // All actions with no associated business account will go into a single group with
        // an explicitly set "0" value for the business account ID.
        BUSINESS_ACCOUNT_ID = 9;

        // The ID of the resource group associated with the action.
        // All actions with no associated resource group will go into a single group with
        // an explicitly set "0" value for the resource group ID.
        RESOURCE_GROUP_ID = 10;

        // Group by the cost type of the action to bucket SAVINGS/INVESTMENT actions.
        COST_TYPE = 11;

        // Group by the risk severity of actions.
        SEVERITY = 12;

        // Group by the CSP
        CSP = 13;

        // The ID of the node pool associated with the action.
        // All actions with no associated resource group will go into a single group with
        // an explicitly set "0" value for the node pool ID.
        NODE_POOL_ID = 14;

        // Group by the environment type
        ENVIRONMENT_TYPE = 15;
    }
}

// A query for historical action stats.
//
// In the historical stat case we support a subset of the criteria we have in "realtime".
// Also, the target of the query is constrained - we only keep action stats for certain
// "management units" (e.g. global market, cluster).
message HistoricalActionStatsQuery {

    message ActionGroupFilter {
        // Match action groups with any of these action types.
        // An empty list means match all action types.
        repeated ActionType action_type = 1;

        // Match action groups with any of these action modes.
        // An empty list means match all action modes.
        repeated ActionMode action_mode = 2;

        // Match action groups with any of these action categories.
        // An empty list means match all action categories.
        repeated ActionCategory action_category = 3;

        // Match action groups with any of these action states.
        // An empty list means match all action states.
        repeated ActionState action_state = 4;

        // Match action groups with any of these action related risks.
        // An empty list means match all action risks.
        repeated string action_related_risk = 5;
    }

    // A "management unit" is an object in the system that is often interacted with by the user.
    // It's a higher level than a single entity. For example, a "cluster" is a typical management
    // unit.
    //
    // A "management unit subgroup" is a subset of the entities within the scope of the management
    // unit - for example "Virtual Machines on hosts in the cluster X", or "CLOUD VMs in the
    // global environment".
    //
    // Stats are only available for certain management unit subgroups.
    message MgmtUnitSubgroupFilter {
        // The scope.
        oneof scope {
            // The entire market.
            bool market = 1;

            // A specific "management unit". Note that only certain management units have
            // historical action stats tracked.
            int64 mgmt_unit_id = 2;

            // A set of management units
            ManagementUnits mgmt_units = 3;
        }

        // Restrict to a particular environment type.
        optional .common.EnvironmentType environment_type = 10;

        // Restrict to a particular list of entity types.
        // If empty, get the value across all entity types.
        //
        // IMPORTANT - if you care about "action count", "investment", or "savings" you should not
        // query for multiple "entity_type"s (the empty list is an exception). Certain actions -
        // "MOVE"s in particular - affect multiple
        // entities at the same time, so there will be double-counting of actions if stats for
        // multiple entity types is combined. For example, a single PM "MOVE" involves a VM and
        // PMs. If you query for "all entity types", the returned action count will be 2!
        //
        // (roman, Jan 16 2019): It's not clear if it's an important use case to support arbitrary
        // groupings of entity types. For now we typically see exactly one entity type.
        repeated int32 entity_type = 11;

        message ManagementUnits {
            // The list of management units
            repeated int64 mgmt_unit_ids = 1;
        }
    }

    message TimeRange {
        // The start time, in epoch millis.
        optional int64 start_time = 1;

        // The end time, in epoch millis.
        optional int64 end_time = 2;
    }

    // Group and aggregate/combine action stats according to this property.
    // This is similar to the SQL "GROUP BY" statement.
    enum GroupBy {
        // No grouping - aggregate all matching action stats into a single set of values.
        NONE = 0;

        // Group by action state - action stats will be grouped by the action state. For example,
        // if we have 1 READY "MOVE" action, 1 READY "RESIZE" action, and 1 QUEUED "MOVE" action,
        // the returned action count will be 2 for the "READY" state and 1 for the "QUEUED" state.
        ACTION_STATE = 1;

        // Group by action state - action stats will be grouped by the action state. For example,
        // if we have 1 "MOVE" action and 1 "RESIZE action for performance, and 1 "MOVE" action for
        // compliance, the returned action count will be 2 for the "performance" category and
        // 1 for the "compliance" category.
        ACTION_CATEGORY = 2;

        // The risk that led to the recommendation of the action (e.g. "CPU congestion",
        // "Underutilized VMem", etc.)
        ACTION_RELATED_RISK = 3;

        // The ID of the business account associated with the action.
        // Only actions that have associated business accounts will be returned. Unlike the
        // "live" action stats query, we will NOT return a "0"-valued business account group for
        // actions without a business account.
        BUSINESS_ACCOUNT_ID = 9;

        // The ID of the resource group associated with action. Only actions that have associated
        // resource group will be returned.
        RESOURCE_GROUP_ID = 10;

        // The ID of the node pool associated with action. Only actions that have associated
       // node pool will be returned.
        NODE_POOL_ID = 11;
    }

    // The time range for the query.
    // Must be present (or else no results will be returned).
    optional TimeRange time_range = 1;

    // Filter for the kinds of actions to return stats for.
    // If not present, results for all action kinds will be returned.
    optional ActionGroupFilter action_group_filter = 2;

    // Filter for the scope to return stats for.
    // Must be present (or else no results will be returned).
    optional MgmtUnitSubgroupFilter mgmt_unit_subgroup_filter = 3;

    // Grouping criteria for the action stats.
    // If not set, action stats for each found time will be combined into a single value.
    optional GroupBy group_by = 10;
}

// The collection of action stats that match a query.
message ActionStats {
    // The ID of the mgmt unit the stats are for (e.g. a cluster, a business account, etc.)
    // Not set if describing the whole market.
    repeated int64 mgmt_unit_ids = 1;

    // One snapshot for every distinct time that has stats in the time range specified by the
    // query. Note that even if there are no stats matching the query in the snapshot, there
    // will still be a snapshot returned with the time set.
    repeated ActionStatSnapshot stat_snapshots = 10;

    message ActionStatSnapshot {
        // The time the stats were collected.
        optional int64 time = 1;

        // A list of aggregated stats.
        // The size of the list is determined as follows:
        //   - If no stats matched the query in the set of stats collected at the time - 0.
        //   - If there were stats:
        //        - If "group by" is "NONE", there will just be 1 stat.
        //        - If "group by" is another field, there will be 1 stat for each distinct value
        //          of the field that has stats. For example, if "group by" is ActionState, there
        //          will be one record for each state present in the stats that matched the query.
        repeated ActionStat stats = 10;
    }
}

// The action resource impact for the given action type.
// For example: VMem or VCPU impact from a Resize Virtual Machine action
message ActionResourceImpact {
    // The target entity type for which resource impact is computed.
    required int32 target_entity_type = 1;

    // The action type for which resource impact is computed.
    required ActionType action_type = 2;

    // The base type of the commodity that is "most responsible" for the action.
    required int32 reason_commodity_base_type = 3;

    // The impact amount of the commodity that is "most responsible" for the action.
    required double amount = 4;
}

// Action stats for the most recent set of actions the action orchestrator knows about.
message CurrentActionStat {

    // If the "group_by" in the query was non-empty, this message contains the values of the
    // grouping criteria that a particular "CurrentActionStat" aggregated across.
    // For example, if the "group_by" was "ACTION_STATE" and "ACTION_TYPE" and there were four
    // matching actions:
    //     - An IN-PROGRESS move action for performance
    //     - An IN-PROGRESS move action for compliance
    //     - A READY move action
    //     - A READY resize action
    //
    // There would be three returned "CurrentActionStat" messages:
    //     - One with StatGroup : { action_state : "IN_PROGRESS", action_type : "MOVE" }
    //           and action_count : 2
    //     - One with StatGroup : { action_state : "READY", action_type : "MOVE" }
    //           and action_count : 1
    //     - One with StatGroup : { action_state : "READY", action_type : "RESIZE" }
    //           and action_count : 1
    message StatGroup {
        // The state for this action stat, only present if the "group_by" in the query contained
        // "ACTION_STATE."
        optional ActionState action_state = 1;

        // The category for this action stat, only present if the "group_by" in the query contained
        // "ACTION_CATEGORY."
        optional ActionCategory action_category = 2;

        // The type for this action stat, only present if the "group_by" in the query contained
        // "ACTION_TYPE."
        optional ActionType action_type = 3;

        // The target entity type, only present if the "group_by" in the query contained
        // "TARGET_ENTITY_TYPE".
        optional int32 target_entity_type = 4;

        // The base type of the commodity that is "most responsible" for the action. Only present if
        // the "group_by" in the query contained "REASON_COMMODITY".
        optional int32 reason_commodity_base_type = 5;

        // Explanation of the risk that led to the recommendation of the action (e.g. "CPU
        // congestion", "Mem congestion", etc.)
        optional string action_related_risk = 6;

        // Id of the target entity for the action. Only present if the "group_by" in the query
        // contained "TARGET_ENTITY_ID".
        optional int64 target_entity_id = 7;

        // ID of the business account associated with the action. Only present if the "group_by" in
        // the query contained "BUSINESS_ACCOUNT_ID".
        // May be explicitly set to "0" for a stat group representing actions that are not
        // associated with any business accounts.
        optional int64 business_account_id = 8;

        // ID of the resource group associated with the action. Only present if the "group_by" in
        // the query contained "RESOURCE_GROUP_ID".
        // May be explicitly set to "0" for a stat group representing actions that are not
        // associated with any resource groups.
        optional int64 resource_group_id = 9;

        // Cost Type of the action, only present if the "group_by" in the query contains
        // "COST_TYPE".
        optional ActionCostType cost_type = 10;

        // Assigned Severity level of the Action used for the "group_by" "severity" query
        optional Severity severity = 11;

        // Cloud service provider of the Action target entity used for the "group_by" "csp" query
        optional string csp = 12;

        // ID of the node pool associated with the action. Only present if the "group_by" in
        // the query contained "NODE_POOL_ID".
        // May be explicitly set to "0" for a stat group representing actions that are not
        // associated with any node pools.
        optional int64 node_pool_id = 13;

        // Environment type of the Action target entity used for the "group_by" "environmentType" query
        optional .common.EnvironmentType environment_type = 14;
    }

    // The stat group this action stat is in.
    // See the "StatGroup" documentation.
    optional StatGroup stat_group = 1;

    // The number of actions affecting the mgmt unit subgroups that matched the query.
    optional int32 action_count = 20;

    // The number of affected entities in the mgmt unit subgroups that matched the query.
    optional int32 entity_count = 21;

    // The amount saved by actions in the mgmt unit subgroups that matched the query.
    optional double savings = 25;

    // The amount of investment required for actions in the mgmt unit subgroups that matched
    // the query.
    // Note - We keep investments separate from savings so that we can see both separately.
    optional double investments = 26;

    // The action resource impact.
    repeated ActionResourceImpact action_resource_impacts = 27;
}

// An action stat for a particular management unit at a particular time.
message ActionStat {
    message Value {
        optional double min = 1;
        optional double max = 2;
        optional double avg = 3;
        optional double total = 4;
    }

    // If the "group_by" in the query was non-empty, this message contains the values of the
    // grouping criteria that a particular "ActionStat" aggregated across.
    message StatGroup {
        // The state for this action stat, only present if the "group_by" in the query was
        // "ACTION_STATE."
        optional ActionState action_state = 1;

        // The category for this action stat, only present if the "group_by" in the query was
        // "ACTION_CATEGORY."
        optional ActionCategory action_category = 2;

        // The business account for this action stat. Only present if the "group_by" in the query was
        // "BUSINESS_ACCOUNT_ID".
        optional int64 business_account_id = 3;

        // The risk for this action stat, only present if the "group_by" in the query is
        // "ACTION_RELATED_RISK". This is similar to the action explanation, but without entity
        // details, and more general
        optional string action_related_risk = 4;

        // The resource group for this action stat. Only present if the "group_by" in the query was
        // "RESOURCE_GROUP_ID".
        optional int64 resource_group_id = 5;

        // The node pool for this action stat. Only present if the "group_by" in the query was
        // "NODE_POOL_ID".
        optional int64 node_pool_id = 6;
    }

    // The stat group for this particular stat. Only set if the group_by in the request was
    // set to something other than NONE.
    optional StatGroup stat_group = 1;

    // The number of actions affecting the mgmt unit subgroups that matched the query.
    optional Value action_count = 20;

    // The number of affected entities in the mgmt unit subgroups that matched the query.
    optional Value entity_count = 21;

    // The amount saved by actions in the mgmt unit subgroups that matched the query.
    optional Value savings = 25;

    // The amount of investment required for actions in the mgmt unit subgroups that matched
    // the query.
    // Note - We keep investments separate from savings so that we can see both separately.
    optional Value investments = 26;
}

// The window of time the change of an executed action is in effect.
message ExecutedActionsChangeWindow {
    // Action ID
    required int64 action_oid = 1;

    // Entity OID
    required int64 entity_oid = 2;

    // Information and state of an action
    optional ActionSpec action_spec = 3;

    // The time the action starts to have an impact on the entity
    optional int64 start_time = 4;

    // The time when the change window ends
    optional int64 end_time = 5;

    // State of the action change, tells whether it is live or not.
    optional LivenessState liveness_state = 6;

    // Action change state enum options.
    enum LivenessState {
        // Just executed, but we haven't detected yet, not live yet, start time is null.
        NEW = 1;

        // We detected change as a result of just executed action, start time is set.
        LIVE = 2;

        // Action ended, with older action now superseded with a newer action.
        SUPERSEDED = 3;

        // Action ended with a revert.
        REVERTED = 4;

        // Action ended with an external modification. User outside of Turbo scaled the VM to
        // another tier that we didn't recommend. E.g we scaled from tier A -> tier B, but
        // customer instead scaled to maybe another tier C instead.
        EXTERNAL_MODIFICATION = 5;

        // Action ended after we detected that entity has been removed.
        DELETED = 6;
    }
}

// The sequence of actions executed on an entity
message ActionChain {
    // Entity OID
    required int64 entity_oid = 1;

    // A list of action executed on the entity ordered by execution time.
    repeated ExecutedActionsChangeWindow executed_actions_change_window = 2;
}

message GetHistoricalActionStatsRequest {

    // A batch of queries.
    repeated SingleQuery queries = 2;

    // No longer used, in favour of the "batch" interface.
    optional HistoricalActionStatsQuery __deprecated_query__ = 1 [deprecated = true];

    message SingleQuery {
        // The ID of the query. This is opaque to the action orchestrator - it's used so that the
        // caller can identify which response refers to which query.
        optional int64 query_id = 1;

        optional HistoricalActionStatsQuery query = 2;
    }

}

message GetHistoricalActionStatsResponse {

    // One response for every query in the request.
    repeated SingleResponse responses = 2;

    // No longer used, in favour of the "batch" interface.
    optional ActionStats __deprecated_action_stat__ = 1 [deprecated = true];

    message SingleResponse {
        // The ID of the query in the request that this response refers to.
        optional int64 query_id = 1;

        oneof result {
            // If the query was executed successfully, this is the result.
            ActionStats action_stats = 2;

            // If the query failed - most notably due to some databae issue - this is
            // the error.
            string error = 3;
        }
    }
}

message GetCurrentActionStatsRequest {

    message SingleQuery {
        // The ID of the query. This is opaque to the action orchestrator - it's used so that the
        // caller can identify which response refers to which query.
        optional int64 query_id = 1;

        optional CurrentActionStatsQuery query = 2;
    }

    // A list of queries to execute.

    // Batched for efficiency - all queries targetting the same topology context will be
    // executed with one pass through the actions.
    repeated SingleQuery queries = 1;
}

message GetCurrentActionStatsResponse {
    message SingleResponse {
        // The ID of the query in the request that this response refers to.
        optional int64 query_id = 1;

        // The number of action stats depends on the group_by criteria in the query.
        // There will be one CurrentActionStat for each distinct CurrentActionStat.stat_group.
        //
        // See: CurrentActionStat.StatGroup
        repeated CurrentActionStat action_stats = 2;
    }

    repeated SingleResponse responses = 1;
}

message RemoveActionsAcceptancesAndRejectionsRequest {
    // The ID of the policy.
    // Acceptance and rejection will be removed for all actions associated with this policy.
    optional int64 policy_id = 1;
}

message RemoveActionsAcceptancesAndRejectionsResponse {
}

// Request message for resending audited actions.
message ResendAuditedActionsRequest {
    // The ID of the workflow.
    // Actions earlier audited with the workflow will be resent for audit again if they still
    // recommended by market and have this associated workflow.
    optional int64 workflow_id = 1;
}

// Response message for resending audited actions.
message ResendAuditedActionsResponse {
    // The number of actions which were resent.
    optional int32 audited_actions_count = 1;
}

message GetInstanceIdsForRecommendationIdsRequest {
    // The topology context the action belongs to.
    // There is one real-time topology context, and a context per-plan.
    optional int64 topology_context_id = 1;
    // The stable (recommendation) id for the action
    repeated int64 recommendation_id = 2;
}

message GetInstanceIdsForRecommendationIdsResponse {
    // The map from stable (recommendation) id to action id
    map<int64, int64> recommendation_id_to_instance_id = 2;
}

message GetActionChainsRequest {
    // Entity OIDs
    repeated int64 entity_oid = 1;
}

// Action change window query request.
message GetActionChangeWindowRequest {
    // Liveness states for which actions need to be queried.
    repeated ExecutedActionsChangeWindow.LivenessState liveness_states = 1;

    // Optionally restrict records to only action oids specified in this list. By default, will
    // get all specified states for all actions, if this action_oids list is empty.
    repeated int64 action_oids = 2;

    // Paging related params. Specify 'cursor' from 2nd page request onwards.
    optional common.PaginationParameters pagination_params = 3;
}

// Action change window query response page.
message GetActionChangeWindowResponse {
    // Change windows in this response page.
    repeated ExecutedActionsChangeWindow change_windows = 1;

    // Use the 'next_cursor' (if present) value for the next page request to be made.
    optional common.PaginationResponse pagination_response = 2;
}

// Action change window update request.
message UpdateActionChangeWindowRequest {
    // Keeps request info that is used to update 1 action change window record.
    message ActionLivenessInfo {
        // Action id for which updates need to be made.
        required int64 action_oid = 1;

        // If making action live, then this is the start time, else this is used as end time.
        required int64 timestamp = 2;

        // Liveness state to set the change window record to.
        required ExecutedActionsChangeWindow.LivenessState liveness_state = 3;
    }

    // Timing info about what to update.
    repeated ActionLivenessInfo liveness_info = 1;
}

// Placeholder for action change window update response.
message UpdateActionChangeWindowResponse {
}

// A service responsible for getting information about accepting actions and getting action information.
service ActionsService {
    // Accepts a list of actions. Each action is queued for execution.
    //
    // The action execution is asynchronous, and this method returns as soon as
    // the Action Orchestrator processes the accept.
    //
    // The method returns execution with a list of actions that were accepted. Rejected actions are
    // not added to the resulting ActionExecution.
    //
    // It currently only makes sense to execute actions belonging to the real-time topology context.
    rpc AcceptActions(MultiActionRequest) returns (ActionExecution);

    // Get an action execution by its ID.
    rpc GetActionExecution(ActionExecutionRequest) returns (ActionExecution);

    // Get all currently running action executions.
    rpc GetAllActionExecutions(AllActionExecutionsRequest) returns (AllActionExecutionsResponse);

    // Get information about an action. If you want information about multiple
    // actions use getActions instead of using this method multiple times.
    rpc GetAction(SingleActionRequest) returns (ActionOrchestratorAction);

    // Get information about all actions the Action Orchestrator knows about for an a given context.
    // if enforce_limit in the pagination_params is true (default), it will stream actions in
    // next page in chunks to client, with the first response to be pagination info. (if no fields
    // in pagination_params are set, the service will use the default sort order and limit.)
    // if enforce_limit is set to false, it will stream all actions to client in chunks.
    rpc GetAllActions(FilteredActionRequest) returns (stream FilteredActionResponse);

    // Get information about multiple actions in a topology context.
    // If an ID present in the IDs in the MultiActionRequest
    rpc GetActions(MultiActionRequest) returns (stream ActionOrchestratorAction);

    // Get information for the topology contexts and their associated actions known to this service.
    rpc GetTopologyContextInfo(TopologyContextInfoRequest) returns (stream TopologyContextResponse);

    // Delete all actions associated with a particular topology context.
    rpc DeleteActions(DeleteActionsRequest) returns (DeleteActionsResponse);

    // Get information about the counts of actions that match a set of criteria.
    // The purpose of the method is to avoid retrieving the actual action objects when only the
    // number of actions is required, thereby saving time and resources.
    //
    // Returns a NOT_FOUND status if the ActionService doesn't know about the
    // GetActionCountsRequest.topology_context_id.
    rpc GetActionCounts(GetActionCountsRequest) returns (GetActionCountsResponse);

    // Get information about the counts of actions by entity level. For one entity, it could have
    // multiple action types, and for each action type, it could have a few action counts. It requires
    // parameter provide involved entities ids, otherwise it will return INVALID_ARGUMENT status.
    // Returns a NOT_FOUND status if the ActionService doesn't know about the
    // GetActionCountsByEntityRequest.topology_context_id.
    rpc GetActionCountsByEntity(GetActionCountsByEntityRequest) returns (GetActionCountsByEntityResponse);

    // Returns a NOT_FOUND status if the ActionService doesn't know about the
    // GetActionCountsByDateRequest.topology_context_id.
    rpc GetActionCountsByDate(GetActionCountsRequest) returns (GetActionCountsByDateResponse);

    // Return the stats grouped by Action Category.
    rpc GetActionCategoryStats(GetActionCategoryStatsRequest) returns (GetActionCategoryStatsResponse);

    // Cancel the execution of outstanding actions i.e. actions which are queued
    // but not yet executed.
    // If the automation settings are changed by the user, the queued automation
    // actions are no longer valid as their execution state has changed. So we need to
    // cancel such actions.
    rpc CancelQueuedActions(CancelQueuedActionsRequest) returns (CancelQueuedActionsResponse);

    // Get historical action stats. Current action stats supports more filtering and grouping options.
    rpc GetHistoricalActionStats(GetHistoricalActionStatsRequest) returns (GetHistoricalActionStatsResponse);

    // Get current action stats. This call is separate from the historical action stats call
    // because it supports additional filtering/grouping options, and may return more data.
    rpc GetCurrentActionStats (GetCurrentActionStatsRequest) returns (GetCurrentActionStatsResponse);

    // Removes acceptance and rejection for all actions which associated with certain policy.
    rpc RemoveActionsAcceptancesAndRejections (RemoveActionsAcceptancesAndRejectionsRequest) returns (RemoveActionsAcceptancesAndRejectionsResponse);

    // Resends actual actions from earlier audited actions associated with certain workflow.
    // This call don't affect the data in audit bookkeeping cache and it works only for
    // orchestration targets using internal bookkeeping mechanism (02/10/2021 only ActionStreamKafka)
    rpc ResendAuditEvents (ResendAuditedActionsRequest) returns (ResendAuditedActionsResponse);

    // The the instance ID provided stable ID of the actions
    rpc GetInstanceIdsForRecommendationIds (GetInstanceIdsForRecommendationIdsRequest) returns (GetInstanceIdsForRecommendationIdsResponse);

    // Get action chains.
    rpc GetActionChains (GetActionChainsRequest) returns (stream ActionChain);

    // Get all action change window records matching the input request criteria.
    rpc GetActionChangeWindows (GetActionChangeWindowRequest) returns (GetActionChangeWindowResponse);

    // Updates action change window records.
    rpc UpdateActionChangeWindows (UpdateActionChangeWindowRequest) returns (UpdateActionChangeWindowResponse);
}
