syntax = "proto2";
package action;

option java_package = "com.vmturbo.common.protobuf.action";

import "common/EnvironmentTypeEnum.proto";
import "common/Pagination.proto";
import "topology/TopologyDTO.proto";
import "CloudCostDTO.proto";

message Explanation {
   oneof action_explanation_type {
       MoveExplanation move = 1;
       ResizeExplanation resize = 2;
       ActivateExplanation activate = 3;
       DeactivateExplanation deactivate = 4;
       ReconfigureExplanation reconfigure = 5;
       ProvisionExplanation provision = 6;
   }
   // A list of explanations for move action.
    message MoveExplanation {
        repeated ChangeProviderExplanation change_provider_explanation = 1;
    }
    message ChangeProviderExplanation {
        oneof change_provider_explanation_type {
            Compliance compliance = 1;
            Congestion congestion = 2;
            Evacuation evacuation = 3;
            InitialPlacement initialPlacement = 4;
            Performance performance = 5;
            Efficiency efficiency = 6;
        }
        // A move explanation suggesting unavailability of commodities.
        message Compliance {
            // A list of commodities' base type which are missing in current supplier.
            repeated topology.CommodityType missing_commodities = 1;
        }

        // A move explanation suggesting commodity congestion.
        message Congestion {
            // A list of commodities' base type which are cheaper at the destination.
            // For the cloud, these are the commodities sold by the target entity which are
            // congested / over-utilized
            repeated topology.CommodityType congested_commodities = 1;

            // For the cloud, these are the commodities sold by the target entity which are
            // under-utilized
            repeated topology.CommodityType under_utilized_commodities = 2;

            // For the cloud, true if increasing RI coverage is the main reason for the move
            optional bool is_ri_coverage_increased = 3;
        }

        // A move explanation suggesting evacuation of buyers.
        message Evacuation {
            // A trader which was suspended so buyers of it should move out.
            required int64 suspended_entity = 1;
        }

        // A move explanation suggesting initial placement of buyer.
        message InitialPlacement {}

        // A move explanation suggesting an overall performance improvement.
        message Performance {}

        // Efficiency messages are currently generated for the cloud.
        // We generate an efficiency message when we move the on-demand cost is cheaper at destination.
        message Efficiency {
            // These are the commodities sold by the target entity which are
            // congested / over-utilized
            repeated topology.CommodityType congested_commodities = 1;

            // These are the commodities sold by the target entity which are
            // under-utilized
            repeated topology.CommodityType under_utilized_commodities = 2;

            // True if increasing RI coverage is the main reason for the move
            optional bool is_ri_coverage_increased = 3;
        }
    }

    // A resize explanation contains start and end utilization of the resize commodity.
    message ResizeExplanation {
        required float start_utilization = 1;
        required float end_utilization = 2;
    }

    // An activate explanation contains the base type of the most expensive commodity.
    message ActivateExplanation {
        optional int32 most_expensive_commodity = 1;
    }

    // Deactivate explanation will always be improve overall efficiency.
    message DeactivateExplanation {}

    // Reconfigure explanation contains the base type of the reconfigure commodity.
    message ReconfigureExplanation {
        repeated topology.CommodityType reconfigure_commodity = 1;
    }

    message ProvisionExplanation {
        oneof provision_explanation_type {
            ProvisionBySupplyExplanation provision_by_supply_explanation = 1;
            ProvisionByDemandExplanation provision_by_demand_explanation = 2;
        }
        // Provision by supply explanation contains the base type of the most expensive commodity.
        message ProvisionBySupplyExplanation {
            // TODO: Change this to topology.CommodityType when M2 provides sufficient information to do so.
            required int32 most_expensive_commodity = 1;
        }

        // Provision by demand explanation
        message ProvisionByDemandExplanation {
            // The OID of the entity which has a shopping list that can't be satisfied by any provider.
            required int64 buyer_id = 1;

            // A list of entries keep information about commodities whose capacity needs to be changed to accommodate
            // the demand and their new capacity.
            repeated CommodityNewCapacityEntry commodity_new_capacity_entry = 2;

            // A list of entries keep commodities whose requested quantity can not be satisfied and
            // the max amount from any provider in market.
            repeated CommodityMaxAmountAvailableEntry commodity_max_amount_available = 5;

            // An entry in commodity to new capacity map. The key is base type of a commodity whose
            // capacity needs to be changed to satisfy the demand. The value is the new capacity for
            // that commodity.
            message CommodityNewCapacityEntry {
                // TODO: Change this to topology.CommodityType when M2 provides sufficient information to do so.
                required int32 commodity_base_type = 1;
                required float new_capacity = 2;
            }

            // An entry in commodity to max amount available from sellers map. The key is base type of a
            // commodity whose requested quantity can not be satisfied. The value is the max amount that
            // from any provider in market and the requested amount from the buyer.
            message CommodityMaxAmountAvailableEntry {
                // TODO: Change this to topology.CommodityType when M2 provides sufficient information to do so.
                required int32 commodity_base_Type = 1;
                required float max_amount_available = 2;
                required float requested_amount = 3;
            }
        }
    }

}

// Change one or more providers of an entity.
message Move {
    // Entity whose providers are being changed.
    required ActionEntity target = 1;

    // Details of the providers changes
    repeated ChangeProvider changes = 2;
}

message ChangeProvider {

    // Market can recommend a move action with an empty source. In this case,
    // the action is generated in order to start the entity in the destination provider.
    // Current provider.
    optional ActionEntity source = 1;

    // New provider.
    optional ActionEntity destination = 2;

    // Resource moving. For ex. volume of a VirtualMachine
    optional ActionEntity resource = 3;
}

message ActionEntity {
    // Both the fields are required.
    // ID of the entity provider.
    required int64 id = 1;

    // Type of the entity provider.
    required int32 type = 2;

    // The environment type of the entity.
    // This is used to infer which actions apply to which environments.
    optional .common.EnvironmentType environment_type = 3;
}

// Resize a commodity on a specific
// entity.
message Resize {
    // Entity where the resize should take place.
    required ActionEntity target = 1;

    // The commodity that's being resized.
    optional topology.CommodityType commodityType = 2;

    // The expected old capacity.
    optional float old_capacity = 3;

    // The recommended capacity.
    optional float new_capacity = 4;

    // which specific attribute of the commodity should be resized? defaults to "capacity".
    optional topology.CommodityAttribute commodity_attribute = 5 [default = CAPACITY];
}

// Activate an existing deactivated entity.
message Activate {
    // Entity to activate.
    required ActionEntity target = 1;

    // The in-demand commodities that triggered the activation
    // recommendation. These are guaranteed to be a subset of
    // the commodities sold by the entity.
    repeated topology.CommodityType triggering_commodities = 2;
}

// Deactivate an existing active entity.
message Deactivate {
    // Entity to deactivate.
    required ActionEntity target = 1;

    // The not-in-demand commodities that triggered the deactivation
    // recommendation. These are guaranteed to be a subset of
    // the commodities sold by the entity.
    repeated topology.CommodityType triggering_commodities = 2;
}

// Represents an action to reconfigure an entity shopping list of a trader that contains a mix of
// commodities no trader is able to provide.
// An example of a Reconfigure action is when a VM is configured to run with some network (say "VLAN-1")
// but the host it is currently running on doesn't have this network configured (i.e. doesn't provide
// access to that network). From a market perspective, the VM is buying a NetworkCommodity with key "VLAN-1"
// but the host doesn't sell this commodity. The Reconfigure action tells the user that s/he needs to
// (re)configure the host to provide access to that network. It should be possible to automate the execution
// of this action, but I am not sure we have. Similarly when a VM is configured to use some storage that is
// not mounted on the host that the VM is currently running on. For both configuration issues, another remedy
// is to move the VM to a host that does have access to the network/storage.
message Reconfigure {
    // Entity to reconfigure.
    required ActionEntity target = 1;

    // The current supplier. Assumed null if missing. It is included for the cases where
    // a trader is buying a particular shopping list from a supplier that isn't supplying the
    // complete list and no supplier can supply the complete list.
    optional ActionEntity source = 2;

    // TODO (davidblinn, July 2016): We also need to record the shopping list that caused the change.
}

// An action to provision an entity that matches another entity already existing in the system.
message Provision {
    // Entity to clone.
    required ActionEntity entity_to_clone = 1;

    // The OID of the newly provisioned entity (that does not yet exist in the system).
    // TODO: Make this non-negative per feedback from Jerry. Need to coordinate this with the market folks.
    // Since this is a special case, we will just use the EntityId. The entity
    // type will be the same as the entity_to_clone.
    optional sint64 provisioned_seller = 2;
}

// Contains the information describing the recommendation for what
// action should be executed in the environment.
message ActionInfo {
    // You can infer the ActionType enum to describe this action
    // based on which oneof field is set.
    oneof action_type {
        Move move = 1;
        Reconfigure reconfigure = 2;
        Provision provision = 3;
        Resize resize = 4;
        Activate activate = 5;
        Deactivate deactivate = 6;
    }
}

message Action {
    // ID for the action.
    required int64 id = 1;

    required ActionInfo info = 2;

    // The importance signifies a relative weight of the action. The one with the higher
    // importance should be taken first.
    required double importance = 3;

    // The explanation for the action
    required Explanation explanation = 4;

    // Indicates whether the market considers the action to be executable based on its dependency
    // ordering of actions. There is a high likelihood of non-executable actions not succeeding
    // because another action should be executed first.
    optional bool executable = 5;

    // Indicates level of supporting of action by probe or not, depends on action
    // capabilities (policies) of probe.
    optional SupportLevel supportingLevel = 6;

    // Hourly savings if the action is taken.
    optional common_dto.CurrencyAmount savings_per_hour = 7;

    // Levels of supporting action by probe
    enum SupportLevel {
        // Unknown support level - up to the application to decide how to interpret this.
        // (note - we added this after UNSUPPORTED, so that unknown support levels wouldn't default
        // to SUPPORTED. But realistically it's probably best to treat this as equivalent to
        // UNSUPPORTED when encountering it in the code).
        UNKNOWN = 0;

        // Full support - will be shown an UI and may be executed
        SUPPORTED = 1;

        // Should be only shown in the UI, cannot be executed
        SHOW_ONLY = 2;

        // Shouldn't be shown, cannot be executed
        UNSUPPORTED = 3;
    }
}

// Actions the market recommends.
message ActionPlan {
    // The ID of the plan.
    required int64 id = 1;

    // The ID of the topology this action plan applies to.
    optional int64 topology_id = 2;

    // The ID of the topology context. Used to differentiate, for example, between real and plan contexts.
    // If not set, it is an error.
    optional int64 topology_context_id = 3;

    // The timestamp at which the analysis that generated this action plan began.
    //
    // This timestamp is captured prior to constructing the economy for analysis.
    //
    // The time is in "system time" and not necessarily UTC, however, times on action plans
    // are comparable. See documentation in Java's System#currentTimeMillis() for further details.
    optional int64 analysis_start_timestamp = 4;

    // The timestamp at which the analysis that generated this action plan completed.
    //
    // The difference between this timestamp and the analysis_start_timestamp approximates
    // the time it took the market component to construct the economy and perform analysis.
    //
    // Note that these timestamps do NOT provide an indication of the time at which data for
    // the analysis was captured from the customer's infrastructure.
    optional int64 analysis_complete_timestamp = 5;

    // The type of action plan.
    optional ActionPlanType action_plan_type = 6;

    enum ActionPlanType {
        // Action Plan with Actions generated by Market.
        MARKET = 1;
        // Action Plan with Buy RI actions generated by Cost component.
        BUY_RI = 2;
    }

    repeated Action action = 17;
}

// ActionMode must be nested in a message type because the DISABLED variant otherwise clashes
// with the DISABLED variant in ActionState
// The ActionMode determines the automation status of a class of actions.
enum ActionMode {
    // The recommendation and execution of this action is disabled. The user
    // credited with disabling a disabled action is the user that created the policy
    // that assigned this mode to the action.
    DISABLED = 0;

    // The recommendation will be shown to the user in the UI but cannot be executed
    // by the system.
    RECOMMEND = 1;

    // The recommendation will be shown to the user in the UI and can be optionally
    // executed or dismissed. The user credited with accepting or rejecting the action
    // is the user that made the decision, not the user that set the policy.
    MANUAL = 2;

    // The recommendation will be automatically executed by the system. The user credited
    // with executing an automated action is the user that created the policy that
    // assigned this mode to the action.
    AUTOMATIC = 3;
}

// The ActionType describes what type of action should be performed.
enum ActionType {
    // An unknown action type
    NONE = 0;

    // Start a service entity. May be recommended by the market as a move from nothing to something.
    START = 1;

    // Move a service entity from one provider to another.
    MOVE = 2;

    // Suspend a service entity. Suspended service entities may be subsequently restarted via a START command.
    SUSPEND = 3;

    // Provision a new service entity.
    PROVISION = 4;

    // Supply a service entity with a new configuration.
    RECONFIGURE = 5;

    // Resize (either up or down) a service entity.
    RESIZE = 6;

    // Activate a non-active service entity.
    ACTIVATE = 7;

    // Deactivate an active service entity.
    DEACTIVATE = 8;
}

// The ActionState describes the current state of an action.
// The possible state transitions are:
//
// READY
//   |-> CLEARED
//   |-> QUEUED ---------> IN_PROGRESS
//                             |-------> SUCCEEDED
//                             |-------> FAILED
enum ActionState {
    // An action that is READY is one that has not yet been decided by the system.
    // Changes in policy or capability that affect actions in the READY state will be applied to
    // those actions and potentially cause them to be decided at that point.
    READY = 0;

    // An action that has been CLEARED is one that was at one time recommended by the market but
    // is now no longer. Actions in DISABLED mode are not immediately CLEARED. Instead, they
    // stay in the READY state but are not shown in the UI or executed.
    CLEARED = 1;

    // Actions in the QUEUED state have been accepted (ie by a user or policy), but cannot be
    //executed because, for instance, the target associated with the action is busy processing
    // many other actions and would be overwhelmed by sending additional requests.
    QUEUED = 2;

    // An action that is currently being executed.
    IN_PROGRESS = 3;

    // A completed action that has completed successfully.
    SUCCEEDED = 4;

    // A completed action that has completed but had errors.
    FAILED = 5;
}

// The ActionDecision provides information about why OperationsManager
// decided to execute or not to execute a particular action.
message ActionDecision {

    // The time at which the decision was made. Milliseconds since the unix epoch.
    optional int64 decisionTime = 1;

    // An action may be undecided, executed, or cleared.
    oneof decision {
        ExecutionDecision execution_decision = 2;
        ClearingDecision clearing_decision = 3;
    }

    // Explains why an action was executed and who accepted the action to execute it.
    message ExecutionDecision {
        enum Reason {
            MANUALLY_ACCEPTED = 1;
            AUTOMATICALLY_ACCEPTED = 2;
        }

        // The reason why the action was decided to be executed.
        required Reason reason = 1;

        // Executed actions may only be attributed to users.
        // When manually accepted, this will be the UUID of the user who manually accepted it.
        // When automatically accepted, this will be the UUID of the user who configured the
        // setting to automatically accept it.
        required string userUuid = 2;
    }

    // Explains why an action was not executed and what in the system caused it
    // to not be executed.
    message ClearingDecision {
        enum Reason {
            NO_LONGER_RECOMMENDED = 1;
            PROBE_UNABLE_TO_EXECUTE = 2;
        }

        // The reason why the action was decided NOT to be executed.
        required Reason reason = 1;

        // Describes what in the system in the system caused the action not to be executed.
        oneof attributionId {
            // When NO_LONGER_RECOMMENDED, this will be the ID of the first action plan
            // after the initial recommendation that did not recommend the action anymore.
            int64 actionPlanId = 2;

            // When PROBE_UNABLE_TO_EXECUTE, this will be the ID of that probe.
            int64 probeId = 3;
        }
    }
}

// Severity categories express the urgency a user should apply in addressing a particular
// action recommendation. In the context of an entity, severity is calculated as the most severe
// action for all actions that apply to a particular service entity.
enum Severity {
    NORMAL = 1;     // Indicates a normal state. An entity in a normal state is considered healthy.
    MINOR = 2;      // The action will improve the situation in the user's environment,
                    // but if not addressed, unlikely to have serious consequences.
    MAJOR = 3;      // The action has some urgency.
    CRITICAL = 4;   // The most critical category, these actions should be addressed immediately.
}

// The state of an action step.
// Composite or multi-step actions may have multiple execution steps.
message ExecutionStep {
    enum Status {
        // Indicates the operation is waiting for earlier steps to complete before
        // it can be executed.
        QUEUED = 1;

        // Indicates the operation is in progress.
        IN_PROGRESS = 2;

        // Indicates the operation has completed and succeeded.
        SUCCESS = 3;

        // Indicates the operation has completed and failed.
        FAILED = 4;
    }

    // The time at which this step of the action was queued to be executed.
    // If an action is ready to execute as soon as it is queued, the transition will be immediate.
    // Milliseconds since the unix epoch.
    optional int64 enqueueTime = 1;

    // The time at which this step of the action started execution.
    // Milliseconds since the unix epoch.
    optional int64 startTime = 2;

    // The time at which this step of the action completed.
    // Initialized to null, and set to the current time when the action completes.
    optional int64 completionTime = 3;

    // The status of this step in the action's execution.
    optional Status status = 4;

    // Any errors that occurred with the action step. The list will be empty if there have been no errors.
    repeated string errors = 5;

    // The ID of the target assigned to execute the action.
    optional int64 targetId = 6;

    // The progress of the execution step. A percentage (0-100). Only meaningful for steps that are IN_PROGRESS.
    optional int32 progressPercentage = 7;

    // A description of what the probe is currently executing as part of this step (ie "Moving VM...").
    // Only meaningful on actiosn that are IN_PROGRESS.
    optional string progressDescription = 8;
}

// The category of the action is a short-form explanation of the reason for the action.
// It's derived from the full explanation.
enum ActionCategory {
    // Unknown - kept at the lowest index so that any categories a service
    // doesn't know about (e.g. due to a different version of the enum) take on
    // this value.
    UNKNOWN = 0;

    // The action is required to ensure an entity has the resources it needs for optimal performance
    // (e.g. sizing up in order to address overutilization).
    PERFORMANCE_ASSURANCE = 1;

    // The action is required in order to improve the efficiency of the system - i.e. how well
    // it utilizes resources (e.g. moving a VM to a less-utilized provider, or shutting down
    // a PM if it's VMs can be moved to other hosts without sacrificing performance)
    EFFICIENCY_IMPROVEMENT = 2;

    // This action is required to prevent future risks.
    PREVENTION = 3;

    // This action is required in order to comply with a placement policy (e.g. a VM needs
    // to be in a certain cluster).
    COMPLIANCE = 4;
}

// An ActionSpec maintains the state of an action in the system.
// It contains information necessary to execute the action as well as the
// execution state of the action.
message ActionSpec {
    // The recommended steps to take in the environment.
    optional Action recommendation = 1;

    // The execution step associated with an action that is being executed.
    // If the action has not begun to be executed, will be empty.
    //
    // TODO: composite or multi-step actions may require more than one step to complete execution.
    // TODO: (per Roman) Perhaps this can be an "optional ActionExecutionSpec" then, where the
    // TODO: ActionExecutionSpec will currently just have an optional ExecutionStep for the current execution step?
    optional ExecutionStep executionStep = 2;

    // The time at which this action was recommended.
    // Milliseconds since the unix epoch.
    optional int64 recommendationTime = 3;

    // The explanation of the action to be displayed to the user.
    // An explanation describes the purpose of the action and how it will improve the user's
    // environment in understandable terms.
    optional string explanation = 4;

    // The ActionDecision provides information about why OperationsManager
    // decided to execute or not to execute a particular action.
    // Not provided if no decision has been made.
    optional ActionDecision decision = 5;

    // The mode of the action. The action mode is established by checking the policy and capability
    // for the action when it is received by the action orchestrator.
    optional ActionMode actionMode = 6;

    // The state of the action. The state of an action may change due to certain user actions or system events.
    // The initial state is determined by the action mode.
    optional ActionState actionState = 7;

    // The ID of the action plan to which this action's recommendation belongs.
    optional int64 actionPlanId = 8;

    // Whether the action is ready to be executed. Actions that require other actions to successfully execute
    // before they can be executed are not considered executable. Actions that are already being executed
    // or have been executed are not considered executable.
    optional bool isExecutable = 9;

    // The category of the action. It is consumed by UI to indicate if the effect of the action is
    // assure performance, improve efficiency, prevention or compliance.
    optional ActionCategory category = 10 [default = UNKNOWN];
}

// A filter to be supplied with action queries.
// The conditions in the query filter will be AND-ed together, so only actions
// that match all of them will be returned.
message ActionQueryFilter {
    // If true, include only externally visible actions in the response.
    // If false, include only non-externally visible actions.
    // If not present, the field is not used to filter.
    optional bool visible = 1;

    // Include only actions in the given states.
    repeated ActionState states = 2;

    // Include only actions that involve any of these entities.
    optional InvolvedEntities involvedEntities = 3;

    message InvolvedEntities {
        // The oids of the involved entities.
        repeated int64 oids = 11;
    }

    // date range for the request; dates are epoch longs, e.g. Unix Timestamp
    // We currently require both start_date and end_date to be not null.
    // Todo: will work on provide default values.
    optional int64 start_date = 4;

    optional int64 end_date = 5;

    // Include only actions in the given modes.
    repeated ActionMode modes = 6;

    // Include only actions of the given types.
    repeated ActionType types = 7;

    // Include only actions of the given categories.
    repeated ActionCategory categories = 8;

    // Include only actions in a particular environment.
    optional .common.EnvironmentType environment_type = 9;
}

// The number of actions of a specific type that match the criteria in
// the request.
message TypeCount {

    // The type of the action this message pertains to.
    optional ActionType type = 1;

    // The number of actions of the type that match the request criteria.
    optional int64 count = 2;
}

// The number of actions of a specific state and mode that match the criteria in
// the request.
message StateAndModeCount {

    // The type of the action this message pertains to.
    optional ActionState state = 1;

    // The mode of the action this message pertains to.
    optional ActionMode mode = 2;

    // The number of actions of the type that match the request criteria.
    optional int32 count = 3;
}

// A message used to address a single action within a topology context.
message SingleActionRequest {
    // The topology context the action belongs to.
    // There is one real-time topology context, and a context per-plan.
    optional int64 topology_context_id = 1;

    // The ID of the action being addressed.
    optional int64 action_id = 2;
}

// A message used to address multiple actions within a topology context.
message MultiActionRequest {
    // The topology context the actions belongs to.
    // There is one real-time topology context, and a context per-plan.
    optional int64 topology_context_id = 1;

    // The IDs of the actions being addressed.
    repeated int64 action_ids = 2;
}

// A message used to retrieve all actions within a topology context.
message FilteredActionRequest {
    // The topology context for which to retrieve actions.
    // There is one real-time topology context, and a context per-plan.
    optional int64 topology_context_id = 1;

    // A filter to be applied to the actions retrieved. If no filter is supplied
    // all actions are returned.
    optional ActionQueryFilter filter = 2;

    // The pagination parameters for the request.
    // If not set, the service will use the default sort order and limit.
    optional common.PaginationParameters pagination_params = 3;
}

message FilteredActionResponse {
    // The list of actions.
    // The length of this list will not exceed the limit set in the request pagination
    // parameters.
    // The actions will be ordered according to the order in the request pagination parameters.
    repeated ActionOrchestratorAction actions = 1;

    // The response message containing pagination-related response parameters.
    optional common.PaginationResponse pagination_response = 2;
}

// The response to an AcceptAction request.
message AcceptActionResponse {
    // The spec for the action that was successfully accepted.
    // Only present if the action was successfully accepted.
    optional ActionSpec action_spec = 1;

    // An error describing why the action could not be accepted.
    // Only present if the action could not be accepted.
    optional string error = 2;
}

message ActionOrchestratorAction {
    // The ID of the action in the system.
    optional int64 action_id = 1;

    // The description of the action in the system. May not be present
    // if a client requests information about an unknown action id.
    optional ActionSpec action_spec = 2;
}

// A request for information about topology contexts known to the action service.
message TopologyContextInfoRequest {
    // Currently empty.
}

// Information about the actions within a given topology context.
message TopologyContextResponse {
    // The topology context the actions belongs to.
    // There is one real-time topology context, and a context per-plan.
    optional int64 topology_context_id = 1;

    // The number of actions known for this context.
    optional int32 action_count = 2;
}

// The request message to delete all actions associated with a topology context.
message DeleteActionsRequest {
    // The topology context for which to delete actions.
    // This may be the context for a live or plan topology context.
    optional int64 topology_context_id = 1;
}

// The response message to delete all actions associated with a topology context.
// An error may be thrown if the context is not found or the operation fails.
message DeleteActionsResponse {
    // The topology context for which actions were deleted.
    optional int64 topology_context_id = 1;

    // The number of actions deleted.
    optional int32 action_count = 2;
}

// The request message to GetActionCounts.
// Allows the user to specify criteria that will affect the number
// of actions in the response.
message GetActionCountsRequest {
    // The topology context for which to retrieve actions.
    // There is one real-time topology context, and a context per-plan.
    optional int64 topology_context_id = 1;

    // A filter to be applied to the actions retrieved. If no filter is supplied
    // all actions are returned.
    optional ActionQueryFilter filter = 2;
}

// The response message to GetActionCounts.
message GetActionCountsResponse {
    // The total number of actions matching the criteria in the request.
    optional int64 total = 1;

    // The actions in the request organized by type.
    // Each ActionType will appear at most once in this list, so the maximum size of the list
    // is the number of distinct ActionType values.
    // The order of the list (w.r.t. TypeCount.type) is not guaranteed.
    repeated TypeCount counts_by_type = 2;
}

// The response message to GetActionCountsByDate.
message GetActionCountsByDateResponse {

    message ActionCountsByDateEntry {
        // date of the actions recommended
        optional int64 date = 1;

        // The actions in the request organized by state and mode. And they are belong to a date.
        repeated StateAndModeCount counts_by_state_and_mode = 2;
    }
    repeated  ActionCountsByDateEntry action_counts_by_date= 1;
}

// The request message to get actions counts by each entity.
message GetActionCountsByEntityRequest {
    // The topology context for which to retrieve actions.
    optional int64 topology_context_id = 1;

    // A filter to be applied to the actions retrieved. It is required in order to call
    // GetActionCountsByEntity function.
    optional ActionQueryFilter filter = 2;
}

// The response message to GetActionCountsByEntity.
message GetActionCountsByEntityResponse {
    // Contains relationship from a entity to related list of action TypeCount. One entity could
    // multiple action type and each action type could have multiple actions.
    message ActionCountsByEntity {
        // Id of entity
        optional int64 entity_id = 1;

        // The actions in the request organized by type. And they are belong to a entity.
        // Each ActionType will appear at most once in this list. so the maximum size of the list
        // is the number of distinct ActionType values. And the sum of the list action counts will
        // be the total action counts of this entity.
        repeated TypeCount counts_by_type = 2;
    }

    // List of ActionCountsByEntity, it contains all requested entities.
    repeated ActionCountsByEntity action_counts_by_entity = 1;
}

message CancelQueuedActionsRequest {
}

message CancelQueuedActionsResponse {
    // Number of actions that were cancelled from execution.
    optional int32 cancelled_count = 1;
}

message GetActionCategoryStatsRequest{
    // The topology context for which to retrieve the actions category stats.
    optional int64 topology_context_id = 1;

    // Type of entities to include in the stats
    repeated int32 entity_type = 2;
}

message GetActionCategoryStatsResponse {

    repeated ActionCategoryStats action_stats_by_category = 1;
}

// Stats for actions based on ActionCategory type.
message ActionCategoryStats {

    optional ActionCategory action_category = 1;

    // Number of actions of 'action_category' type.
    optional int32 actions_count = 2;

    // Number of target entities which are affected by the the actions
    // of 'action_category' type.
    optional int32 entities_count = 3;

    optional double savings = 4;

    optional double investment = 5;
}

// A query for current actions (i.e. the most recent actions)
message CurrentActionStatsQuery {

    // Filter for the kinds of actions to return stats for.
    // If not present, results for all action kinds will be returned.
    optional ActionGroupFilter action_group_filter = 1;

    // Filter for the scope to return stats for. If set, will only retrieve actions affecting
    // entities in the scope. If not set, will retrieve actions affecting any entities in
    // the realtime topology.
    optional ScopeFilter scope_filter = 2;

    // Grouping criteria for the action stats.
    // If not set, action stats for each found time will be combined into a single value.
    repeated GroupBy group_by = 10;

    // The filter to apply to the actions considered for the counts.
    //
    // This is pretty much the same as the one in HistoricalActionCountsQuery, but it's kept
    // separate for future-proofing. The live version is much more flexible because we're dealing
    // with in-memory objects. Given the breadth of the API it's very possible that we will need
    // to add other properties here. However, adding a property here shouldn't confuse users of
    // the historical interface.
    message ActionGroupFilter {
        // Match action groups with any of these action types.
        // An empty list means match all action types.
        repeated ActionType action_type = 1;

        // Match action groups with any of these action modes.
        // An empty list means match all action modes.
        repeated ActionMode action_mode = 2;

        // Match action groups with any of these action categories.
        // An empty list means match all action categories.
        repeated ActionCategory action_category = 3;

        // Match action groups with any of these action states.
        // An empty list means match all action states.
        repeated ActionState action_state = 4;
    }

    // The entities involved in an action must match this filter in order for the action to be
    // considered for the counts.
    //
    // If any entity involved in an action matches this filter, the action will be counted.
    // However, only the matching entity will be counted towards the "numEntities" in the returned
    // stats. For example, suppose there is a move of VM 1 from Host 1 to Host 2. If the scope
    // filter targets VM 1, the returned stats will be:
    //    numActions: 1
    //    numEntities: 1 (the VM)
    // On the other hand, if the scope filter targets all three entities the returned stats will be:
    //    numActions: 1
    //    numEntities: 3
    message ScopeFilter {
        // The topology context for the scope.
        // If unset, use the default realtime context - i.e. get the live actions.
        optional int64 topology_context_id = 1;

        oneof scope {
            // A subset of entities in the most recent topology for the context.
            GlobalScope global = 2;

            // A list of entity IDs.
            EntityScope entity_list = 3;
        }

        // The scope is all entities in the specific topology context,
        // with some optional high-level filters to allow targeting a subset of the entities.
        message GlobalScope {
            // Restrict to a particular environment type.
            // If not set, include entities of all environment types.
            optional .common.EnvironmentType environment_type = 1;

            // Restrict to a particular list of entity types.
            // If empty, get the value across all entity types.
            repeated int32 entity_type = 2;
        }

        // The scope is a specific list of entity IDs.
        message EntityScope {
            repeated int64 oids = 1;
        }

    }

    // Group and aggregate/combine action stats according to this property.
    // This is similar to the SQL "GROUP BY" statement.
    enum GroupBy {
        // No grouping - aggregate all matching action stats into a single set of values.
        NONE = 0;

        // Group by action state - action stats will be grouped by the action state. For example,
        // if we have 1 READY "MOVE" action, 1 READY "RESIZE" action, and 1 QUEUED "MOVE" action,
        // the returned action count will be 2 for the "READY" state and 1 for the "QUEUED" state.
        ACTION_STATE = 1;

        // Group by action state - action stats will be grouped by the action state. For example,
        // if we have 1 "MOVE" action and 1 "RESIZE action for performance, and 1 "MOVE" action for
        // compliance, the returned action count will be 2 for the "performance" category and
        // 1 for the "compliance" category.
        ACTION_CATEGORY = 2;

        // Group by action type.
        ACTION_TYPE = 3;

        // Group by the reason commodity (e.g. VMem, CPU, etc)
        REASON_COMMODITY = 4;

        // Entity type of the primary entity for the action.
        TARGET_ENTITY_TYPE = 5;
    }
}

// A query for historical action stats.
//
// In the historical stat case we support a subset of the criteria we have in "realtime".
// Also, the target of the query is constrained - we only keep action stats for certain
// "management units" (e.g. global market, cluster).
message HistoricalActionStatsQuery {

    message ActionGroupFilter {
        // Match action groups with any of these action types.
        // An empty list means match all action types.
        repeated ActionType action_type = 1;

        // Match action groups with any of these action modes.
        // An empty list means match all action modes.
        repeated ActionMode action_mode = 2;

        // Match action groups with any of these action categories.
        // An empty list means match all action categories.
        repeated ActionCategory action_category = 3;

        // Match action groups with any of these action states.
        // An empty list means match all action states.
        repeated ActionState action_state = 4;
    }

    // A "management unit" is an object in the system that is often interacted with by the user.
    // It's a higher level than a single entity. For example, a "cluster" is a typical management
    // unit.
    //
    // A "management unit subgroup" is a subset of the entities within the scope of the management
    // unit - for example "Virtual Machines on hosts in the cluster X", or "CLOUD VMs in the
    // global environment".
    //
    // Stats are only available for certain management unit subgroups.
    message MgmtUnitSubgroupFilter {
        // The scope.
        oneof scope {
            // The entire market.
            bool market = 1;

            // A specific "management unit". Note that only certain management units have
            // historical action stats tracked.
            int64 mgmt_unit_id = 2;
        }

        // Restrict to a particular environment type.
        optional .common.EnvironmentType environment_type = 10;

        // Restrict to a particular list of entity types.
        // If empty, get the value across all entity types.
        //
        // IMPORTANT - if you care about "action count", "investment", or "savings" you should not
        // query for multiple "entity_type"s (the empty list is an exception). Certain actions -
        // "MOVE"s in particular - affect multiple
        // entities at the same time, so there will be double-counting of actions if stats for
        // multiple entity types is combined. For example, a single PM "MOVE" involves a VM and
        // PMs. If you query for "all entity types", the returned action count will be 2!
        //
        // (roman, Jan 16 2019): It's not clear if it's an important use case to support arbitrary
        // groupings of entity types. For now we typically see exactly one entity type.
        repeated int32 entity_type = 11;
    }

    message TimeRange {
        // The start time, in epoch millis.
        optional int64 start_time = 1;

        // The end time, in epoch millis.
        optional int64 end_time = 2;
    }

    // Group and aggregate/combine action stats according to this property.
    // This is similar to the SQL "GROUP BY" statement.
    enum GroupBy {
        // No grouping - aggregate all matching action stats into a single set of values.
        NONE = 0;

        // Group by action state - action stats will be grouped by the action state. For example,
        // if we have 1 READY "MOVE" action, 1 READY "RESIZE" action, and 1 QUEUED "MOVE" action,
        // the returned action count will be 2 for the "READY" state and 1 for the "QUEUED" state.
        ACTION_STATE = 1;

        // Group by action state - action stats will be grouped by the action state. For example,
        // if we have 1 "MOVE" action and 1 "RESIZE action for performance, and 1 "MOVE" action for
        // compliance, the returned action count will be 2 for the "performance" category and
        // 1 for the "compliance" category.
        ACTION_CATEGORY = 2;
    }

    // The time range for the query.
    // Must be present (or else no results will be returned).
    optional TimeRange time_range = 1;

    // Filter for the kinds of actions to return stats for.
    // If not present, results for all action kinds will be returned.
    optional ActionGroupFilter action_group_filter = 2;

    // Filter for the scope to return stats for.
    // Must be present (or else no results will be returned).
    optional MgmtUnitSubgroupFilter mgmt_unit_subgroup_filter = 3;

    // Grouping criteria for the action stats.
    // If not set, action stats for each found time will be combined into a single value.
    optional GroupBy group_by = 10;
}

// The collection of action stats that match a query.
message ActionStats {
    // The ID of the mgmt unit the stats are for (e.g. a cluster, a business account, etc.)
    // Not set if describing the whole market.
    optional int64 mgmt_unit_id = 1;

    // One snapshot for every distinct time that has stats in the time range specified by the
    // query. Note that even if there are no stats matching the query in the snapshot, there
    // will still be a snapshot returned with the time set.
    repeated ActionStatSnapshot stat_snapshots = 10;

    message ActionStatSnapshot {
        // The time the stats were collected.
        optional int64 time = 1;

        // A list of aggregated stats.
        // The size of the list is determined as follows:
        //   - If no stats matched the query in the set of stats collected at the time - 0.
        //   - If there were stats:
        //        - If "group by" is "NONE", there will just be 1 stat.
        //        - If "group by" is another field, there will be 1 stat for each distinct value
        //          of the field that has stats. For example, if "group by" is ActionState, there
        //          will be one record for each state present in the stats that matched the query.
        repeated ActionStat stats = 10;
    }
}

// Action stats for the most recent set of actions the action orchestrator knows about.
message CurrentActionStat {

    // If the "group_by" in the query was non-empty, this message contains the values of the
    // grouping criteria that a particular "CurrentActionStat" aggregated across.
    // For example, if the "group_by" was "ACTION_STATE" and "ACTION_TYPE" and there were four
    // matching actions:
    //     - An IN-PROGRESS move action for performance
    //     - An IN-PROGRESS move action for compliance
    //     - A READY move action
    //     - A READY resize action
    //
    // There would be three returned "CurrentActionStat" messages:
    //     - One with StatGroup : { action_state : "IN_PROGRESS", action_type : "MOVE" }
    //           and action_count : 2
    //     - One with StatGroup : { action_state : "READY", action_type : "MOVE" }
    //           and action_count : 1
    //     - One with StatGroup : { action_state : "READY", action_type : "RESIZE" }
    //           and action_count : 1
    message StatGroup {
        // The state for this action stat, only present if the "group_by" in the query contained
        // "ACTION_STATE."
        optional ActionState action_state = 1;

        // The category for this action stat, only present if the "group_by" in the query contained
        // "ACTION_CATEGORY."
        optional ActionCategory action_category = 2;

        // The type for this action stat, only present if the "group_by" in the query contained
        // "ACTION_TYPE."
        optional ActionType action_type = 3;

        // The target entity type, only present if the "group_by" in the query contained
        // "TARGET_ENTITY_TYPE".
        optional int32 target_entity_type = 4;

        // The base type of the commodity that is "most responsible" for the action. Only present if
        // the "group_by" in the query contained "REASON_COMMODITY".
        optional int32 reason_commodity_base_type = 5;
    }

    // The stat group this action stat is in.
    // See the "StatGroup" documentation.
    optional StatGroup stat_group = 1;

    // The number of actions affecting the mgmt unit subgroups that matched the query.
    optional int32 action_count = 20;

    // The number of affected entities in the mgmt unit subgroups that matched the query.
    optional int32 entity_count = 21;

    // The amount saved by actions in the mgmt unit subgroups that matched the query.
    optional double savings = 25;

    // The amount of investment required for actions in the mgmt unit subgroups that matched
    // the query.
    // Note - We keep investments separate from savings so that we can see both separately.
    optional double investments = 26;
}

// An action stat for a particular management unit at a particular time.
message ActionStat {
    message Value {
        optional double min = 1;
        optional double max = 2;
        optional double avg = 3;
        optional double total = 4;
    }

    // The state for this action stat, only present if the "group_by" in the query was
    // "ACTION_STATE."
    optional ActionState action_state = 1;

    // The category for this action stat, only present if the "group_by" in the query was
    // "ACTION_CATEGORY."
    optional ActionCategory action_category = 2;

    // The number of actions affecting the mgmt unit subgroups that matched the query.
    optional Value action_count = 20;

    // The number of affected entities in the mgmt unit subgroups that matched the query.
    optional Value entity_count = 21;

    // The amount saved by actions in the mgmt unit subgroups that matched the query.
    optional Value savings = 25;

    // The amount of investment required for actions in the mgmt unit subgroups that matched
    // the query.
    // Note - We keep investments separate from savings so that we can see both separately.
    optional Value investments = 26;
}

message GetHistoricalActionStatsRequest {

    // A batch of queries.
    repeated SingleQuery queries = 2;

    // No longer used, in favour of the "batch" interface.
    optional HistoricalActionStatsQuery __deprecated_query__ = 1 [deprecated = true];

    message SingleQuery {
        // The ID of the query. This is opaque to the action orchestrator - it's used so that the
        // caller can identify which response refers to which query.
        optional int64 query_id = 1;

        optional HistoricalActionStatsQuery query = 2;
    }

}

message GetHistoricalActionStatsResponse {

    // One response for every query in the request.
    repeated SingleResponse responses = 2;

    // No longer used, in favour of the "batch" interface.
    optional ActionStats __deprecated_action_stat__ = 1 [deprecated = true];

    message SingleResponse {
        // The ID of the query in the request that this response refers to.
        optional int64 query_id = 1;

        oneof result {
            // If the query was executed successfully, this is the result.
            ActionStats action_stats = 2;

            // If the query failed - most notably due to some databae issue - this is
            // the error.
            string error = 3;
        }
    }
}

message GetCurrentActionStatsRequest {

    message SingleQuery {
        // The ID of the query. This is opaque to the action orchestrator - it's used so that the
        // caller can identify which response refers to which query.
        optional int64 query_id = 1;

        optional CurrentActionStatsQuery query = 2;
    }

    // A list of queries to execute.

    // Batched for efficiency - all queries targetting the same topology context will be
    // executed with one pass through the actions.
    repeated SingleQuery queries = 1;
}

message GetCurrentActionStatsResponse {
    message SingleResponse {
        // The ID of the query in the request that this response refers to.
        optional int64 query_id = 1;

        // The number of action stats depends on the group_by criteria in the query.
        // There will be one CurrentActionStat for each distinct CurrentActionStat.stat_group.
        //
        // See: CurrentActionStat.StatGroup
        repeated CurrentActionStat action_stats = 2;
    }

    repeated SingleResponse responses = 1;
}

// A service responsible for getting information about accepting actions and getting action information.
service ActionsService {
    // Accepts an action, queueing it for execution.
    //
    // The action execution is asynchronous, and this method returns as soon as
    // the Action Orchestrator processes the accept.
    //
    // It currently only makes sense to execute actions belonging to the real-time topology context.
    rpc AcceptAction(SingleActionRequest) returns (AcceptActionResponse);

    // Get information about an action. If you want information about multiple
    // actions use getActions instead of using this method multiple times.
    rpc GetAction(SingleActionRequest) returns (ActionOrchestratorAction);

    // Get information about all actions the Action Orchestrator knows about for an a given context.
    rpc GetAllActions(FilteredActionRequest) returns (FilteredActionResponse);

    // Get information about multiple actions in a topology context.
    // If an ID present in the IDs in the MultiActionRequest
    rpc GetActions(MultiActionRequest) returns (stream ActionOrchestratorAction);

    // Get information for the topology contexts and their associated actions known to this service.
    rpc GetTopologyContextInfo(TopologyContextInfoRequest) returns (stream TopologyContextResponse);

    // Delete all actions associated with a particular topology context.
    rpc DeleteActions(DeleteActionsRequest) returns (DeleteActionsResponse);

    // Get information about the counts of actions that match a set of criteria.
    // The purpose of the method is to avoid retrieving the actual action objects when only the
    // number of actions is required, thereby saving time and resources.
    //
    // Returns a NOT_FOUND status if the ActionService doesn't know about the
    // GetActionCountsRequest.topology_context_id.
    rpc GetActionCounts(GetActionCountsRequest) returns (GetActionCountsResponse);

    // Get information about the counts of actions by entity level. For one entity, it could have
    // multiple action types, and for each action type, it could have a few action counts. It requires
    // parameter provide involved entities ids, otherwise it will return INVALID_ARGUMENT status.
    // Returns a NOT_FOUND status if the ActionService doesn't know about the
    // GetActionCountsByEntityRequest.topology_context_id.
    rpc GetActionCountsByEntity(GetActionCountsByEntityRequest) returns (GetActionCountsByEntityResponse);

    // Returns a NOT_FOUND status if the ActionService doesn't know about the
    // GetActionCountsByDateRequest.topology_context_id.
    rpc GetActionCountsByDate(GetActionCountsRequest) returns (GetActionCountsByDateResponse);

    // Return the stats grouped by Action Category.
    rpc GetActionCategoryStats(GetActionCategoryStatsRequest) returns (GetActionCategoryStatsResponse);

    // Cancel the execution of outstanding actions i.e. actions which are queued
    // but not yet executed.
    // If the automation settings are changed by the user, the queued automation
    // actions are no longer valid as their execution state has changed. So we need to
    // cancel such actions.
    rpc CancelQueuedActions(CancelQueuedActionsRequest) returns (CancelQueuedActionsResponse);


    // Get historical action stats. Current action stats supports more filtering and grouping options.
    rpc GetHistoricalActionStats(GetHistoricalActionStatsRequest) returns (GetHistoricalActionStatsResponse);

    // Get current action stats. This call is separate from the historical action stats call
    // because it supports additional filtering/grouping options, and may return more data.
    rpc GetCurrentActionStats(GetCurrentActionStatsRequest) returns (GetCurrentActionStatsResponse);
}
