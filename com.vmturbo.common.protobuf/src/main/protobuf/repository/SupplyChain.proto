syntax = "proto2";

package repository;

option java_package = "com.vmturbo.common.protobuf.repository";
option java_outer_classname = "SupplyChainProto";

import "common/EnvironmentTypeEnum.proto";
import "common/Pagination.proto";
import "CommonDTO.proto";
import "topology/TopologyDTO.proto";
import "action/ActionDTO.proto";

// The response to a supply chain request consists of a series of supply chain nodes
// that express graph of connections in the supply chain.
//
// All changes to this message must be backwards compatible. This message is persisted in the
// database for plans.
message SupplyChainNode {

    // A list of node members of a particular state.
    message MemberList {
        repeated int64 member_oids = 1;
    }

    // The entity type in this node of the supply chain. A node in
    // the chain may contain only one type of entity.
    optional int32 entity_type = 1;

    // The depth of this node.
    optional int32 supply_chain_depth = 2;

    // list of entity types that provide resources to the the entity types
    // at this node in the supply chain.
    repeated int32 connected_provider_types = 3;

    // list of entity types that consume resources from the entity types
    // at this node in the supply chain.
    repeated int32 connected_consumer_types = 4;

    // A map from entity state -> members of that state.
    map<int32, MemberList> members_by_state = 6;
}

// A description of a supply chain returned by the service.
message SupplyChain {
    // A list of supply chain nodes.
    // There will only be one node for every entity type in the returned supply chain.
    repeated SupplyChainNode supply_chain_nodes = 1;

    // The entities specified in the request that were not found - and whose supply chains
    // are therefore not included in the returned supply chain.
    repeated int64 missing_starting_entities = 10;
}

// Request the supply chain. A supply chain request may optionally specify a contextId and
// startingVertexId.
message GetSupplyChainRequest {
    // The ID of the topology context whose supply chains are being requested.
    // If no context is supplied, returns the supply chain for the current live context.
    optional int64 context_id = 1;

    optional SupplyChainScope scope = 2;

    // If true, exclude entities that are technically in the supply chain but that are normally filtered
    // out of the response because they are considered visually distracting in the supply chain UI.
    // We'll use this flag to make sure we can find all qualifying entities in the user scope accessibility
    // calculation, which uses the supply chain calculation, but doesn't directly display the results.
    optional bool filter_for_display = 5 [default = true];
}

// The response to a "GetSupplyChain" request.
message GetSupplyChainResponse {
    // The supply chain.
    // Should be set in a successful request.
    optional SupplyChain supply_chain = 1;
}

// A supply chain seed defines the starting point of a supply chain query,
// and provides ways to limit the entities considered to be part of the
// supply chain.
message SupplyChainSeed {
    // The OID of the seed. This can be any arbitrary number.
    // Use this number to identify which response corresponds to which seed.
    optional int64 seed_oid = 1;

    optional SupplyChainScope scope = 2;
}

message GetMultiSupplyChainsRequest {
    // The ID of the topology context whose supply chains are being requested.
    // If no context is supplied, returns the supply chain for the current live context.
    optional int64 context_id = 1;

    // A list of "supply chain seeds" - each seed is a request for a supply chain.
    repeated SupplyChainSeed seeds = 2;
}

// The response to a GetMultiSupplyChainsRequest.
// There is one response for every seed in the request.
message GetMultiSupplyChainsResponse {
    // The OID of the SupplyChainSeed this response pertains to.
    optional int64 seed_oid = 1;

    // The supply chain for this seed.
    // May be unset (empty) if there was an error retrieving the supply chain.
    //
    // Note - Missing starting entities in the seed do not constitute an error. If some of those
    // entities are missing, there will be a partial supply chain, and the missing entities
    // will be listed in SupplyChain.missing_starting_entities.
    optional SupplyChain supply_chain = 2;

    // If the supply chain for this seed could not be retrieved, this is a description
    // of the error/reason. We use this instead of the regular error mechanism because
    // the failure for a single seed should not fail the entire call.
    optional string error = 10;
}

// The scope for a supply chain query.
// This will affect how we calculate the supply chain.
message SupplyChainScope {
    // The OIDs of the vertices to start from when constructing the supply chain.
    // The supply chains from each individual OID are merged into a single result.
    // If no starting vertex is specified, the global supply chain is retrieved.
    repeated int64 starting_entity_oid = 1;

    // The list of entity types to include in the resultant supplychain. If this
    // list is empty, then default filtering is done and SupplyChainNodes pertaining
    // to entity types normally displayed in the supply chain are included.
    repeated int32 entity_types_to_include = 3;


    // Only include entities in a particular environment type in the supply chain.
    // If not set, return all entities regardless of environment type.
    optional .common.EnvironmentType environment_type = 4;

    // Only include entities with the particular state.
    // If not set, return entities with any state.
    repeated .topology.EntityState entity_states_to_include = 5;
}

// Group By criteria for supply chain stats.
enum SupplyChainGroupBy {
    // Group by the type of entity.
    ENTITY_TYPE = 1;

    // Group by the state of entity.
    ENTITY_STATE = 2;

    // Group by the entity severity.
    // This will require a call to the action orchestrator to get the severities of entities.
    SEVERITY = 3;

    // Group by the action categories of actions associated with each entity.
    // This will require a call to the action orchestrator to get the categories of entities.
    ACTION_CATEGORY = 4;

    // Group by the display name of template of the entity
    TEMPLATE = 5;

    // Group by the IDs of targets that discovered the entity.
    TARGET = 6;

    // Group by the ID of the business account that owns the entity.
    BUSINESS_ACCOUNT_ID = 8;

    // Group by the ID of the resource group contains the entity.
    RESOURCE_GROUP = 9;
}

// A single supply chain statistic describing the number of entities
// in a particular "StatGroup" in the supply chain.
message SupplyChainStat {

    // Describes a unique combination of values that all the entities counted by this
    // SupplyChainStat have in common. The values that are relevant in the group depend on the
    // group_by parameter in the request.
    //
    // For example, if the topology has one powered off VM, two powered on VMs, and one host,
    // and the group_by criteria in the request is
    // [SupplyChainGroupBy.ENTITY_TYPE, SupplyChainGroupBy.ENTITY_STATE], then the
    // response would have three stat groups:
    //
    // { "entity_type" : VirtualMachine, "entity_state" : "POWERED_ON" } with 2 entities
    // { "entity_type" : VirtualMachine, "entity_state" : "POWERED_OFF" } with 1 entity
    // { "entity_type" : PhysicalMachine, "entity_state" : "POWERED_ON" } with 1 entity
    message StatGroup {
        // The entity type of the entities in this group. Set IFF the request group_by criteria
        // contains SupplyChainGroupBy.ENTITY_TYPE.
        optional int32 entity_type = 1;

        // The entity state of the entities in this group. Set IFF the request group_by criteria
        // contains SupplyChainGroupBy.ENTITY_STATE.
        optional .topology.EntityState entity_state = 2;

        // The severity of the entities in this group. Set IFF the request group_by criteria
        // contains SupplyChainGroupBy.SEVERITY.
        //
        // Note - an entity with no associated actions is considered to have "NORMAL" severity.
        optional .action.Severity severity = 3;

        // If the request group_by criteria contains SupplyChainGroupBy.ACTION_CATEGORY:
        //   If set, the entities in this group all have at least one associated action in this
        //   category. If unset, the entities in this group have no associated actions.
        //   Note: "associated actions" are actions that directly target the entity, NOT actions
        //   the entity is involved in. e.g. a MOVE is associated only with the VM being moved.
        //
        // Otherwise, this is unset.
        optional .action.ActionCategory action_category = 4;

        // If the request group_by criteria contains SupplyChainGroupBy.TEMPLATE:
        //   If set, the entities in this group all have template with the display name in
        //   this value.
        //
        // Otherwise, this is unset.
        optional string template = 5;

        // If the request group_by criteria contains SupplyChainGroupBy.TARGET:
        //   If set, the OID of the target that discovered the entities in this group.
        //   If unset, the entities in this group have no discovering target (shouldn't happen).
        //
        // Otherwise, this is unset.
        optional int64 target_id = 6;

        // If the request group_by criteria contains SupplyChainGroupBy.BUSINESS_ACCOUNT_ID:
        //   If set, the OID of the business account that owns the entities in this group.
        //   If unset, the entities in this group have no business account owner.
        //
        // Otherwise, this is unset.
        optional int64 account_id = 8;

        // If the request group_by criteria contains SuppluChainGroupBy.ResourceGroup:
        // If set, the resource group oids for this entities
        // If unset, the entities in this group don't belong to resource groups
        optional int64 resource_group_id = 9;
    }

    // The "group" of a particular stat. See "StatGroup" documentation.
    optional StatGroup stat_group = 1;

    // The entities in the group.
    optional int64 num_entities = 10;
}

// Request for supply chain statistics.
message GetSupplyChainStatsRequest {

    // The scope to use to calculate the supply chain.
    optional SupplyChainScope scope = 1;

    // The grouping criteria to use to aggregate the supply chain entities into
    // stat groups. The number of group_by criteria affects the number of returned
    // SupplyChainStat messages in the response.
    repeated SupplyChainGroupBy group_by = 10;
}

// Response for supply chain statistics.
message GetSupplyChainStatsResponse {

    // One SupplyChainStat for every unique combination of the request's group_by criteria values
    // in the entities in the supply chain.
    repeated SupplyChainStat stats = 1;
}

message LeafEntitiesRequest {
    repeated int64 seeds = 1;
    repeated .common_dto.EntityDTO.EntityType filter_out_classes = 2;
    optional common.PaginationParameters pagination_params = 3;
}

// Response for leaf entities.
//
// The leaf entities are the highest entities in the supply chain that have
// no consumers.
message LeafEntitiesResponse {
    message LeafEntity {
        required int64 oid = 1;
        required .common_dto.EntityDTO.EntityType entityType = 2;
        required string displayName = 3;
    }
    repeated LeafEntity leaves = 3;
    optional common.PaginationResponse pagination_response = 4;
}

// A service for fetching information about supply chains.
// The supply chain is a concept that expresses the links between entities in a topology.
service SupplyChainService {
    // Retrieve the supply chain.
    rpc GetSupplyChain(GetSupplyChainRequest) returns (GetSupplyChainResponse);

    rpc GetSupplyChainStats(GetSupplyChainStatsRequest) returns (GetSupplyChainStatsResponse);

    // Retrieve multiple supply chains in one call.
    // This is equivalent to calling GetSupplyChain multiple times, but it provides an easier way
    // to do it from the client's perspective and allows for optimizations on the server.
    //
    // The response streams back each supply chain once it's computed.
    rpc GetMultiSupplyChains(GetMultiSupplyChainsRequest) returns (stream GetMultiSupplyChainsResponse);

    // Retrieve the leaf entities.
    rpc GetLeafEntities(LeafEntitiesRequest) returns (LeafEntitiesResponse);
}
