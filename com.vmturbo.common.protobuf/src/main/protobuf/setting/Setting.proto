syntax = "proto2";
package setting;

option java_package = "com.vmturbo.common.protobuf.setting";
option java_outer_classname = "SettingProto";

// The SettingSpec defines a specification for a setting that will be used in the
// system. A SettingSpec can be of 2 different types: EntitySettingSpec or GlobalSettingSpec (check
// the specific message docs for the details).
// A SettingSpec should have a name, that will be used as an identifier. It will also have a
// SettingCategoryPath used to classify it, and a SettingValueType to specify which values
// are allowed for this setting.
message SettingSpec {

    // Name of the setting specification.
    // This is used as an identifier for this class. Two SettingSpec instances with the same name
    //should not exist.
    optional string name = 1;

    // The display name for the specification.
    // This is NOT used as an identifier, so multiple specs can have the same display name
    // (although to avoid confusion they should have different category paths).
    optional string display_name = 9;

    // Used to classify a setting spec into categories (and nested categories, like a path).
    //Example: the VM_Move_Automation setting spec can be under the Action_Policies category.
    optional SettingCategoryPath path = 2;

    // A SettingSpec can be of 2 different types:
    // - EntitySettingSpec, used to define settings that are related to entities. In this case
    //      every entity can have its own setting value.
    // - GlobalSettingSpec, used to define settings that are global for the system. In this case
    //      there is only one value possible for the whole system.
    oneof setting_type {
        EntitySettingSpec entity_setting_spec = 3;
        GlobalSettingSpec global_setting_spec = 4;
    }

    // The settingValueType is used to specify the type of values that a SettingSpec can have.
    oneof setting_value_type {
        BooleanSettingValueType boolean_setting_value_type = 5;
        NumericSettingValueType numeric_setting_value_type = 6;
        StringSettingValueType string_setting_value_type = 7;
        EnumSettingValueType enum_setting_value_type = 8;
    }
}

// SettingCategoryPath is used to classify a SettingSpec into categories (and sub categories, if
// needed, like a path).
// Example: the VMMoveAutomation setting spec can be under the ActionAutomation category.
// the HighAvailability setting spec can be under the OperationalConstrains category.
// Each one of those categories is represented by a node (with the respective name).
// If needed, we can further subdivide a category in subcategories. In this case, there will be
// subnode (with its respecting name) under the main category node.
message SettingCategoryPath {

    // the node used as a root
    optional SettingCategoryPathNode root_path_node = 1;

    // SettingCategoryPathNode is used to create a node in a SettingCategoryPath. A root node is used as a path
    // starting point.
    message SettingCategoryPathNode {
        // name of the node
        optional string node_name = 1;

        // link to the following node in the path
        optional SettingCategoryPathNode child_node = 2;
    }
}

// GlobalSettingSpec, used to define settings that are global for the system. In this case
// there is only one value possible for the whole system.
message GlobalSettingSpec {}

// EntitySettingSpec, used to define settings that are related to entities. In this case
// every entity can have its own setting value.
message EntitySettingSpec {

    // tiebreaker to use in order to resolve a conflict when multiple settings are applied to the
    // same entity
    optional SettingTiebreaker tiebreaker = 1;

    // scope of this setting, which entities can have it
    optional EntitySettingScope entity_setting_scope = 2;

    // Whether the setting should be automatically created for default setting policy for this
    // endity types.
    optional bool allow_global_default = 3 [default = true];
}

// SettingTiebreaker defines the strategy used to resolve conflicts when an entity has more than one
// setting value to be applied. We always want to pick the most conservative value. Sometimes the
// most conservative value is the bigger one, sometimes is the smaller one.
// The creator of the setting spec need to define which one of the possible options is the most
// conservative one.
//
// Example:
// 2 value for HA setting on a host: 80 and 90. 80 is more conservative (smaller of the 2).
// 2 value for setting about the number of polling cycle to wait, before removing objects: 2 and 5.
// in this other case, 5 is the more conservative (bigger of the 2).
//
// Bigger and smaller are used for any type of setting spec. They refers to the compareTo
// method for the related java object. Example:
// For boolean, TRUE is bigger than FALSE.
// For Enum, the natural order implemented by compareTo is the order in which the constants are
// declared
// For String, the lexicographic ordering is used.
enum SettingTiebreaker {
    BIGGER = 1;
    SMALLER = 2;
}

// EntitySettingScope is associated with an EntitySettingSpec, in order to indicate which
// type of entities are allowed to have this setting.
// The class keeps a list of entities allowed. It can also specify that all entity types are allowed.
message EntitySettingScope {
    oneof scope {
        EntityTypeSet entity_type_set = 1;
        AllEntityType all_entity_type = 2;
    }

    // Set of entity types that are allowed in this scope.
    message EntityTypeSet {
        repeated int32 entity_type = 1;
    }

    // This message allows all the entity types to be used as scope (which means that there is
    // no scope in reality)
    message AllEntityType {}
}

// BooleanSettingValueType is used to indicate that a setting is carrying a Boolean type of value.
message BooleanSettingValueType {
    // The default value for this setting.
    optional bool default = 1;

    // Entity type -specific defaults to overrride the global default for this setting.
    // They are only used if there should be different default values for different entity types
    map<int32, bool> entityDefaults = 4;
}

// NumericSettingValueType is used to indicate that a setting is carrying a numeric
// type of value. The class can specify a minimum and a maximum number; the value should be in that
// range in order to be accepted.
// if min/max is not specified, then we can assume that there is no min/max (except the memory limit
// given by the float variable itself)
message NumericSettingValueType {
    // Minimum number that the value can assume.
    optional float min = 1;

    // Maximum number that the value can assume.
    optional float max = 2;

    // The default value for this setting.
    optional float default = 3;

    // Entity type -specific defaults to overrride the global default for this setting.
    // They are only used if there should be different default values for different entity types
    map<int32, float> entityDefaults = 4;
}

// StringSettingValueType is used to indicate that a setting is carrying a String type of value.
// The class can specify a regex that will be used against the string value, in order to validate it
message StringSettingValueType {
    // regex used to validate against the setting value
    optional string validation_regex = 1;

    // The default value for this setting.
    optional string default = 2;

    // Entity type -specific defaults to overrride the global default for this setting.
    // They are only used if there should be different default values for different entity types
    map<int32, string> entityDefaults = 4;
}

// EnumSettingValueType is used to indicate that a setting is carrying an enumeration
// type of value. The class will be created by specifying the allowed value that this setting value
// can accept.
message EnumSettingValueType {
    // holds the possible values accepted by this setting
    // Entries in this list should be unique.
    // TODO check if the ordering when deserializing might be a problem
    repeated string enum_values = 1;

    // The default value for this setting.
    // The value must be one of enum_values.
    optional string default = 2;

    // Entity type -specific defaults to overrride the global default for this setting.
    // They are only used if there should be different default values for different entity types
    map<int32, string> entityDefaults = 4;
}

// Used to deserialize a collection of Specs from a single JSON file
message SettingSpecCollection {
    repeated SettingSpec setting_specs = 1;
}

// A Setting adjusts the behavior of some object or collection of objects in the system.
// The semantics of the setting are specified via the SettingSpec that the setting references.
message Setting {
    // The reference by name to the SettingSpec that specifies the semantics of this setting.
    optional string setting_spec_name = 1;

    // The value of the setting. May be one of a number of options.
    // BooleanSettingValue must be paired with a SettingSpec that has a BooleanSettingValueType,
    // NumericSettingValue must be paired with a SettingSpec that has a NumericSettingValueType,
    // StringSettingValue must be paired with a SettingSpec that has a StringSettingValueType,
    // and EnumSettingValue must be paired with a SettingSpec that has a EnumSettingValueType.
    //
    // Not complying with the above restrictions results in a Setting that is considered malformed
    // and may produce errors.
    oneof value {
        BooleanSettingValue boolean_setting_value = 7;
        NumericSettingValue numeric_setting_value = 8;
        StringSettingValue string_setting_value = 9;
        EnumSettingValue enum_setting_value = 10;
    }
}

// Contains the value of a boolean setting.
message BooleanSettingValue {
    optional bool value = 1;
}

// Contains the value of a numeric setting.
message NumericSettingValue {
    optional float value = 1;
}

// Contains the value of a string setting.
message StringSettingValue {
    optional string value = 1;
}

// Contains the value of a setting that must be one of the options in an enumeration.
message EnumSettingValue {
    optional string value = 1;
}

// A SettingPolicy binds a group of settings to one or more groups of entities that those settings
// should apply to. A SettingPolicy may also be a default, in which case there is no specific scope
// and the SettingPolicy will affect entities of a given type to which no other SettingPolicy applies.
// Note that the DefaultScope vs GroupScope resolution mechanism differs from the
// "most conservative" conflict resolution mechanism described elsewhere.
message SettingPolicy {
    enum Type {
        // Default setting policies are created by the system, and can only be modified by
        // users. Default policies are defined on a per-entity-type basis, and there is only
        // one default policy per entity type. The policy applies to all entities of that type
        // for which there is no other SettingPolicy.
        DEFAULT = 1;

        // User setting policies are created by users, and must be scoped.
        // User policies always override default policies, regardless of conflict resolution
        // strategies.
        USER = 2;

        // Discovered setting policies are discovered by probes and are scoped to groups
        // also discovered by probes. Discovered setting policies follow a similar conflict
        // resolution strategy to user setting policies.
        DISCOVERED = 3;
    }

    // The id of the SettingPolicy.
    optional int64 id = 1;

    // The properties of the SettingPolicy.
    optional SettingPolicyInfo info = 2;

    // The type of the setting policy.
    optional Type setting_policy_type = 7;
}

// Describes the properties of a SettingPolicy object. For additional information about
// SettingPolicies, see the comments for the SettingPolicy message.
message SettingPolicyInfo {
    // The name of the SettingPolicy, used to name it in the UI.
    //
    // The name should be unique.
    //
    // Default setting policies have an auto-generated name for consistency and debugging, but it
    // is not meant to be user-visible. The API component (and UI) should generate the "right"
    // name to use.
    optional string name = 1;

    // The settings that should be applied to the entities in the scope.
    //
    // These settings may only be associated with SettingSpecs that are of an EntitySettingSpec type.
    // It makes no sense to apply a GlobalSettingSpec to a SettingPolicy.
    //
    // The entity_type on the SettingSpecs associated with each of these Settings should match
    // the entity_type on the SettingPolicy.
    repeated Setting settings = 2;

    // The type of the entities to which the SettingPolicy applies.
    // If the SettingPolicy is a default, it applies to all entities of that type for which
    // there is no other SettingPolicy that applies.
    //
    // Consider the following simple example with the following default and user-created SettingPolicy for
    // VirtualMachines:
    // default : {
    //   vmMove: MANUAL
    //   resize: MANUAL
    // }
    //
    // sqlVmSettingPolicy : {
    //   vmMove: AUTOMATE
    // }
    //
    // Now consider a virtual machine in the scope of the "sqlVmSettingPolicy". This VM will have moves
    // automated and resize set to manual.
    // In contrast, a virtual machine NOT in the scope of the the "sqlVmSettingPolicy" will have both
    // moves and resizes as manually executable.
    optional int32 entity_type = 3;

    // Whether the setting_policy is enabled or not.
    // Default setting policies are always enabled.
    optional bool enabled = 4 [default = true];

    // The period for which the setting policy may apply.
    // If not specified, the setting policy may apply all the time.
    optional Schedule schedule = 5;

    // The scope of a setting policy is the groups of entities the policy applies to.
    // Default setting policies do not have a scope (see detailed comments above).
    optional Scope scope = 7;

    // The ID of the target that discovered this setting policy.
    // This field is only present or has meaning on DISCOVERED type setting policies.
    optional int64 target_id = 8;
}

// The time during which the setting policy may be active.
message Schedule {

    // Currently for one-time policies the UI supports periods of activity only within
    // a single day. That is, a one-time policy can only be active on one day. A monthly policy
    // can be active on only one day per month currently.

    // The first occasion the policy is active (milliseconds since Unix epoch)
    optional int64 start_time = 2;

    // Duration of period of activity (time [milliseconds since Unix epoch] at which or number
    // of minutes until the policy becomes inactive). This is necessary when describing a period of
    // time, but unnecessary when describing a time at which a process is triggered.
    oneof duration {
        int64 end_time = 3;
        int32 minutes = 4;
    }


    // Whether the setting policy applies daily, weekly, monthly, or only once.
    oneof recurrence {
        OneTime one_time = 10;
        Daily daily = 11;
        Weekly weekly = 12;
        Monthly monthly = 13;
    }

    // The last date (milliseconds since Unix epoch) the policy is active, if any
    oneof ending {
        int64 last_date = 6;
        Perpetual perpetual = 7;
    }

    // A policy active only once
    message OneTime {}

    // A policy active daily
    message Daily {}

    // A policy active weekly
    message Weekly {

        // The day(s) of the week on which the policy should be active
        // If not set, this defaults to the day of the start_date
        repeated DayOfWeek days_of_week = 4;
    }

    // A policy active monthly
    message Monthly {

        // The day(s) of the month on which the policy should be active.
        // Currently only one day per month, the first day of the policy,
        // is supported by the UI, but who knows what the future holds.
        // If not set, this defaults to the day of the start_date
        repeated int32 days_of_month = 4;
    }

    enum DayOfWeek {
        MONDAY = 1;
        TUESDAY = 2;
        WEDNESDAY = 3;
        THURSDAY = 4;
        FRIDAY = 5;
        SATURDAY = 6;
        SUNDAY = 7;
    }

    // To mark that a policy will continue indefinitely without an end date
    message Perpetual {}

}

// A scope defines the groups to which the SettingPolicy applies to.
// A Setting is applied to an entity the same regardless if it is a member of 1, 2, or n of
// the groups in the scope. A setting will not be applied to an entity if it is not in the scope.
// The entity_type of the groups in the scope should match the entity_type of the SettingPolicy.
message Scope {
    // The ids of the groups to which a SettingPolicy should be bound.
    repeated int64 groups = 1;
}

// Used to request a single SettingSpec
message SingleSettingSpecRequest {
    // name of the Spec being requested
    optional string setting_spec_name = 1;
}

// Used to request all the single SettingSpecs that match some criteria.
// If no fields are set, returns all SettingSpecs.
message SearchSettingSpecsRequest {
    // If set, return only setting specs that match the list of names.
    repeated string setting_spec_name = 1;
}

// Used to request a single global setting.
message GetSingleGlobalSettingRequest {
    // Name of the Setting being requested.
    // If it is not set, no setting is returned.
    optional string setting_spec_name = 1;
}

// Get the Global Settings whose names matche the ones in the request
message GetMultipleGlobalSettingsRequest {
    // If set, return only settings that match the list of names.
    // If absent, return all global settings
    repeated string setting_spec_name = 1;
}

message UpdateGlobalSettingRequest {
    // Name of the Setting which needs to be updated.
    optional string setting_spec_name = 1;

    // The new value for the setting.
    // There is a gap in the proto tag numbers because
    // when new fields are added, new value types can be
    // assigned contigious numbers
    oneof value {
        BooleanSettingValue boolean_setting_value = 6;
        NumericSettingValue numeric_setting_value = 7;
        StringSettingValue string_setting_value = 8;
        EnumSettingValue enum_setting_value = 9;
    }
}

message UpdateGlobalSettingResponse {
}

message GetSettingPolicyRequest {
    // Whether to include the SettingSpecs associated with the Setting objects
    // in the policy in the response. This is often desirable because the specs
    // are usually necessary to understand the semantics of how to apply a given
    // setting.
    optional bool include_setting_specs = 1 [default = false];

    // A SettingPolicy can be fetched either by its id or name.
    // Names are unique so there should be at most one SettingPolicy with a given name.
    oneof setting_policy_identifier {
        int64 id = 2;
        string name = 3;
    }
}

// The response for a GetSettingPolicy rpc.
message GetSettingPolicyResponse {
    // The requested SettingPolicy.
    optional SettingPolicy setting_policy = 1;

    // The SettingSpec objects associated with the Settings in the SettingPolicy.
    // This list will be only be populated if GetSettingPolicyRequest.include_setting_specs
    // was true.
    repeated SettingSpec setting_specs = 2;
}

message UpdateSettingPolicyRequest {
    // The ID of the setting policy to edit.
    // This should be set.
    optional int64 id = 1;

    // The updated SettingPolicyInfo to use for the setting policy.
    // This info will completely override the existing
    // info of the setting policy. Therefore it needs to be valid, with all relevant
    // fields filled out.
    optional SettingPolicyInfo new_info = 2;
}

message UpdateSettingPolicyResponse {
    // The updated setting policy.
    optional SettingPolicy setting_policy = 1;
}

message DeleteSettingPolicyRequest {
    // The ID of the policy to delete.
    optional int64 id = 1;
}

message DeleteSettingPolicyResponse {
}

// List the created SettingPolicies.
// The SettingSpecs associated with the settings in the returned SettingPolicies
// should be retrieved in a separate call.
message ListSettingPoliciesRequest {
    // Return only policies of the particular type.
    optional SettingPolicy.Type type_filter = 1;
    // The type of the topology. is plan or not.
    optional int64 context_Id = 2;
}

// Settings associated with an entity
message EntitySettings {
    // The OID of the entity. This is a required field
    optional int64 entity_oid = 1;

    // The user settings associated with this entity.
    // These are the settings after conflict resolution.
    repeated SettingToPolicyId user_settings = 2;

    // The default setting policy that applies to this entity, if any. Since there is only one
    // default policy per entity type, each entity has at most one default policy.
    // User settings override any settings in the default policy.
    //
    // The Topology Processor (TP) is responsible for setting the default setting policy associated
    // with this entity's type. The TP could have sent all the settings
    // associated with an entity instead, but that approach is inefficient since there will be many
    // more default settings than the user settings. The Group Component can extract the setting
    // values from the default setting policy internally, since it's the authority for setting
    // policy definitions.
    optional int64 default_setting_policy_id = 3;

    message SettingToPolicyId {

        // The setting applied to the entity after conflict resolution.
        optional Setting setting = 1;

        // The ID of the non-default setting policy the setting is associated with.
        optional int64 setting_policy_id = 2;

    }
}

message UploadEntitySettingsRequest {
    // required field
    optional int64 topology_id = 1;

    // required field
    optional int64 topology_context_id = 2;

    repeated EntitySettings entity_settings = 3;
}

message UploadEntitySettingsResponse {
}

// This message is used to look up a topology to retrieve entity settings from.
message TopologySelection {
    // The topology context to look in.
    // If not present, use the realtime topology context.
    optional int64 topology_context_id = 1;

    // The topology ID to look for within the topology context.
    // If not present, use the latest topology in the topology context.
    // Note that if the topology_id is set to a topology not in the realtime topology context,
    // the topology_context_id HAS to be set to find the topology.
    optional int64 topology_id = 2;
}

// This filter restricts the entity settings returned by the service.
message EntitySettingFilter {
    // List of entity OIDs to return settings for.
    // If the OID list is absent or empty, return the settings for all entities.
    repeated int64 entities = 1;

    // include the Setting Policies the settings belong to
    optional bool includeSettingPolicies = 2;
}

message GetEntitySettingsRequest {
    // Specifies the topology to draw the settings from.
    // If not present, get the settings from the most recent
    // realtime topology.
    optional TopologySelection topology_selection = 1;

    // The filter to apply to the actual settings to retrieve. Use this
    // to restrict the amount of settings (e.g. the Action Orchestrator
    // may not care about Topology settings).
    optional EntitySettingFilter setting_filter = 2;

}

message GetEntitySettingsResponse {

    message SettingsForEntity {
        // The ID of the entity
        // This will always be set.
        optional int64 entity_id = 1;

        // The settings on the entity that match the filter in the request.
        // This list may be empty if no matching settings exist.
        repeated SettingToPolicyName settings = 2;

        // The setting policy this setting is associated with.
        optional SettingPolicy settingPolicy = 3;
    }

    // The settings that match the filters in the request.
    // If the request contains an explicit set of entities to get settings for, the
    // response will contain an entry for every specified entity. If the request is
    // for all entities, the response will only return entries for entities that have settings
    // matching the parameters in the request.
    repeated SettingsForEntity settings = 1;

    message SettingToPolicyName {

        // The setting applied to the entity after conflict resolution.
        optional Setting setting = 1;

        // The name of the non-default setting policy the setting is associated with.
        optional string setting_policy_name = 2;
    }
}

message GetGlobalSettingResponse {
    // The requested setting. It will be unset
    // if the setting is not found.
    optional Setting setting = 1;
}

// Service responsible for setting operations
service SettingService {
    // Get a setting spec
    rpc GetSettingSpec(SingleSettingSpecRequest) returns (SettingSpec);

    // Search setting specs, returning all that match some criteria.
    rpc SearchSettingSpecs(SearchSettingSpecsRequest) returns (stream SettingSpec);

    // Get global setting
    rpc GetGlobalSetting(GetSingleGlobalSettingRequest) returns (GetGlobalSettingResponse);

    // Get global setting
    rpc GetMultipleGlobalSettings(GetMultipleGlobalSettingsRequest) returns (stream Setting);

    // Update global setting
    rpc UpdateGlobalSetting(UpdateGlobalSettingRequest) returns (UpdateGlobalSettingResponse);
}

// A request to create a SettingPolicy.
message CreateSettingPolicyRequest {
    // The properties of the SettingPolicy to create.
    optional SettingPolicyInfo setting_policy_info = 1;
}

// The response for creating a SettingPolicy.
message CreateSettingPolicyResponse {
    // The created SettingPolicy.
    optional SettingPolicy setting_policy = 1;
}

message ResetSettingPolicyRequest {
    // The ID of the setting policy to reset. This should be the ID of an existing DEFAULT setting
    // policy.
    optional int64 setting_policy_id = 1;
}

message ResetSettingPolicyResponse {
    // The setting policy, after the reset.
    optional SettingPolicy setting_policy = 1;
}

// Return the setting policies associated with an entity.
message GetEntitySettingPoliciesRequest{

    optional int64 entity_oid = 1;
}

message GetEntitySettingPoliciesResponse {

    repeated SettingPolicy setting_policies = 1;
}

// The SettingPolicyService provides RPC's for CRUD-type operations related to SettingPolicy objects.
service SettingPolicyService {
    // Create a setting policy
    // If the setting policy is invalid (e.g. it refers to settings that don't exist), this
    // will return a INVALID_ARGUMENT status.
    // If a setting policy of the same name already exists, this will return a ALREADY_EXIST status.
    rpc CreateSettingPolicy (CreateSettingPolicyRequest) returns (CreateSettingPolicyResponse);

    // Update an existing setting policy.
    //
    // If the setting policy is not found, this will return a NOT_FOUND status.
    // If the edited setting policy is invalid, this will return an INVALID_ARGUMENT status.
    // If a setting policy of the same name already exists, this will return an ALREADY_EXIST status.
    rpc UpdateSettingPolicy(UpdateSettingPolicyRequest) returns (UpdateSettingPolicyResponse);

    // Reset a default setting policy back to "factory" settings.
    //
    // Resetting a setting policy only makes sense for default setting policies.
    //
    // If the specified policy is not found, this will return a NOT_FOUND status.
    // If the specified policy is not a default policy, this will return an INVALID_ARGUMENT status.
    rpc ResetSettingPolicy(ResetSettingPolicyRequest) returns (ResetSettingPolicyResponse);

    // Delete an existing setting policy.
    //
    // If the setting policy is not found, this will return a NOT_FOUND status.
    // If the setting policy is a default policy, this will return an INVALID_ARGUMENT status because
    // default policies can't be deleted.
    rpc DeleteSettingPolicy(DeleteSettingPolicyRequest) returns (DeleteSettingPolicyResponse);

    // Fetch a specific SettingPolicy by its id or name.
    // If the SettingPolicy is not found, it will not be set in the response.
    rpc GetSettingPolicy (GetSettingPolicyRequest) returns (GetSettingPolicyResponse);

    // List setting policies.
    rpc ListSettingPolicies (ListSettingPoliciesRequest) returns (stream SettingPolicy);

    // Store the Entities and their associated Settings
    // karthikt : Should we stream this from the client instead of sending in
    // one request as the number of entites could be huge?
    rpc UploadEntitySettings(UploadEntitySettingsRequest) returns (UploadEntitySettingsResponse);

    // Retrieve settings associated with a selection of entities.
    // Returns a NOT_FOUND status if there is no setting information for the selected topology.
    rpc GetEntitySettings(GetEntitySettingsRequest) returns (GetEntitySettingsResponse);

    // Get setting policies associated with an entity
    rpc GetEntitySettingPolicies(GetEntitySettingPoliciesRequest) returns (GetEntitySettingPoliciesResponse);
}
