syntax = "proto2";
package group;

option java_package = "com.vmturbo.common.protobuf.group";

import "search/Search.proto";
import "setting/Setting.proto";

// A group is a set of entities that can be treated collectively for the
// purpose of settings, policies, statistics, and other operations.
message Group {
    // The origin represents how the group came to be in the system.
    enum Origin {
        // A user group was explicitly created by the user, and is owned by
        // the turbonomic system.
        USER = 1;

        // A discovered group exists in the user's topology, and was imported and interpreted
        // as part of a discovery.
        // Users cannot mutate or delete discovered groups.
        DISCOVERED = 2;
    }

    // The type of the group. Protobuf doesn't have inheritance, so we use a Type to
    // differentiate between sufficiently different kinds of groups.
    enum Type {
        // A group is a set of entities that can be treated collectively for the
        // purpose of settings, policies, statistics, and other operations.
        GROUP = 1;

        // A cluster is closely related to a group, and is most relevant when working with on-prem
        // environments - especially vSphere. It's essentially the unit of management for large
        // vSphere environments.
        //
        // Since clusters cannot be created by the user, all clusters have Origin == DISCOVERED.
        //
        // TODO (roman, July 27 2017): In the future we will likely want to rearchitect the model
        // away from "cluster" terminology to "management unit" terminology, where groups of entities
        // that act as the units of management for an environment - e.g. Clusters for vSphere, Business
        // Units for cloud environments - can be represented in a common fashion.
        CLUSTER = 2;

        // A temporary group is a GROUP that can only have static scope, is not persisted to
        // the database, and gets removed after a certain time.
        //
        // Temporary groups are not valid targets for policies or setting policies, and are
        // only used for query purposes.
        TEMP_GROUP = 3;
    }

    // The unique numeric identifier of the group.
    // This field will always be set.
    optional int64 id = 1;

    // The type of the group.
    // This field will always be set.
    optional Type type = 7 [default = GROUP];

    // The origin of this group.
    // This field will always be set.
    optional Origin origin = 6 [default = USER];

    oneof info {
        // The properties describing the group.
        // This field is only set for groups where Type == GROUP.
        GroupInfo group = 2;

        // The properties describing the cluster.
        // This field is only set for groups where Type == CLUSTER.
        ClusterInfo cluster = 4;

        // The properties describing a temporary group.
        // This field is only set for groups where Type == TEMP_GROUP.
        TempGroupInfo temp_group = 5;
    }

    // The ID of the target that discovered the group.
    // This field is only set for groups where Origin == DISCOVERED.
    optional int64 target_id = 3;
}

// The customizeable properties of a group.
message GroupInfo {
    // The name of the group.
    optional string name = 1;

    // The type of entity in the group. A group can only have entities of
    // a single type.
    optional int32 entity_type = 2;

    // Groups may be either static or dynamic.
    // Whether it is static or dynamic determines when its members are resolved and updated.
    oneof selection_criteria {
        // A static group's members are fixed at the time they are created and that membership
        // may only be updated by an explicit call to update the group.
        StaticGroupMembers static_group_members = 3;

        // A wrapper layer to respent a list of search parameters
        SearchParametersCollection search_parameters_collection = 5;
    }
}

message TempGroupInfo {
    // The name of the group.
    optional string name = 1;

    // The type of entity in the group. A group can only have entities of
    // a single type.
    optional int32 entity_type = 2;

    // A static group's members are fixed at the time they are created and that membership
    // may only be updated by an explicit call to update the group.
    optional StaticGroupMembers members = 3;
}

// The properties of a cluster.
message ClusterInfo {

    enum Type {
        // A compute cluster is comprised of physical machines.
        COMPUTE = 1;
        // A storage cluster is comprised of storages.
        STORAGE = 2;
    }

    // The name of the cluster.
    optional string name = 1;

    optional Type cluster_type = 2;

    // The entities belonging to the cluster.
    optional StaticGroupMembers members = 3;

    // The template ID that the headroom plan will use.
    // If it is empty, the default plan will be used.
    optional int64 cluster_headroom_template_id = 4;
}


// Info for creating discovered policies.
// These are uploaded to group component together with discovered groups.
message DiscoveredPolicyInfo {

    // Name of constraint which was used for creating of Policy info
    required string policy_name = 1;

    // Name of the seller's group. It will be replaced to OID in group component.
    // When creating a discovered policy, a group of the same name must exist in the
    // StoreDiscoveredGroupsRequest or the discovered policy creation will fail.
    // Note: some policies (MustRun/MustNotRunTogether) only have a buyers group, so this field
    // will be empty in those policies
    optional string sellers_group_string_id = 2;

    // Name of the buyer's group. It will be replaced to OID in group component
    // When creating a discovered policy, a group of the same name must exist in the
    // StoreDiscoveredGroupsRequest or the discovered policy creation will fail.
    required string buyers_group_string_id = 3;

    // Constraint type of Policy. This value is obtained from field(which is enum) of ConstraintInfo
    // See the "ConstraintType" enum in the SDK CommonDTO file for more information.
    required int32 constraint_type = 4;
}

// Info for creating discovered setting policies.
// These are uploaded to group component together with discovered groups.
message DiscoveredSettingPolicyInfo {

    // Name of the setting policy.
    // The name should be unique.
    required string name = 1;

    // The settings that should be applied to the entities in the scope.
    //
    // These settings may only be associated with SettingSpecs that are of an EntitySettingSpec type.
    // It makes no sense to apply a GlobalSettingSpec to a SettingPolicy.
    //
    // The entity_type on the SettingSpecs associated with each of these Settings should match
    // the entity_type on the SettingPolicy.
    repeated .setting.Setting settings = 2;

    // The type of the entities to which the SettingPolicy applies.
    optional int32 entity_type = 3;

    // The names of the discovered groups that this setting policy will be applied to.
    // This will be convereted into a scope for the SettingPolicy to be created.
    // When creating a discovered setting policy, a group of the same name must exist in the
    // StoreDiscoveredGroupsRequest or the discovered setting policy creation will fail.
    repeated string discovered_group_names = 4;
}

message SearchParametersCollection {
    // A dynamic group's members are defined by a set of search criteria, and its members may
    // change as the entities in the topology change so that members enter and leave the group
    // based on their properties and relationships.
    repeated search.SearchParameters searchParameters = 1;
}

// Contains the membership for a static (fixed membership) group.
message StaticGroupMembers {
    // The OIDs of the members of the static group.
    repeated int64 static_member_oids = 1;
}

message UpdateGroupRequest {
    optional int64 id = 1;
    optional GroupInfo new_info = 2;
}

message UpdateGroupResponse {
    optional Group updated_group = 1;
}

message CreateGroupResponse {
    optional Group group = 1;
}

message GetGroupResponse {
    // If present, the group associated with the input ID.
    // If not present, the requested group does not exist.
    optional Group group = 1;
}

message GroupID {
    optional int64 id = 1;
}

message DeleteGroupResponse {
    optional bool deleted = 1;
}

// Specify the criteria for the groups to return.
// All filters/conditions are AND-ed together. If no filters/conditions
// are set, the call will return all groups.
message GetGroupsRequest {

    // Return only groups with these IDs.
    repeated int64 id = 1;

    // Return only groups where the name matches this filter.
    optional NameFilter name_filter = 2;

    // Return only groups with the specific origin.
    optional Group.Origin origin_filter = 3;

    // Return only groups of a particular type.
    //
    // Note: GetGroupsRequest does not
    // return temporary groups unless explicitly specified here.
    optional Group.Type type_filter = 4;

    // Apply this filter to any groups returned where Group.Type is CLUSTER.
    optional ClusterFilter cluster_filter = 5;

    // "Resolve" any Cluster Membership search filters contained in the resulting Groups.
    // Cluster Membership filters are expected to return the set of PM's belonging to all clusters
    // matching the filter criteria. So "resolving" a cluster membership means replacing the
    // ClusterMembershipFilter with an equivalent regex-based String matching filter that identifies
    // all of the PM entity id's belonging to the set of clusters matched by the cluster filter.
    //
    // Since the group component is the primary source of truth for cluster membership, this option
    // exists as a way to have the group component pre-calculate the cluster members and inject them
    // into the search parameters, avoiding further calls back to the group service that would have
    // requested these cluster members anyways.
    optional bool resolve_cluster_search_filters = 6 [default = false];
}

message GetMembersRequest {
    // The group ID to get members for.
    optional int64 id = 1;
}

message GetMembersResponse {
    repeated int64 member_id = 1;
}

message StoreDiscoveredGroupsRequest {
    // The ID of the target that discovered the groups.
    //
    // ALL old groups and clusters associated with this target ID
    // will either be updated (if they are re-discovered) or deleted .
    //
    // We use the (target_id, GroupInfo.name) tuple to determine equality
    // between discovered groups. So within a particular target, discovered GroupInfos
    // with the name of an existing discovered GroupInfo will update the group.
    optional int64 target_id = 1;

    // The most recent groups discovered by the target.
    repeated GroupInfo discovered_group = 2;

    // The most recent clusters discovered by the target.
    repeated ClusterInfo discovered_cluster = 3;

    // Discovered policies associated with this target.
    // The new set of policies will completely replace the old, even if the new set is empty.
    // Groups referenced in these discovered policies must be contained in the discovered_group field
    // in this message.
    repeated DiscoveredPolicyInfo discovered_policy_infos = 4;

    // Discovered setting policies associated with this target.
    // The new set of setting policies will completely replace the old, even if the new set is empty.
    // Groups referenced in these discovered setting policies must be contained in the discovered_group field
    // in this message.
    repeated DiscoveredSettingPolicyInfo discovered_setting_policies = 5;
}

message StoreDiscoveredGroupsResponse {}


// A filter on the name of a group (or cluster).
message NameFilter {
    // The regex to compare the name against.
    optional string name_regex = 1;

    // Whether to negate the result of the regex.
    optional bool negate_match = 2 [default = false];
}

// Specify the criteria for the clusters to return.
// All filters/conditions are AND-ed together. If no filters/conditions
// are set, the call will return all clusters.
message ClusterFilter {
    // If set, return only clusters of the provided type.
    optional ClusterInfo.Type type_filter = 1;
}

message CreateTempGroupRequest {
    optional TempGroupInfo group_info = 1;
}

message CreateTempGroupResponse {
    optional Group group = 1;
}

// Request for udpating the cluster headroom template ID of a cluster.
// The group_id must reference a group that is a cluster.
message UpdateClusterHeadroomTemplateRequest {
    optional int64 group_id = 1;
    optional int64 cluster_headroom_template_id = 2;
}

message UpdateClusterHeadroomTemplateResponse {
    // The group with with udpated cluster headroom template ID
    optional Group updated_group = 1;
}

// A service responsible for group operations.
service GroupService {
    // Create a group
    rpc CreateGroup(GroupInfo) returns (CreateGroupResponse);

    rpc CreateTempGroup(CreateTempGroupRequest) returns (CreateTempGroupResponse);

    // Get a group
    rpc GetGroup(GroupID) returns (GetGroupResponse);

    // Get all user groups
    rpc GetGroups(GetGroupsRequest) returns (stream Group);

    // Update a group
    //
    // Returns INVALID_ARGUMENT if the group is a discovered group (origin == DISCOVERED), since
    // users cannot modify discovered groups.
    rpc UpdateGroup(UpdateGroupRequest) returns (UpdateGroupResponse);

    // Update the cluster headroom template ID of a cluster.
    rpc UpdateClusterHeadroomTemplate(UpdateClusterHeadroomTemplateRequest)
    returns (UpdateClusterHeadroomTemplateResponse);

    // Delete a group
    //
    // Returns INVALID_ARGUMENT if the group is a discovered group.
    rpc DeleteGroup(GroupID) returns (DeleteGroupResponse);

    // Get the members of a group
    rpc GetMembers(GetMembersRequest) returns (GetMembersResponse);

}

// This service provides the interface to store all group and policy related information
// (i.e. groups, clusters, policies) discovered in the customer's topology.
// It should provide an atomic RPC to store updated information from a discovery.
//
// TODO (roman, July 27): If this becomes the single entry point for "uploading" discovered
// groups and policies, we probably need a better name.
service DiscoveredGroupService {
    // Stores groups and clusters discovered in the customer's topology.
    //
    // Only the Topology Processor should use this method to record the groups
    // that it discovered.
    //
    // Each call to this method is atomic - either all groups will be added, overriding
    // existing groups, or none of them will be.
    rpc StoreDiscoveredGroups(StoreDiscoveredGroupsRequest) returns (StoreDiscoveredGroupsResponse);
}
