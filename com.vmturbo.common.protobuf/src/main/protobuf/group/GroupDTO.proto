syntax = "proto2";
package group;

option java_package = "com.vmturbo.common.protobuf.group";

import "common/EnvironmentTypeEnum.proto";
import "search/Search.proto";
import "setting/Setting.proto";
import "tag/Tag.proto";
import "CommonDTO.proto";

// The information about a group in the system
// A group is a set of entities that can be treated collectively for the
// purpose of settings, policies, statistics, and other operations.
message Grouping {

    // The unique numeric identifier of the group.
    // This field will always be set.
    optional int64 id = 1;

    // This is a derived field based on the group definition which tell which types
    // are allowed in the group.  This enables policies to be set on heterogeneous
    // groups based on possible members.
    repeated MemberType expected_types = 2;

    // If true, this group can be looked up by the members
    optional bool supports_member_reverse_lookup = 3;

    // Describes how this group came to be in the system.
    optional Origin origin = 5;

    // This type encapsulates the group definition.  This is supplied by the client to create
    // or update the group
    optional GroupDefinition definition = 4;
}

// The group definition
message GroupDefinition {

    // The type of group such as CLUSTER, RESOURCE GROUP, ...
    optional common_dto.GroupDTO.GroupType type = 1 [default = REGULAR];

    // The user-friendly name of the group.
    optional string display_name = 2;

    // If true, this group will be deleted on restart or after a while
    optional bool is_temporary = 3 [default = false];

    // If true, this group will not be displayed to users.
    optional bool is_hidden = 4 [default = false];

    // If there is an entity in the topology that "owns" this group, this is the ID of that
    // entity. The main use case (Sept 5 2019) is Business Accounts that own Resource Groups.
    optional int64 owner = 6;

    // This is additional information that is used for optimizing information retrieval about group
    optional OptimizationMetadata optimization_metadata = 7;

    // The information that is used for selecting members of group
    oneof selection_criteria {
        // A static group's members are fixed at the time they are created and that membership
        // may only be updated by an explicit call to update the group.
        StaticMembers static_group_members = 8;
        // The criteria to select members when the group is dynamic group of groups

        GroupFilters group_filters = 9;

        // The criteria to select members when the group is dynamic group of entities
        EntityFilters entity_filters = 10;
    }

    // Tags on this group.
    // (roman Sept 5, 2019): Currently we only have discovered tags, but in the future we may
    // support user tags as well.
    optional .tag.Tags tags = 11;

    // Collection of group type's specific data.
    oneof group_data {
        EntityDefinitionData entity_definition_data = 12;
    }

    // Represent a list of group-specific search parameters, for groups that contain other groups.
    message GroupFilters {
        // a group is a member of this group if it satisfies any of the filters specified here (OR)
        repeated GroupFilter group_filter = 1;
    }

    // Represent a list of entity-specific search parameters, for groups that contain other entities.
    message EntityFilters {
        // an entity is a member of this group if it satisfies any of the filters specified here (OR)
        repeated EntityFilter entity_filter = 1;

        // A wrapper layer to represent a list of search parameters
        message EntityFilter {
            // the entity types that this filter apply to which means this filter can only be true for
            // entities with the type specified here.
            optional int32 entity_type = 1;
            optional SearchParametersCollection search_parameters_collection = 2;
        }
    }

    message OptimizationMetadata {
        //Is this group is all entities of specific type in a global scope
        optional bool is_global_scope = 1 [default = false];

        // The environment for which this group is group of all entities
        optional .common.EnvironmentType environment_type = 2;
    }
}

// This is used to store specific data for EntityDefinition group type.
message EntityDefinitionData {
    // Represents The type of entity that will be created based on an EntityDefinition group.
    optional common_dto.EntityDTO.EntityType defined_entity_type = 1;
}

// This encapsulates both the origin type and the information appropriate to that origin type
message Origin {
    enum Type {
        USER = 1;
        DISCOVERED = 2;
        SYSTEM = 3;
    }

    oneof creation_origin {
        User user = 1;
        Discovered discovered = 2;
        System system = 3;
    }

    // The group was created by a user via. an external API request.
    message User {
        // The username of the user who created this group.
        optional string username = 1;
    }

    // The group was discovered by the platform in one of the targets
    // added by the users.
    message Discovered {
        // The set of targets that discovered this group.
        repeated int64 discovering_target_id = 1;

        // The UUID of this group across all targets that discovered it.
        // This is sometimes required when referencing this group in actions that go to the probes.
        // This is also used to join together groups across targets, and to distinguish between
        // re-discovered groups and newly discovered groups.
        optional string source_identifier = 2;
    }

    // The group was created internally by the system.
    message System {
        // A description of the purpose of this system group - mainly for clarity/debugging/logging
        // purposes.
        optional string description = 1;
    }
}


message StaticMembers {
    message StaticMembersByType {
      // The type of the member.
      optional MemberType type = 1;

      // A non-repeating list of the ids of the members.
      repeated int64 members = 2;
    }

    // One entry for each group member type.
    // This allows easy access to members of specific types in multi-type groups.
    // There will only be one entry for every distinct "StaticMembersByType.type" value.
    repeated StaticMembersByType members_by_type = 1;
}

// The filter for a group. A group matches this filter if it has all properties (AND)
message GroupFilter {
    // Return only groups with these IDs.
    repeated int64 id = 1;

    // Group type to retrieve. Groups of another types (if specified) will be ignored
    optional common_dto.GroupDTO.GroupType group_type = 2;

    // Property filters to match group against. Currently (2019/4/29) used only for:
    // (a) display name (property of type string) regex matching and
    // (b) tags (property of type multimap).
    repeated .search.PropertyFilter property_filters = 3;

    // The groups with following direct member type
    repeated MemberType direct_member_types = 4;

    // The groups with following indirect member types
    // This is only can be different for nested groups
    repeated MemberType indirect_member_types = 5;

    // if true temporary groups will returned in addition to regular groups
    // if false only permanent groups will return
    optional bool include_temporary = 6 [default = false];

    // if true hidden groups will returned in addition to regular groups
    // if false only unhidden groups will return
    optional bool include_hidden = 7 [default = false];

    // Return only groups with the specific origin.
    optional OriginFilter origin_filter = 9;
}

message MemberType {
    oneof type {
        // The type of entity (matches TopologyEntityDTO.entity_type).
        int32 entity = 1;

        // The type of a group nested inside this group.
        common_dto.GroupDTO.GroupType group = 2;
    }
}

// This message keeps information for filtering a group based on the origin
message OriginFilter {
    // the origins to include. if empty all origins are included
    repeated Origin.Type origin = 1;
}

// Info for creating discovered policies.
// These are uploaded to group component together with discovered groups.
message DiscoveredPolicyInfo {
    // Name of constraint which was used for creating of Policy info
    required string policy_name = 1;

    // Name of the seller's group. It will be replaced to OID in group component.
    // When creating a discovered policy, a group of the same name must exist in the
    // StoreDiscoveredGroupsRequest or the discovered policy creation will fail.
    // Note: some policies (MustRun/MustNotRunTogether) only have a buyers group, so this field
    // will be empty in those policies
    optional string sellers_group_string_id = 2;

    // Name of the buyer's group. It will be replaced to OID in group component
    // When creating a discovered policy, a group of the same name must exist in the
    // StoreDiscoveredGroupsRequest or the discovered policy creation will fail.
    required string buyers_group_string_id = 3;

    // Constraint type of Policy. This value is obtained from field(which is enum) of ConstraintInfo
    // See the "ConstraintType" enum in the SDK CommonDTO file for more information.
    required int32 constraint_type = 4;
}

// Info for creating discovered setting policies.
// These are uploaded to group component together with discovered groups.
message DiscoveredSettingPolicyInfo {
    // Name of the setting policy.
    // The name should be unique.
    required string name = 1;

    // Display name of the setting policy
    optional string display_name = 5;

    // The settings that should be applied to the entities in the scope.
    //
    // These settings may only be associated with SettingSpecs that are of an EntitySettingSpec type.
    // It makes no sense to apply a GlobalSettingSpec to a SettingPolicy.
    //
    // The entity_type on the SettingSpecs associated with each of these Settings should match
    // the entity_type on the SettingPolicy.
    repeated .setting.Setting settings = 2;

    // The type of the entities to which the SettingPolicy applies.
    optional int32 entity_type = 3;

    // The names of the discovered groups that this setting policy will be applied to.
    // This will be converted into a scope for the SettingPolicy to be created.
    // When creating a discovered setting policy, a group of the same name must exist in the
    // StoreDiscoveredGroupsRequest or the discovered setting policy creation will fail.
    repeated string discovered_group_names = 4;
}

message SearchParametersCollection {
    // A dynamic group's members are defined by a set of search criteria, and its members may
    // change as the entities in the topology change so that members enter and leave the group
    // based on their properties and relationships.
    repeated search.SearchParameters searchParameters = 1;
}

// Contains the membership for a static (fixed membership) group.
message StaticGroupMembers {
    // The OIDs of the members of the static group.
    repeated int64 static_member_oids = 1;
}

message CreateGroupResponse {
    optional Grouping group = 1;
}

message UpdateGroupRequest {
    optional int64 id = 1;
    optional GroupDefinition new_definition = 2;
}

message UpdateGroupResponse {
    optional Grouping updated_group = 1;
}

message GetGroupResponse {
    // If present, the group associated with the input ID.
    // If not present, the requested group does not exist.
    optional Grouping group = 1;
}

message GroupID {
    optional int64 id = 1;
}

message DeleteGroupResponse {
    optional bool deleted = 1;
}

message GetGroupsRequest {
    optional GroupFilter group_filter = 1;
    optional bool replaceGroupPropertyWithGroupMembershipFilter = 2 [default = false];
    // list of scopes used to filter the groups, all returned groups will be within the given list
    // of scopes, in other words, all members of a group in the response will be within the range
    // of entities which are accessible through supply chain traversal starting from these scopes
    // for example: limit the Clusters to be in a DataCenter scope.
    repeated int64 scopes = 3;
}

message GetMembersRequest {
    // The group ID to get members for.
    repeated int64 id = 1;

    // If true, return an error if the ID does not refer to a group.
    // If false, the ID may or may not refer to a group.
    optional bool expect_present = 2 [default = true];

    // If true, the user's scoping restrictions will be enforced. This means a PERMISSION_DENIED
    // may be returned if not all of the group members are in the user's entity access scope. We do
    // not want scoping enforced when retrieving group members in the context of plan results, for
    // example, but we do want scoping enforced in most other cases.
    // Note that the default setting of "false" is not what we want long term, and is only set this
    // way because some of the plan requests don't have enough information in them to selectively
    // set this flag. This should be addressed as part of OM-44360.
    optional bool enforce_user_scope = 3 [default = false];

    // if true, then any groups contained within the requested group will be also expanded, and it's
    // members returned as part of the response. If true, no groups will appear in the result of
    // the call as they are substituted with their entity members.
    optional bool expand_nested_groups = 4 [default = false];
}

message GetMembersResponse {
    required int64 group_id = 1;
    repeated int64 member_id = 2;
}

// Information about the target. If the message for a target is not present, this means that
// target has been deleted.
message DiscoveredGroupsPoliciesSettings {

    // The ID of the target that discovered the groups/policies/settings.
    //
    // ALL old groups and clusters associated with this target ID
    // will either be updated (if they are re-discovered) or deleted .
    //
    // We use the (target_id, GroupInfo.name) tuple to determine equality
    // between discovered groups. So within a particular target, discovered GroupInfos
    // with the name of an existing discovered GroupInfo will update the group.
    optional int64 target_id = 1;

    // probe type of the target which discovered the groups/policies/settings
    optional string probe_type = 2;

    // The most recent discovered groups by probes and after interpretation in TP
    // The groups can be regular groups, clusters, or resource groups
    repeated UploadedGroup uploaded_groups = 3;

    // Discovered policies associated with this target.
    // The new set of policies will completely replace the old, even if the new set is empty.
    // Groups referenced in these discovered policies must be contained in the uploaded_groups
    // field in this message.
    repeated DiscoveredPolicyInfo discovered_policy_infos = 4;

    // Discovered setting policies associated with this target.
    // The new set of setting policies will completely replace the old, even if the new set is empty.
    // Groups referenced in these discovered setting policies must be contained in the
    // uploaded_groups field in this message.
    repeated DiscoveredSettingPolicyInfo discovered_setting_policies = 5;

    // Indicates that data is available from the target. If this field is set to false, it means
    // that target exists in the system, but it has not been discovered yet. As a result, groups,
    // policies and settings should not be cleared. If this field is set to true and no
    // uploaded groups, policies and settings then groups, policies and settings must be cleaned
    // up for this target.
    optional bool data_available = 6 [default = true];

    // the interpreted group to be uploaded to group component
    message UploadedGroup {
        // the source identifier coming from the probe
        optional string source_identifier = 1;
        // the definition of the group after interpretation in TP
        optional GroupDefinition definition = 2;
    }
}

message StoreDiscoveredGroupsPoliciesSettingsResponse {}

message CreateGroupRequest {
    optional GroupDefinition group_definition = 1;
    optional Origin origin = 2;
}

message GetGroupsForEntitiesRequest {
    // Entity OIDs to request groups for. If empty, an empty response will be returned.
    repeated int64 entity_id = 1;

    // Group types to retrieve. If empty all the group types will be queried.
    repeated common_dto.GroupDTO.GroupType group_type = 2;

    // Whether to load groups objects. If this parameter is set to false (default), then
    // GetGroupForEntityResponse.groups will not be filled.
    // Be aware that setting this flag to true will cause additional queries to be executed
    // at the service's side and additional data to be transferred over the network
    optional bool load_group_objects = 3 [default = false];
}

// A collection of groups
message Groupings {
    repeated int64 group_id = 1;
}

// Response of groups for entity request
message GetGroupsForEntitiesResponse {
    // Map of entity Oid -> group OIDs
    map<int64, Groupings> entity_group = 1;

    // A collection of groups that are mentioned in entity_group map. Only filled if
    // GetGroupForEntityRequest.load_group_objects is true
    repeated Grouping groups = 2;
}

// Request contains requested groups.
message GetTagsRequest {
    //If collection of requested groups is empty
    //then return tags for all existed groups in group component
    repeated int64 group_id = 1;
}

message GetTagsResponse {
    map<int64, .tag.Tags> tags = 1;
}

// Request owners for groups
message GetOwnersRequest {
    // The groupType to get owners for. If not specified, query will not distinguish between group types.
    optional common_dto.GroupDTO.GroupType group_type = 1;

    // The group IDs to get owners for
    repeated int64 group_id = 2;
}

// Response contains list of owners for owners request
message GetOwnersResponse {
    // Collection of owners ids
    repeated int64 owner_id = 1;
}

message CountGroupsResponse {
    optional int32 count = 1;
}

// A service responsible for group operations.
service GroupService {

    rpc CreateGroup(CreateGroupRequest) returns (CreateGroupResponse);

    // Get a group
    rpc GetGroup(GroupID) returns (GetGroupResponse);

    // Get groups based on the query
    rpc GetGroups(GetGroupsRequest) returns (stream Grouping);

    // Count groups matching a particular request.
    rpc CountGroups (GetGroupsRequest) returns (CountGroupsResponse);

    rpc UpdateGroup (UpdateGroupRequest) returns (UpdateGroupResponse);

    // Delete a group
    //
    // Returns INVALID_ARGUMENT if the group is a discovered group.
    rpc DeleteGroup (GroupID) returns (DeleteGroupResponse);

    // Get the members of a group
    rpc GetMembers (GetMembersRequest) returns (stream GetMembersResponse);

    // Get the group the entity belongs to.
    rpc GetGroupsForEntities (GetGroupsForEntitiesRequest) returns (GetGroupsForEntitiesResponse);

    // Stores groups, clusters, settings and policies discovered in the customer's topology.
    rpc StoreDiscoveredGroupsPoliciesSettings (stream DiscoveredGroupsPoliciesSettings) returns (StoreDiscoveredGroupsPoliciesSettingsResponse);

    // Returns tags of groups
    rpc GetTags (GetTagsRequest) returns (GetTagsResponse);

    // Returns owners of requested groups
    rpc GetOwnersOfGroups (GetOwnersRequest) returns (GetOwnersResponse);
}
