syntax = "proto2";
package group;

option java_package = "com.vmturbo.common.protobuf.group";

import "common/EnvironmentTypeEnum.proto";
import "search/Search.proto";
import "setting/Setting.proto";
import "tag/Tag.proto";
import "CommonDTO.proto";

// NB All messages in this set of declarations are serialized in rdbms.
// They are not modifiable, only extendable.

// A group is a set of entities that can be treated collectively for the
// purpose of settings, policies, statistics, and other operations.
message Group {
    // The origin represents how the group came to be in the system.
    enum Origin {
        // A user group was explicitly created by the user, and is owned by
        // the turbonomic system.
        USER = 1;

        // A discovered group exists in the user's topology, and was imported and interpreted
        // as part of a discovery.
        // Users cannot mutate or delete discovered groups.
        DISCOVERED = 2;
    }

    // The type of the group. Protobuf doesn't have inheritance, so we use a Type to
    // differentiate between sufficiently different kinds of groups.
    enum Type {
        // A group is a set of entities that can be treated collectively for the
        // purpose of settings, policies, statistics, and other operations.
        GROUP = 1;

        // A cluster is closely related to a group, and is most relevant when working with on-prem
        // environments - especially vSphere. It's essentially the unit of management for large
        // vSphere environments.
        //
        // Since clusters cannot be created by the user, all clusters have Origin == DISCOVERED.
        //
        // TODO (roman, July 27 2017): In the future we will likely want to rearchitect the model
        // away from "cluster" terminology to "management unit" terminology, where groups of entities
        // that act as the units of management for an environment - e.g. Clusters for vSphere, Business
        // Units for cloud environments - can be represented in a common fashion.
        CLUSTER = 2;

        // A temporary group is a GROUP that can only have static scope, is not persisted to
        // the database, and gets removed after a certain time.
        //
        // Temporary groups are not valid targets for policies or setting policies, and are
        // only used for query purposes.
        TEMP_GROUP = 3;

        // A nested group is a group that contains other groups. The most common use case for
        // nested groups is to create a group of several clusters (e.g. all clusters in a
        // datacenter).
        //
        // Temporary groups are not valid targets for policies or setting policies, and are only
        // used for query/visibility purposes.
        NESTED_GROUP = 4;
    }

    // The unique numeric identifier of the group.
    // This field will always be set.
    optional int64 id = 1;

    // The type of the group.
    // This field will always be set.
    optional Type type = 7 [default = GROUP];

    // The origin of this group.
    // This field will always be set.
    optional Origin origin = 6 [default = USER];

    oneof info {
        // The properties describing the group.
        // This field is only set for groups where Type == GROUP.
        GroupInfo group = 2;

        // The properties describing the cluster.
        // This field is only set for groups where Type == CLUSTER.
        ClusterInfo cluster = 4;

        // The properties describing a temporary group.
        // This field is only set for groups where Type == TEMP_GROUP.
        TempGroupInfo temp_group = 5;

        // The properties describing the nested group.
        // This field is only set for groups where Type == NESTED_GROUP.
        NestedGroupInfo nested_group = 10;
    }

    // The ID of the target that discovered the group.
    // This field is only set for groups where Origin == DISCOVERED.
    optional int64 target_id = 3;
}

// The customizeable properties of a group.
message GroupInfo {
    // The name of the group.
    optional string name = 1;

    // The type of entity in the group. A group can only have entities of
    // a single type.
    optional int32 entity_type = 2;

    // Groups may be either static or dynamic.
    // Whether it is static or dynamic determines when its members are resolved and updated.
    oneof selection_criteria {
        // A static group's members are fixed at the time they are created and that membership
        // may only be updated by an explicit call to update the group.
        StaticGroupMembers static_group_members = 3;

        // A wrapper layer to respent a list of search parameters
        SearchParametersCollection search_parameters_collection = 5;
    }

    // Is the group a hidden group
    // We use this field for the groups automatically created for merge data centers policy, since
    // data center is not a group, but we need the groups for the merge operation.
    optional bool is_hidden = 6 [default = false];

    // User friendly name. Typically used for discovered groups.
    optional string display_name = 7;

    // Tags. Used for discovered groups.
    optional .tag.Tags tags = 8;
}

message TempGroupInfo {
    // The name of the group.
    optional string name = 1;

    // The type of entity in the group. A group can only have entities of
    // a single type.
    optional int32 entity_type = 2;

    // A static group's members are fixed at the time they are created and that membership
    // may only be updated by an explicit call to update the group.
    optional StaticGroupMembers members = 3;

    // If true, means the temp group contains all entities with same entity type in global scope.
    // This field will speed up stats query for global scope.
    optional bool is_global_scope_group = 4;

    // If set, the environment type of entities in the group.
    // This field should be combined with entity_type and is_global_scope_group to optimize
    // stats queries for all entity types in an environment when navigating the supply chain.
    optional .common.EnvironmentType environment_type = 5;
}

// The properties of a cluster.
message ClusterInfo {

    enum Type {
        // A compute cluster is comprised of physical machines.
        COMPUTE = 1;
        // A storage cluster is comprised of storages.
        STORAGE = 2;
        // A compute virtual machine cluster is comprised of virtual machines.
        COMPUTE_VIRTUAL_MACHINE = 3;
    }

    // The name of the cluster.
    optional string name = 1;

    optional Type cluster_type = 2;

    // The entities belonging to the cluster.
    optional StaticGroupMembers members = 3;

    // The template ID that the headroom plan will use.
    // If it is empty, the default plan will be used.
    optional int64 cluster_headroom_template_id = 4;

    // User friendly name. Typically used for discovered clusters.
    optional string display_name = 7;

    // Tags. Used for discovered clusters.
    optional .tag.Tags tags = 8;
}

// The properties of a nested group.
message NestedGroupInfo {
    // The name of the group.
    optional string name = 1;

    // The type of nested group. All members of the group will be of the same type.
    oneof type {
        // If set, this is a group of clusters of this type.
        ClusterInfo.Type cluster = 2;

        // In the future, we may want to support nested groups of other nested groups (e.g. when
        // parsing VC folders). However, for now we don't do this - and will try to avoid it for
        // as long as possible!
    }

    // Describes how groups are selected to be in the group.
    // The selection criteria only applies to groups that match the type (defined above).
    // For example, if the type is compute cluster, we will only consider compute clusters
    // as candidates for selection.
    oneof selection_criteria {
        // If set, this is a static nested group. The members are configured at creation time
        // and do not change.
        StaticGroupMembers static_group_members = 10;

        // If set, this is a dynamic nested group. The members will be the subset of groups in
        // the system that match the property filters.
        GroupPropertyFilterList property_filter_list = 11;
    }
}

// A property filter list that can be used to dynamically select a set of groups.
// This is loosely equivalent to "SearchParameters" in Search.proto, but without
// traversal filters.<p/>
// Currently (2019/4/29), there are exactly two properties that can be used to
// filter groups: display names and tags. For display names, we use a regex string
// filter. For tags, we use a MapFilter, as is the case for service entity tags.
// Other property filter types, e.g., numeric filters, list filters, and object
// filters are not used.
message GroupPropertyFilterList {
    // This message type is included for backward compatibility with 7.16 and
    // earlier versions.  It should not be used.
    message GroupPropertyFilter {
        oneof property_type {
            .search.PropertyFilter.StringFilter __deprecated__name_filter = 1 [deprecated=true];
        }
    }

    // This field is included for backward compatibility with 7.16 and
    // earlier versions.  It should not be used.
    repeated GroupPropertyFilter __deprecated__property_filters_old = 1 [deprecated=true];

    // Property filters to match group against. Currently (2019/4/29) used only for:
    // (a) display name (property of type string) regex matching and
    // (b) tags (property of type multimap).
    repeated .search.PropertyFilter property_filters = 2;
}

// The information about a group in the system
// A group is a set of entities that can be treated collectively for the
// purpose of settings, policies, statistics, and other operations.
message Grouping {

    // The unique numeric identifier of the group.
    // This field will always be set.
    optional int64 id = 1;

    // This is a derived field based on the group definition which tell which types
    // are allowed in the group.  This enables policies to be set on heterogeneous
    // groups based on possible members.
    repeated MemberType expected_types = 2;

    // If true, this group can be looked up by the members
    optional bool supports_member_reverse_lookup = 3;

    // Describes how this group came to be in the system.
    optional Origin origin = 5;

    // This type encapsulates the group definition.  This is supplied by the client to create
    // or update the group
    optional GroupDefinition definition = 4;
}

// The group definition
message GroupDefinition {

    // The type of group such as CLUSTER, RESOURCE GROUP, ...
    optional common_dto.GroupDTO.GroupType type = 1 [default = REGULAR];

    // The user-friendly name of the group.
    optional string display_name = 2;

    // If true, this group will be deleted on restart or after a while
    optional bool is_temporary = 3 [default = false];

    // If true, this group will not be displayed to users.
    optional bool is_hidden = 4 [default = false];

    // If there is an entity in the topology that "owns" this group, this is the ID of that
    // entity. The main use case (Sept 5 2019) is Business Accounts that own Resource Groups.
    optional int64 owner = 6;

    // This is additional information that is used for optimizing information retrieval about group
    optional OptimizationMetadata optimization_metadata = 7;

    // The information that is used for selecting members of group
    oneof selection_criteria {
        // A static group's members are fixed at the time they are created and that membership
        // may only be updated by an explicit call to update the group.
        StaticMembers static_group_members = 8;
        // The criteria to select members when the group is dynamic group of groups

        GroupFilters group_filters = 9;

        // The criteria to select members when the group is dynamic group of entities
        EntityFilters entity_filters = 10;
    }

    // Tags on this group.
    // (roman Sept 5, 2019): Currently we only have discovered tags, but in the future we may
    // support user tags as well.
    optional .tag.Tags tags = 11;

    // Represent a list of group-specific search parameters, for groups that contain other groups.
    message GroupFilters {
        // a group is a member of this group if it satisfies any of the filters specified here (OR)
        repeated GroupFilter group_filter = 1;
    }

    // Represent a list of entity-specific search parameters, for groups that contain other entities.
    message EntityFilters {
        // an entity is a member of this group if it satisfies any of the filters specified here (OR)
        repeated EntityFilter entity_filter = 1;

        // A wrapper layer to represent a list of search parameters
        message EntityFilter {
            // the entity types that this filter apply to which means this filter can only be true for
            // entities with the type specified here.
            optional int32 entity_type = 1;
            optional SearchParametersCollection search_parameters_collection = 2;
        }
    }

    message OptimizationMetadata {
        //Is this group is all entities of specific type in a global scope
        optional bool is_global_scope = 1 [default = false];

        // The environment for which this group is group of all entities
        optional .common.EnvironmentType environment_type = 2;
    }

}

// This encapsulates both the origin type and the information appropriate to that origin type
message Origin {
    enum Type {
        USER = 1;
        DISCOVERED = 2;
        SYSTEM = 3;
    }

    oneof creation_origin {
        User user = 1;
        Discovered discovered = 2;
        System system = 3;
    }

    // The group was created by a user via. an external API request.
    message User {
        // The username of the user who created this group.
        optional string username = 1;
    }

    // The group was discovered by the platform in one of the targets
    // added by the users.
    message Discovered {
        // The set of targets that discovered this group.
        repeated int64 discovering_target_id = 1;

        // The UUID of this group across all targets that discovered it.
        // This is sometimes required when referencing this group in actions that go to the probes.
        // This is also used to join together groups across targets, and to distinguish between
        // re-discovered groups and newly discovered groups.
        optional string source_identifier = 2;
    }

    // The group was created internally by the system.
    message System {
        // A description of the purpose of this system group - mainly for clarity/debugging/logging
        // purposes.
        optional string description = 1;
    }
}


message StaticMembers {
    message StaticMembersByType {
      // The type of the member.
      optional MemberType type = 1;

      // A non-repeating list of the ids of the members.
      repeated int64 members = 2;
    }

    // One entry for each group member type.
    // This allows easy access to members of specific types in multi-type groups.
    // There will only be one entry for every distinct "StaticMembersByType.type" value.
    repeated StaticMembersByType members_by_type = 1;
}

// The filter for a group. A group matches this filter if it has all properties (AND)
message GroupFilter {
    // Return only groups with these IDs.
    repeated int64 id = 1;

    // Group type to retrieve. Groups of another types (if specified) will be ignored
    optional common_dto.GroupDTO.GroupType group_type = 2;

    // Property filters to match group against. Currently (2019/4/29) used only for:
    // (a) display name (property of type string) regex matching and
    // (b) tags (property of type multimap).
    repeated .search.PropertyFilter property_filters = 3;

    // The groups with following direct member type
    repeated MemberType direct_member_types = 4;

    // The groups with following indirect member types
    // This is only can be different for nested groups
    repeated MemberType indirect_member_types = 5;

    // if true temporary groups will returned in addition to regular groups
    // if false only permanent groups will return
    optional bool include_temporary = 6 [default = false];

    // if true hidden groups will returned in addition to regular groups
    // if false only unhidden groups will return
    optional bool include_hidden = 7 [default = false];

    // Return only groups with the specific origin.
    optional OriginFilter origin_filter = 9;
}

message MemberType {
    oneof type {
        // The type of entity (matches TopologyEntityDTO.entity_type).
        int32 entity = 1;

        // The type of a group nested inside this group.
        common_dto.GroupDTO.GroupType group = 2;
    }
}

// This message keeps information for filtering a group based on the origin
message OriginFilter {
    // the origins to include. if empty all origins are included
    repeated Origin.Type origin = 1;
}

// Info for creating discovered policies.
// These are uploaded to group component together with discovered groups.
message DiscoveredPolicyInfo {
    // Name of constraint which was used for creating of Policy info
    required string policy_name = 1;

    // Name of the seller's group. It will be replaced to OID in group component.
    // When creating a discovered policy, a group of the same name must exist in the
    // StoreDiscoveredGroupsRequest or the discovered policy creation will fail.
    // Note: some policies (MustRun/MustNotRunTogether) only have a buyers group, so this field
    // will be empty in those policies
    optional string sellers_group_string_id = 2;

    // Name of the buyer's group. It will be replaced to OID in group component
    // When creating a discovered policy, a group of the same name must exist in the
    // StoreDiscoveredGroupsRequest or the discovered policy creation will fail.
    required string buyers_group_string_id = 3;

    // Constraint type of Policy. This value is obtained from field(which is enum) of ConstraintInfo
    // See the "ConstraintType" enum in the SDK CommonDTO file for more information.
    required int32 constraint_type = 4;
}

// Info for creating discovered setting policies.
// These are uploaded to group component together with discovered groups.
message DiscoveredSettingPolicyInfo {
    // Name of the setting policy.
    // The name should be unique.
    required string name = 1;

    // Display name of the setting policy
    optional string display_name = 5;

    // The settings that should be applied to the entities in the scope.
    //
    // These settings may only be associated with SettingSpecs that are of an EntitySettingSpec type.
    // It makes no sense to apply a GlobalSettingSpec to a SettingPolicy.
    //
    // The entity_type on the SettingSpecs associated with each of these Settings should match
    // the entity_type on the SettingPolicy.
    repeated .setting.Setting settings = 2;

    // The type of the entities to which the SettingPolicy applies.
    optional int32 entity_type = 3;

    // The names of the discovered groups that this setting policy will be applied to.
    // This will be converted into a scope for the SettingPolicy to be created.
    // When creating a discovered setting policy, a group of the same name must exist in the
    // StoreDiscoveredGroupsRequest or the discovered setting policy creation will fail.
    repeated string discovered_group_names = 4;
}

message SearchParametersCollection {
    // A dynamic group's members are defined by a set of search criteria, and its members may
    // change as the entities in the topology change so that members enter and leave the group
    // based on their properties and relationships.
    repeated search.SearchParameters searchParameters = 1;
}

// Contains the membership for a static (fixed membership) group.
message StaticGroupMembers {
    // The OIDs of the members of the static group.
    repeated int64 static_member_oids = 1;
}

message CreateGroupResponse {
    optional Grouping group = 1;
}

message UpdateGroupRequest {
    optional int64 id = 1;
    optional GroupDefinition new_definition = 2;
}

message UpdateGroupResponse {
    optional Grouping updated_group = 1;
}

message GetGroupResponse {
    // If present, the group associated with the input ID.
    // If not present, the requested group does not exist.
    optional Grouping group = 1;
}

message GroupID {
    optional int64 id = 1;
}

message DeleteGroupResponse {
    optional bool deleted = 1;
}

message GetGroupsRequest {
    optional GroupFilter group_filter = 1;
    optional bool replaceGroupPropertyWithGroupMembershipFilter = 2 [default = false];
}

message GetMembersRequest {
    // The group ID to get members for.
    optional int64 id = 1;

    // If true, return an error if the ID does not refer to a group.
    // If false, the ID may or may not refer to a group.
    optional bool expect_present = 2 [default = true];

    // If true, the user's scoping restrictions will be enforced. This means a PERMISSION_DENIED
    // may be returned if not all of the group members are in the user's entity access scope. We do
    // not want scoping enforced when retrieving group members in the context of plan results, for
    // example, but we do want scoping enforced in most other cases.
    // Note that the default setting of "false" is not what we want long term, and is only set this
    // way because some of the plan requests don't have enough information in them to selectively
    // set this flag. This should be addressed as part of OM-44360.
    optional bool enforce_user_scope = 3 [default = false];

    // if true, then any groups contained within the requested group will be also expanded, and it's
    // members returned as part of the response.
    optional bool expand_nested_groups = 4 [default = false];
}

message GetMembersResponse {
    optional Members members = 1;

    message Members {
        repeated int64 ids = 1;
    }
}

message DiscoveredGroupsPoliciesSettings {

    // The ID of the target that discovered the groups/policies/settings.
    //
    // ALL old groups and clusters associated with this target ID
    // will either be updated (if they are re-discovered) or deleted .
    //
    // We use the (target_id, GroupInfo.name) tuple to determine equality
    // between discovered groups. So within a particular target, discovered GroupInfos
    // with the name of an existing discovered GroupInfo will update the group.
    optional int64 target_id = 1;

    // probe type of the target which discovered the groups/policies/settings
    optional string probe_type = 2;

    // The most recent discovered groups by probes and after interpretation in TP
    // The groups can be regular groups, clusters, or resource groups
    repeated UploadedGroup uploaded_groups = 3;

    // Discovered policies associated with this target.
    // The new set of policies will completely replace the old, even if the new set is empty.
    // Groups referenced in these discovered policies must be contained in the uploaded_groups
    // field in this message.
    repeated DiscoveredPolicyInfo discovered_policy_infos = 4;

    // Discovered setting policies associated with this target.
    // The new set of setting policies will completely replace the old, even if the new set is empty.
    // Groups referenced in these discovered setting policies must be contained in the
    // uploaded_groups field in this message.
    repeated DiscoveredSettingPolicyInfo discovered_setting_policies = 5;

    // the interpreted group to be uploaded to group component
    message UploadedGroup {
        // the source identifier coming from the probe
        optional string source_identifier = 1;
        // the definition of the group after interpretation in TP
        optional GroupDefinition definition = 2;
    }
}

message StoreDiscoveredGroupsPoliciesSettingsResponse {}

// Specify the criteria for the clusters to return.
// All filters/conditions are AND-ed together. If no filters/conditions
// are set, the call will return all clusters.
message ClusterFilter {
    // If set, return only clusters of the provided type.
    optional ClusterInfo.Type type_filter = 1;
}

message CreateGroupRequest {
    optional GroupDefinition group_definition = 1;
    optional Origin origin = 2;
}

// Request for udpating the cluster headroom template ID of a cluster.
// The group_id must reference a group that is a cluster.
message UpdateClusterHeadroomTemplateRequest {
    optional int64 group_id = 1;
    optional int64 cluster_headroom_template_id = 2;
}

message UpdateClusterHeadroomTemplateResponse {
    // The group with with udpated cluster headroom template ID
    optional Group updated_group = 1;
}

message GetClusterForEntityRequest {
    optional int64 entity_id = 1;
}

message GetClusterForEntityResponse {
    optional Group cluster = 1;
}

message GetGroupForEntityRequest {
    optional int64 entity_id = 1;
}

message GetGroupForEntityResponse {
    repeated Grouping group = 1;
}

message GetTagsRequest {}

message GetTagsResponse {
    optional .tag.Tags tags = 1;
}

message CountGroupsResponse {
    optional int32 count = 1;
}

// A service responsible for group operations.
service GroupService {

    rpc CreateGroup(CreateGroupRequest) returns (CreateGroupResponse);

    // Get a group
    rpc GetGroup(GroupID) returns (GetGroupResponse);

    // Get groups based on the query
    rpc GetGroups(GetGroupsRequest) returns (stream Grouping);

    // Count groups matching a particular request.
    rpc CountGroups(GetGroupsRequest) returns (CountGroupsResponse);

    rpc UpdateGroup(UpdateGroupRequest) returns (UpdateGroupResponse);

    // Delete a group
    //
    // Returns INVALID_ARGUMENT if the group is a discovered group.
    rpc DeleteGroup(GroupID) returns (DeleteGroupResponse);

    // Get the members of a group
    rpc GetMembers(GetMembersRequest) returns (GetMembersResponse);

    // Get the group the entity belongs to.
    rpc GetGroupForEntity(GetGroupForEntityRequest) returns (GetGroupForEntityResponse);

    // Stores groups, clusters, settings and policies discovered in the customer's topology.
    rpc StoreDiscoveredGroupsPoliciesSettings(stream DiscoveredGroupsPoliciesSettings) returns (StoreDiscoveredGroupsPoliciesSettingsResponse);

    // Returns all tags of groups
    rpc GetTags(GetTagsRequest) returns (GetTagsResponse);
}

