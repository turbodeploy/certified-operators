syntax = "proto2";
package group;

option java_package = "com.vmturbo.common.protobuf.group";

import "common/EnvironmentTypeEnum.proto";
import "search/Search.proto";
import "setting/Setting.proto";
import "tag/Tag.proto";

// NB All messages in this set of declarations are serialized in rdbms.
// They are not modifiable, only extendable.

// A group is a set of entities that can be treated collectively for the
// purpose of settings, policies, statistics, and other operations.
message Group {
    // The origin represents how the group came to be in the system.
    enum Origin {
        // A user group was explicitly created by the user, and is owned by
        // the turbonomic system.
        USER = 1;

        // A discovered group exists in the user's topology, and was imported and interpreted
        // as part of a discovery.
        // Users cannot mutate or delete discovered groups.
        DISCOVERED = 2;
    }

    // The type of the group. Protobuf doesn't have inheritance, so we use a Type to
    // differentiate between sufficiently different kinds of groups.
    enum Type {
        // A group is a set of entities that can be treated collectively for the
        // purpose of settings, policies, statistics, and other operations.
        GROUP = 1;

        // A cluster is closely related to a group, and is most relevant when working with on-prem
        // environments - especially vSphere. It's essentially the unit of management for large
        // vSphere environments.
        //
        // Since clusters cannot be created by the user, all clusters have Origin == DISCOVERED.
        //
        // TODO (roman, July 27 2017): In the future we will likely want to rearchitect the model
        // away from "cluster" terminology to "management unit" terminology, where groups of entities
        // that act as the units of management for an environment - e.g. Clusters for vSphere, Business
        // Units for cloud environments - can be represented in a common fashion.
        CLUSTER = 2;

        // A temporary group is a GROUP that can only have static scope, is not persisted to
        // the database, and gets removed after a certain time.
        //
        // Temporary groups are not valid targets for policies or setting policies, and are
        // only used for query purposes.
        TEMP_GROUP = 3;

        // A nested group is a group that contains other groups. The most common use case for
        // nested groups is to create a group of several clusters (e.g. all clusters in a
        // datacenter).
        //
        // Temporary groups are not valid targets for policies or setting policies, and are only
        // used for query/visibility purposes.
        NESTED_GROUP = 4;
    }

    // The unique numeric identifier of the group.
    // This field will always be set.
    optional int64 id = 1;

    // The type of the group.
    // This field will always be set.
    optional Type type = 7 [default = GROUP];

    // The origin of this group.
    // This field will always be set.
    optional Origin origin = 6 [default = USER];

    oneof info {
        // The properties describing the group.
        // This field is only set for groups where Type == GROUP.
        GroupInfo group = 2;

        // The properties describing the cluster.
        // This field is only set for groups where Type == CLUSTER.
        ClusterInfo cluster = 4;

        // The properties describing a temporary group.
        // This field is only set for groups where Type == TEMP_GROUP.
        TempGroupInfo temp_group = 5;

        // The properties describing the nested group.
        // This field is only set for groups where Type == NESTED_GROUP.
        NestedGroupInfo nested_group = 10;
    }

    // The ID of the target that discovered the group.
    // This field is only set for groups where Origin == DISCOVERED.
    optional int64 target_id = 3;
}

// The customizeable properties of a group.
message GroupInfo {
    // The name of the group.
    optional string name = 1;

    // The type of entity in the group. A group can only have entities of
    // a single type.
    optional int32 entity_type = 2;

    // Groups may be either static or dynamic.
    // Whether it is static or dynamic determines when its members are resolved and updated.
    oneof selection_criteria {
        // A static group's members are fixed at the time they are created and that membership
        // may only be updated by an explicit call to update the group.
        StaticGroupMembers static_group_members = 3;

        // A wrapper layer to respent a list of search parameters
        SearchParametersCollection search_parameters_collection = 5;
    }

    // Is the group a hidden group
    // We use this field for the groups automatically created for merge data centers policy, since
    // data center is not a group, but we need the groups for the merge operation.
    optional bool is_hidden = 6 [default = false];

    // User friendly name. Typically used for discovered groups.
    optional string display_name = 7;

    // Tags. Used for discovered groups.
    optional .tag.Tags tags = 8;
}

message TempGroupInfo {
    // The name of the group.
    optional string name = 1;

    // The type of entity in the group. A group can only have entities of
    // a single type.
    optional int32 entity_type = 2;

    // A static group's members are fixed at the time they are created and that membership
    // may only be updated by an explicit call to update the group.
    optional StaticGroupMembers members = 3;

    // If true, means the temp group contains all entities with same entity type in global scope.
    // This field will speed up stats query for global scope.
    optional bool is_global_scope_group = 4;

    // If set, the environment type of entities in the group.
    // This field should be combined with entity_type and is_global_scope_group to optimize
    // stats queries for all entity types in an environment when navigating the supply chain.
    optional .common.EnvironmentType environment_type = 5;
}

// The properties of a cluster.
message ClusterInfo {

    enum Type {
        // A compute cluster is comprised of physical machines.
        COMPUTE = 1;
        // A storage cluster is comprised of storages.
        STORAGE = 2;
    }

    // The name of the cluster.
    optional string name = 1;

    optional Type cluster_type = 2;

    // The entities belonging to the cluster.
    optional StaticGroupMembers members = 3;

    // The template ID that the headroom plan will use.
    // If it is empty, the default plan will be used.
    optional int64 cluster_headroom_template_id = 4;

    // User friendly name. Typically used for discovered clusters.
    optional string display_name = 7;

    // Tags. Used for discovered clusters.
    optional .tag.Tags tags = 8;
}

// The properties of a nested group.
message NestedGroupInfo {
    // The name of the group.
    optional string name = 1;

    // The type of nested group. All members of the group will be of the same type.
    oneof type {
        // If set, this is a group of clusters of this type.
        ClusterInfo.Type cluster = 2;

        // In the future, we may want to support nested groups of other nested groups (e.g. when
        // parsing VC folders). However, for now we don't do this - and will try to avoid it for
        // as long as possible!
    }

    // Describes how groups are selected to be in the group.
    // The selection criteria only applies to groups that match the type (defined above).
    // For example, if the type is compute cluster, we will only consider compute clusters
    // as candidates for selection.
    oneof selection_criteria {
        // If set, this is a static nested group. The members are configured at creation time
        // and do not change.
        StaticGroupMembers static_group_members = 10;

        // If set, this is a dynamic nested group. The members will be the subset of groups in
        // the system that match the property filters.
        GroupPropertyFilterList property_filter_list = 11;
    }
}

// A property filter list that can be used to dynamically select a set of groups.
// This is loosely equivalent to "SearchParameters" in Search.proto, but without
// traversal filters.<p/>
// Currently (2019/4/29), there are exactly two properties that can be used to
// filter groups: display names and tags. For display names, we use a regex string
// filter. For tags, we use a MapFilter, as is the case for service entity tags.
// Other property filter types, e.g., numeric filters, list filters, and object
// filters are not used.
message GroupPropertyFilterList {
    // Property filters to match group against. Currently (2019/4/29) used only for:
    // (a) display name (property of type string) regex matching and
    // (b) tags (property of type multimap).
    repeated .search.PropertyFilter property_filters = 1;
}


// Info for creating discovered policies.
// These are uploaded to group component together with discovered groups.
message DiscoveredPolicyInfo {

    // Name of constraint which was used for creating of Policy info
    required string policy_name = 1;

    // Name of the seller's group. It will be replaced to OID in group component.
    // When creating a discovered policy, a group of the same name must exist in the
    // StoreDiscoveredGroupsRequest or the discovered policy creation will fail.
    // Note: some policies (MustRun/MustNotRunTogether) only have a buyers group, so this field
    // will be empty in those policies
    optional string sellers_group_string_id = 2;

    // Name of the buyer's group. It will be replaced to OID in group component
    // When creating a discovered policy, a group of the same name must exist in the
    // StoreDiscoveredGroupsRequest or the discovered policy creation will fail.
    required string buyers_group_string_id = 3;

    // Constraint type of Policy. This value is obtained from field(which is enum) of ConstraintInfo
    // See the "ConstraintType" enum in the SDK CommonDTO file for more information.
    required int32 constraint_type = 4;
}

// Info for creating discovered setting policies.
// These are uploaded to group component together with discovered groups.
message DiscoveredSettingPolicyInfo {

    // Name of the setting policy.
    // The name should be unique.
    required string name = 1;

    // The settings that should be applied to the entities in the scope.
    //
    // These settings may only be associated with SettingSpecs that are of an EntitySettingSpec type.
    // It makes no sense to apply a GlobalSettingSpec to a SettingPolicy.
    //
    // The entity_type on the SettingSpecs associated with each of these Settings should match
    // the entity_type on the SettingPolicy.
    repeated .setting.Setting settings = 2;

    // The type of the entities to which the SettingPolicy applies.
    optional int32 entity_type = 3;

    // The names of the discovered groups that this setting policy will be applied to.
    // This will be converted into a scope for the SettingPolicy to be created.
    // When creating a discovered setting policy, a group of the same name must exist in the
    // StoreDiscoveredGroupsRequest or the discovered setting policy creation will fail.
    repeated string discovered_group_names = 4;
}

message SearchParametersCollection {
    // A dynamic group's members are defined by a set of search criteria, and its members may
    // change as the entities in the topology change so that members enter and leave the group
    // based on their properties and relationships.
    repeated search.SearchParameters searchParameters = 1;
}

// Contains the membership for a static (fixed membership) group.
message StaticGroupMembers {
    // The OIDs of the members of the static group.
    repeated int64 static_member_oids = 1;
}

message UpdateGroupRequest {
    optional int64 id = 1;
    optional GroupInfo new_info = 2;
}

message UpdateGroupResponse {
    optional Group updated_group = 1;
}

message CreateGroupResponse {
    optional Group group = 1;
}

message GetGroupResponse {
    // If present, the group associated with the input ID.
    // If not present, the requested group does not exist.
    optional Group group = 1;
}

message GroupID {
    optional int64 id = 1;
}

message DeleteGroupResponse {
    optional bool deleted = 1;
}

// Specify the criteria for the groups to return.
// All filters/conditions are AND-ed together. If no filters/conditions
// are set, the call will return all groups.
message GetGroupsRequest {

    // Return only groups with these IDs.
    repeated int64 id = 1;

    // Return only groups where these filters are matched
    optional GroupPropertyFilterList property_filters = 2;

    // Return only groups with the specific origin.
    optional Group.Origin origin_filter = 3;

    // Return only groups of particular types.
    //
    // Note: GetGroupsRequest does not
    // return temporary groups unless explicitly specified here.
    repeated Group.Type type_filter = 4;

    // Apply this filter to any groups returned where Group.Type is CLUSTER.
    optional ClusterFilter cluster_filter = 5;

    // "Resolve" any Cluster Membership search filters contained in the resulting Groups.
    // Cluster Membership filters are expected to return the set of PM's belonging to all clusters
    // matching the filter criteria. So "resolving" a cluster membership means replacing the
    // ClusterMembershipFilter with an equivalent regex-based String matching filter that identifies
    // all of the PM entity id's belonging to the set of clusters matched by the cluster filter.
    //
    // Since the group component is the primary source of truth for cluster membership, this option
    // exists as a way to have the group component pre-calculate the cluster members and inject them
    // into the search parameters, avoiding further calls back to the group service that would have
    // requested these cluster members anyways.
    optional bool resolve_cluster_search_filters = 6 [default = false];
}

message GetMembersRequest {
    // The group ID to get members for.
    optional int64 id = 1;

    // If true, return an error if the ID does not refer to a group.
    // If false, the ID may or may not refer to a group.
    optional bool expect_present = 2 [default = true];

    // If true, the user's scoping restrictions will be enforced. This means a PERMISSION_DENIED
    // may be returned if not all of the group members are in the user's entity access scope. We do
    // not want scoping enforced when retrieving group members in the context of plan results, for
    // example, but we do want scoping enforced in most other cases.
    // Note that the default setting of "false" is not what we want long term, and is only set this
    // way because some of the plan requests don't have enough information in them to selectively
    // set this flag. This should be addressed as part of OM-44360.
    optional bool enforce_user_scope = 3 [default = false];
}

message GetMembersResponse {
    optional Members members = 1;

    message Members {
        repeated int64 ids = 1;
    }
}

message DiscoveredGroupsPoliciesSettings {

    // The ID of the target that discovered the groups/policies/settings.
    //
    // ALL old groups and clusters associated with this target ID
    // will either be updated (if they are re-discovered) or deleted .
    //
    // We use the (target_id, GroupInfo.name) tuple to determine equality
    // between discovered groups. So within a particular target, discovered GroupInfos
    // with the name of an existing discovered GroupInfo will update the group.
    optional int64 target_id = 1;

    // The most recent groups discovered by the target.
    repeated GroupInfo discovered_group = 2;

    // The most recent clusters discovered by the target.
    repeated ClusterInfo discovered_cluster = 3;

    // Discovered policies associated with this target.
    // The new set of policies will completely replace the old, even if the new set is empty.
    // Groups referenced in these discovered policies must be contained in the discovered_group field
    // in this message.
    repeated DiscoveredPolicyInfo discovered_policy_infos = 4;

    // Discovered setting policies associated with this target.
    // The new set of setting policies will completely replace the old, even if the new set is empty.
    // Groups referenced in these discovered setting policies must be contained in the discovered_group field
    // in this message.
    repeated DiscoveredSettingPolicyInfo discovered_setting_policies = 5;
}

message StoreDiscoveredGroupsPoliciesSettingsResponse {}

// Specify the criteria for the clusters to return.
// All filters/conditions are AND-ed together. If no filters/conditions
// are set, the call will return all clusters.
message ClusterFilter {
    // If set, return only clusters of the provided type.
    optional ClusterInfo.Type type_filter = 1;
}

message CreateTempGroupRequest {
    optional TempGroupInfo group_info = 1;
}

message CreateTempGroupResponse {
    optional Group group = 1;
}

message CreateNestedGroupRequest {
    optional NestedGroupInfo group_info = 1;
}

message CreateNestedGroupResponse {
    optional Group group = 1;
}

message UpdateNestedGroupRequest {
    optional int64 group_id = 1;
    optional NestedGroupInfo new_group_info = 2;
}

message UpdateNestedGroupResponse {
    optional Group updated_group = 1;
}

// Request for udpating the cluster headroom template ID of a cluster.
// The group_id must reference a group that is a cluster.
message UpdateClusterHeadroomTemplateRequest {
    optional int64 group_id = 1;
    optional int64 cluster_headroom_template_id = 2;
}

message UpdateClusterHeadroomTemplateResponse {
    // The group with with udpated cluster headroom template ID
    optional Group updated_group = 1;
}

message GetClusterForEntityRequest {
    optional int64 entity_id = 1;
}

message GetClusterForEntityResponse {
    optional Group cluster = 1;
}

message GetTagsRequest {}

message GetTagsResponse {
    optional .tag.Tags tags = 1;
}

// A service responsible for group operations.
service GroupService {
    // Create a group
    rpc CreateGroup(GroupInfo) returns (CreateGroupResponse);

    rpc CreateTempGroup(CreateTempGroupRequest) returns (CreateTempGroupResponse);

    rpc CreateNestedGroup(CreateNestedGroupRequest) returns (CreateNestedGroupResponse);

    // Get a group
    rpc GetGroup(GroupID) returns (GetGroupResponse);

    // Get all user groups
    rpc GetGroups(GetGroupsRequest) returns (stream Group);

    // Update a group
    //
    // Returns INVALID_ARGUMENT if the group is a discovered group (origin == DISCOVERED), since
    // users cannot modify discovered groups.
    rpc UpdateGroup(UpdateGroupRequest) returns (UpdateGroupResponse);

    // Update a nested group.
    //
    // Returns INVALID_ARGUMENT if the group is a discovered group (origin == DISCOVERED), since
    // users cannot modify discovered groups.
    rpc UpdateNestedGroup(UpdateNestedGroupRequest) returns (UpdateNestedGroupResponse);

    // Update the cluster headroom template ID of a cluster.
    rpc UpdateClusterHeadroomTemplate(UpdateClusterHeadroomTemplateRequest)
    returns (UpdateClusterHeadroomTemplateResponse);

    // Delete a group
    //
    // Returns INVALID_ARGUMENT if the group is a discovered group.
    rpc DeleteGroup(GroupID) returns (DeleteGroupResponse);

    // Get the members of a group
    rpc GetMembers(GetMembersRequest) returns (GetMembersResponse);

    // Get the cluster the entity belongs to.
    rpc GetClusterForEntity(GetClusterForEntityRequest) returns (GetClusterForEntityResponse);

    // Stores groups, clusters, settings and policies discovered in the customer's topology.
    rpc StoreDiscoveredGroupsPoliciesSettings(stream DiscoveredGroupsPoliciesSettings) returns (StoreDiscoveredGroupsPoliciesSettingsResponse);

    // Returns all tags of groups
    rpc GetTags(GetTagsRequest) returns (GetTagsResponse);
}

