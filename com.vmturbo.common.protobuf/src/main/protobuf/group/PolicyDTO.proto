syntax = "proto2";

package group;

option java_package = "com.vmturbo.common.protobuf.group";

message Policy {
    optional int64 id = 1;

    // The ID of the target that discovered the policy,
    // if the policy was discovered by a target.
    optional int64 target_id = 2;

    // Editable information describing the details of the policy.
    optional PolicyInfo policy_info = 10;
}

// The customizable properties of a policy.
message PolicyInfo {
    // Name of the policy
    optional string name = 1;

    // Name of the policy
    optional string display_name = 4;

    // Shows if the policy is enabled.
    optional bool enabled = 2 [default = true];

    // Commodity type used for the policy.
    optional string commodity_type = 3;

    oneof policy_detail {
        AtMostNPolicy at_most_n = 15;
        AtMostNBoundPolicy at_most_nbound = 16;
        BindToComplementaryGroupPolicy bind_to_complementary_group = 17;
        BindToGroupPolicy bind_to_group = 18;
        BindToGroupAndLicencePolicy bind_to_group_and_license = 19;
        BindToGroupAndGeoRedundancyPolicy bind_to_group_and_geo_redundancy = 20;
        MergePolicy merge = 21;
        MustRunTogetherPolicy must_run_together = 22;
        MustNotRunTogetherPolicy must_not_run_together = 23;
    }

    // Defines a limit on the number of entities from the consumer group that can run on each
    // provider in the provider group without limiting the consumers to run only on the entities
    // in the provider group.
    // Common use case: VM->VM anti-affinity
    message AtMostNPolicy {
        // Indicate the max entities at the same time that can run on any entity in the provider group.
        optional float capacity = 1;
        optional int64 consumer_group_id = 2;
        optional int64 provider_group_id = 3;
    }

    // Limits the entities in the consumer group to run only on the entities in the provider group
    // and limit the number of entities that can run on each of the providers.
    // Common use case: VM->VM anti-affinity
    message AtMostNBoundPolicy {
        // Indicate the max workload entities at the same time per placement entites.
        optional float capacity = 1;
        optional int64 consumer_group_id = 2;
        optional int64 provider_group_id = 3;
    }

    // Entities in the consumer group can not run on any entity in the provider group.
    // Common use case: VM->Host or VM->Storage anti-affinity.
    message BindToComplementaryGroupPolicy {
        optional int64 consumer_group_id = 1;
        optional int64 provider_group_id = 2;
    }

    // Limits the entities in the consumer group to run only on the entities in the provider group.
    // Common use case: VM->Host or VM->Storage affinity.
    message BindToGroupPolicy {
        optional int64 consumer_group_id = 1;
        optional int64 provider_group_id = 2;
    }

    // Limits the entities in the consumer group to run only on the entities in the provider group
    // and makes it more expensive for workloads not in the consumer group to run on providers in the provider group.
    message BindToGroupAndLicencePolicy {
        optional int64 consumer_group_id = 1;
        optional int64 provider_group_id = 2;
    }

    // ??? - Seems to have something to do with timezones.
    message BindToGroupAndGeoRedundancyPolicy {
        optional int64 consumer_group_id = 1;
        optional int64 provider_group_id = 2;
    }

    // Merges all the given provider groups to be viewed as a single liquidity pool. For example
    // when merging clusters workloads would be able to move across the boundaries of those clusters.
    message MergePolicy {
        // The merge type indicates the type of groups that we want to merge.
        enum MergeType {
            // Merge cluster workloads (a cluster is a group of physical machines).
            CLUSTER = 0;

            // Merge storage cluster workloads (a storage cluster is a group of storages).
            STORAGE_CLUSTER = 1;

            // Merge datacenter workloads (a datacenter is a group of physical machines).
            DATACENTER = 2;

            // Merge desktop pool entities
            DESKTOP_POOL = 3;
        }

        optional MergeType merge_type = 1;

        // List of Groups to merge
        repeated int64 merge_group_ids = 2;
    }

    // Requires that all entities in the group must run together on a single provider.
    // Common use case: VM->VM affinity.
    message MustRunTogetherPolicy {
        optional int64 group_id = 1;

        // Entity type of the provider on which we want the consumers to run together.
        // We might want 2 VMs to run on the same host, or run on the same storage.
        optional int32 provider_entity_type = 2;
    }

    // Requires that all entities in the group must not run together on the same provider.
    // Common use case: VM->VM anti-affinity.
    // Please note that this is different from the AtMostN and AtMostNBound policies. Those last two
    // requires you to limit on which provider group the entities should run; and also limit how many
    // of them to run, per provider.
    message MustNotRunTogetherPolicy {
        optional int64 group_id = 1;

        // Entity type of the providers on which we want the consumers to not run together.
        // We might want 2 VMs to run on different hosts, or run on different storages.
        optional int32 provider_entity_type = 2;
    }
}

message SinglePolicyRequest {
    optional int64 policy_id = 1;
}

message PolicyRequest {
    repeated int64 policy_ids = 1;
}

message PolicyResponse {
    // The policy, if found.
    // If not found, this will be unset.
    optional Policy policy = 1;
}

message PolicyCreateRequest {
    optional PolicyInfo policy_info = 1;
}

message PolicyCreateResponse {
    optional Policy policy = 1;
}

message PolicyEditRequest {
    optional int64 policy_id = 1;

    optional PolicyInfo new_policy_info = 2;
}

message PolicyEditResponse {
    // The edited policy.
    optional Policy policy = 1;
}

message PolicyDeleteRequest {
    optional int64 policy_id = 1;
}

message PolicyDeleteResponse {
    // The deleted policy.
    optional Policy policy = 1;
}

service PolicyService {
    rpc GetPolicy(SinglePolicyRequest) returns (PolicyResponse) {}
    rpc GetPolicies(PolicyRequest) returns (stream PolicyResponse) {}
    rpc CreatePolicy(PolicyCreateRequest) returns (PolicyCreateResponse) {}
    rpc EditPolicy(PolicyEditRequest) returns (PolicyEditResponse) {}
    rpc DeletePolicy(PolicyDeleteRequest) returns (PolicyDeleteResponse) {}
}
