syntax = "proto2";
package cost;

option java_package = "com.vmturbo.common.protobuf.cost";

import "CloudCostDTO.proto";
import "PricingDTO.proto";
import "cost/Cost.proto";

// The price table is used to help calculate costs for entities in the
// topology that use cloud services, or to evaluate the effects of cloud-related moves/provisions
// in the market.
//
// The price table is extracted out of price data coming from the cost probe for a particular
// service provider, so each service provider will have its own price table. However:
// 1) One service provider may have different services (e.g. EC2, RDS for AWS), and the cost
//    probe should send the merged prices for all these services together. This means that
//    the price table for that service provider will contain prices for all services.
// 2) Price tables for different service providers could also be combined into one,
//    since IDs for all sold products should be different between service providers.
//
// This table contains PRICES - the amounts that the cloud providers say you need
// to pay for specific services (e.g. for a particular compute instance).
// We use the prices to calculate "bottom-up" costs - the amounts that the user will need to
// pay for a specific entity in the topology.
//
// Note: Bottom-up costs are our estimates of the costs for entities in the cloud based on the
// information that we have in the system (such as this price table, any discounts, and
// already-purchased reserved instances bought). This is different from top-down costs - which
// are the amounts that the user actually got charged, discovered by the billing probes.
// Bottom-up costs are essentially our estimates of what the top-down costs will be.
message PriceTable {
    // The on-demand prices, arranged by region ID.
    // See OnDemandPriceTable for more details.
    map<int64, OnDemandPriceTable> on_demand_price_by_region_id = 1;

    // The spot instance prices, arranged by zone or region ID. If prices are provided per zone
    // the key is zone ID, otherwise the key is region ID.
    // See SpotInstancePriceTable for more details.
    map<int64, SpotInstancePriceTable> spot_price_by_zone_or_region_id = 10;

    // A list of on-demand license prices grouped by OS type.
    repeated common_dto.LicensePriceEntry on_demand_license_prices = 20;

    // A list of reserved license prices grouped by OS type.
    repeated common_dto.LicensePriceEntry reserved_license_prices = 30;
}

// PriceTableKey contains information which describes the source of price table.
message PriceTableKey {
    // Represents the scope of this PriceTableKey. It is expected the group will be an identifier
    // of the cloud provider (e.g. AWS, Azure). This group is a short-term implementation for scoping
    // the keys, which is expected to be replaced by a CloudServiceProvider entity identifier in the
    // near future
    optional string pricing_group = 1;

    // probe_key_material is a map of miscellaneous information about the price table which helps to
    // uniquely identify a price table and to which account it might be related to.
    map<string, string> probe_key_material = 2;
}

// Simple MapFieldEntry to capture checksum of each priceTableKey and to
// serve GetPriceTableChecksum requests.
message PriceTableChecksum {
    optional PriceTableKey price_table_key = 1;

    optional int64 check_sum = 2;
}

// Map of business account OID to priceTableKey
message BusinessAccountPriceTableKey {
    map<int64, PriceTableKey> business_account_price_table_key = 1;
}

// The pricing information for reserved instances.
//
// This is kept separate from the main pricing table, because reserved instance pricing is only
// used to generate reserved instance buy recommendations, which happens outside the market.
message ReservedInstancePrice {
    // The pricing table for reserved instances.
    // See ReservedInstancePriceTable for more details.
    optional ReservedInstancePriceTable pricing_table = 1;
}

// The pricing table for reserved instances. This pricing table is GLOBAL, because
// region ID is factored into the reserved instance spec.
//
// Reserved instances are basically discounted on-demand instances with
// an upfront cost and a term. So instead of paying on-demand, you buy
// "in bulk".
//
// Note: AWS and Azure have reserved instance, and Google has a similar
// concept called "Committed Use Discounts".
message ReservedInstancePriceTable {

    // The prices for reserved instances, arranged by the ID of the reserved instance spec.
    // The spec is made up of all the configurable fields that affect the price of the instance,
    // so each spec resolves to exactly one price.
    map<int64, common_dto.ReservedInstancePrice> ri_prices_by_spec_id = 1;
}

// The pricing table for on-demand instances within a particular region.
//
// On-demand instances are the "default" pay-per-use option for all cloud providers.
message OnDemandPriceTable {

    // The prices for compute tiers in this region, arranged by tier ID.
    map<int64, common_dto.ComputeTierPriceList> compute_prices_by_tier_id = 1;

    // The prices for database instances in this region, arranged by instance ID.
    map<int64, DbTierOnDemandPriceTable> db_prices_by_instance_id = 2;

    // The prices for IPs in this region
    optional common_dto.IpPriceList ip_prices = 3;

    // The prices for cloud storage in this region, arranged by tier ID.
    map<int64, common_dto.StorageTierPriceList> cloud_storage_prices_by_tier_id = 4;
}

message DbTierOnDemandPriceTable {
    optional common_dto.DatabaseTierPriceList on_demand_prices_no_deployment_type = 1;
    map<int32, common_dto.DatabaseTierPriceList> db_prices_by_deployment_type = 2;
}

// The pricing table for spot instances.
//
// Spot instances are acquired via bids for unused capacity in a data center.
// They are cheaper than on-demand instances, but volatile - if someone bids
// higher, you lose the instance.
//
// Note: Spot instances are called Low-Priority VMs in Azure, and Preemptible VMs in
//       Google Cloud.
message SpotInstancePriceTable {
    // Spot prices by compute tier ID
    map<int64, SpotPricesForTier> spot_prices_by_tier_oid = 1;

    // Spot prices for all Operating Systems in a given Compute Tier
    message SpotPricesForTier {
        repeated PriceForGuestOsType price_for_guest_os_type = 1;
    }

    // Spot instance price for given guest OS type
    message PriceForGuestOsType {
        // OS type
        required common_dto.OSType guest_os_type = 1;

        // Spot instance hourly price
        required common_dto.Price price = 2;
    }
}

message GetPriceTableRequest {
}

message GetPriceTablesRequest {
    // List of oids to get price tables for.
    repeated int64 oid = 1;
}

message GetPriceTableResponse {
    // The global price table is a merging of all the per-target price tables.
    // We can merge all of them safely because the individual tiers have globally unique IDs.
    optional PriceTable global_price_table = 1;
}

message GetPriceTablesResponse{
    // List of price tables corresponding to a list of oids
    map <int64, PriceTable> price_tables_by_oid = 1;
}

// a segment of a probe price table delivery
message ProbePriceTableSegment {
    optional ProbePriceTableHeader header = 1;
    optional ProbePriceTableChunk probe_price_table = 2;
    optional ProbeRISpecPriceChunk probe_ri_spec_prices = 3;

    message ProbePriceTableHeader {
        // the time the request was created
        optional int64 created_time = 1;

        // entries of price_table to its checksum values.
        repeated PriceTableChecksum price_table_checksums = 2;
    }

    // a chunk containing a probe's price table.
    message ProbePriceTableChunk {
        //PriceTableKey contains priceTable properties.
        required PriceTableKey price_table_key = 1;

        optional PriceTable price_table = 2;
    }

    // a chunk of RI Spec Prices from a probe type. We may see several of these spread across
    // several ProbePriceTableSegments
    message ProbeRISpecPriceChunk {
        //PriceTableKey contains priceTable properties.
        optional PriceTableKey price_table_key = 1;

        repeated ReservedInstanceSpecPrice reserved_instance_spec_prices = 2;
    }
}

message ReservedInstanceSpecPrice {
    optional ReservedInstanceSpecInfo ri_spec_info = 1;

    optional common_dto.ReservedInstancePrice price = 2;
}

message UploadPriceTablesResponse {
}

message GetPriceTableChecksumRequest {
    repeated PriceTableKey priceTableKey = 1;
}

message GetPriceTableChecksumResponse {
    repeated PriceTableChecksum pricetable_to_checksum = 1;
}

// Request for upload map of businessAccount to PriceTable in cost DB.
message UploadAccountPriceTableKeyRequest {
    optional BusinessAccountPriceTableKey business_account_price_table_key = 1;
}

// Response for UploadAccountPriceTableKeyRequest.
message UploadAccountPriceTableKeysResponse {

}

// Request to fetch map of BA OIDs to Price table key.
message GetAccountPriceTableRequest {
    repeated int64 business_account_oid  = 1;
}

// Response for GetAccountPriceTableKeys. Returns map of BA OIDs to PriceTableKey OIDs.
message GetAccountPriceTableResponse {
    map<int64, int64> business_account_price_table_key = 1;
}

// The pricing service is the interface to upload and retrieve pricing data from the cost
// component.
service PricingService {
    // Get the current "global" price table.
    rpc GetPriceTable (GetPriceTableRequest) returns (GetPriceTableResponse) {
        option deprecated = true;
    };

    // Gets a list of price tables
    rpc GetPriceTables (GetPriceTablesRequest) returns (GetPriceTablesResponse);

    // request for the checksum of the list of price tables
    rpc GetPriceTableChecksum (GetPriceTableChecksumRequest) returns (GetPriceTableChecksumResponse);

    // Upload the most recent price table discovered by a particular cost probe.
    // Returns INVALID_ARGUMENT if the request is missing fields.
    // Captures priceTableKey -> priceTable data. Its working is closely related to information
    // captured by UploadAccountPriceTableKeys. Which captures BA OID - > priceTableKey information.
    rpc UpdatePriceTables (stream ProbePriceTableSegment) returns (UploadPriceTablesResponse);

    // Upload map of businessAccounts id to priceTableKeys discovered.
    // This is closely related to UpdatePriceTables which provides priceTableKeys to priceTable information.
    // BA -> priceTable data can be looked up only after both these rpc call completes.
    rpc UploadAccountPriceTableKeys (UploadAccountPriceTableKeyRequest)
    returns (UploadAccountPriceTableKeysResponse);

    //Request to fetch BA OIDs to price table key mapping.
    //If no BA OIDs are provided, all mappings are returned.
    rpc GetAccountPriceTable(GetAccountPriceTableRequest)
    returns (GetAccountPriceTableResponse);
}
