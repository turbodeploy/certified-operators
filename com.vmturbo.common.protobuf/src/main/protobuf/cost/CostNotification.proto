syntax = "proto2";
package cost;

option java_package = "com.vmturbo.common.protobuf.cost";

import "plan/PlanProgressStatusEnum.proto";
import "cost/Cost.proto";
import "topology/TopologyDTO.proto";

// This defines notifications that are sent to subscribing components in various circumstances.
// It is the notification message from cost component to plan orchestrator at the end of an
// optimize cloud plan.
message CostNotification {

    oneof Type {
        // notify of events in the lifecycle of certain plans
        StatusUpdate status_update = 1;
        // notify of new cost data computed from a source real-time topology
        CloudCostStatsAvailable cloud_cost_stats_available = 2;

        // Notify when account expenses (billing costs) are available.
        AccountExpensesAvailable account_expenses_available = 3;

        // When savings data is available for query.
        CloudSavingsAvailable cloud_savings_available = 4;
    }

    // A message about a cost operation stats
    message StatusUpdate {

        optional StatusUpdateType type = 1;

        // the topology context id that the operation relates to
        optional int64 topology_context_id = 2;

        // the topology id that the operation relates to
        optional int64 topology_id = 3;

        // status of the operation
        optional .plan.Status status = 4 [default = UNKNOWN];

        // TODO: the error description should be set if any error happens while running the plan.
        // This description is useful when status is fail.
        optional string status_description = 5;

        // the time that the operation reached the status indicated
        optional int64 timestamp = 6;

        optional int64 topology_creation_time = 7;

    }

    enum StatusUpdateType {
        // This notification will be sent after ReservedInstanceCoverageUpdate has finished processing
        // RI coverage for a topology. This processing will include supplemental RI coverage
        // allocation. "Source" refers to a live/realtime topology and is meant to be the origin
        // of a projected topology.
        SOURCE_RI_COVERAGE_UPDATE = 1;
        // It will be sent from cost to plan orchestrator after receiving the cost signal.
        PROJECTED_COST_UPDATE = 2;
        // It will be sent from cost to plan orchestrator after receiving the RI coverage signal.
        PROJECTED_RI_COVERAGE_UPDATE = 3;
        // This notification will be sent after plan entity cost is persisted.
        PLAN_ENTITY_COST_UPDATE = 4;
    }

    // Notification that newly computed cloud cost stats data have become available
    message CloudCostStatsAvailable {
        // the snapshot_date of the topology on which the costs are based
        required int64 snapshot_date = 1;
    }

    // Notification sent out from cost when AccountExpenses (Billing costs) have been persisted.
    message AccountExpensesAvailable {
    }

    // Notification about new cloud savings data being available for query. Typically every hour
    // new savings data is written to entity_savings_by_hour DB table, so one notification of
    // this type is sent out. E.g at 10:15 AM, data is written to DB for 9:00 - 10:00 time period,
    // so start_date (inclusive) will be 9:00 and end_date (exclusive) will be 10:00.
    message CloudSavingsAvailable {
        // The start timestamp (inclusive) of available savings data.
        optional uint64 start_date = 1;

        // The end timestamp (exclusive) of available savings data.
        optional uint64 end_date = 2;
    }
}

// On-demand cost information for an entire topology (used by suspend component)
message TopologyOnDemandCostChunk {

    optional int64 topology_oid = 1;

    oneof segment {
        Start start = 2;
        Data data = 3;
        End end = 4;
    }

    message Start {
        // Basic information about the topology
        optional .topology.TopologyInfo topology_info = 1;
    };

    message Data {
        repeated EntityCost entity_costs = 1;
    }

    message End {
        // Total number of costs sent (can be used for integrity checks)
        optional uint64 total_count = 1;
    }
}