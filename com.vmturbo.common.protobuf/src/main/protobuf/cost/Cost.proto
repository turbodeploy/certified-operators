syntax = "proto2";
package cost;

option java_package = "com.vmturbo.common.protobuf.cost";

import "CloudCostDTO.proto";
import "common/Pagination.proto";

// Top down Cloud account expense discovered by the billing probe, associated with a specific account
message AccountExpenses {
    // The associated account oid
    optional int64 associated_account_id = 1;

    // Account service expense, e.g. AWSLambda
    repeated ServiceExpenses service_expenses = 2;

    // Account tier expense, e.g. i3.large.
    repeated TierExpenses tier_expenses = 3;

    message ServiceExpenses {
        optional int64 associated_service_id = 1;

        optional common_dto.CurrencyAmount expenses = 2;
    }

    message TierExpenses {
        optional int64 associated_tier_id = 1;

        optional common_dto.CurrencyAmount expenses = 2;
    }

    // The timestamp at which the expense is received by Cost component.
    // Note: It should be the timestamp that the expenses were generated.
    // But currently probe doesn't have this information in it's DTO.
    // The time is in "system time" and not necessarily UTC.
    optional int64 expense_received_timestamp = 4;
}

// A reserved instance is a reservation of resources and capacity and it provides a significant
// discount compared to on-demand instances. And it is reserved instance bought by user account.
message ReservedInstance {
    // The id of the reserved instance.
    optional int64 id = 1;

    // The properties describe the reserved instance. Set the field tag to 10, in case of we need to
    // add more properties later.
    optional ReservedInstanceInfo reserved_instance_info = 10;

    // Information describing the reserved instance. And it is not editable by the user, all the
    // reserved instance information are discovered by cloud probe.
    message ReservedInstanceInfo {
        // The business account id of the reserved instance.
        optional int64 business_account_id = 1;

        // The reserved instance id of probe send out, we use it to tell if two reserved instance bought
        // are same or not.
        optional string probe_reserved_instance_id = 2;

        // The start milliseconds since epoch.
        optional int64 start_time = 3;

        // The number of instances bought of the reserved instance.
        optional int32 num_bought = 4;

        // The availability zone of the reserved instance. It will only be set if the reserved instance
        // was made in a specific availability zone. Otherwise, it is local to a region, and the region
        // id in reserved instance spec will be set.
        optional int64 availability_zone_id = 5;

        // The id of reserved instance spec which this reserved instance refer to.
        optional int64 reserved_instance_spec = 6;

        // The cost of the reserved instance. It is the cost that user account payed when user bought this
        // reserved instance, it might be different from the current reserved instance cost.
        optional ReservedInstanceCost reserved_instance_cost = 7;

        // The coupons information of the reserved instance.
        optional ReservedInstanceCoupons reserved_instance_coupons = 8;

        message ReservedInstanceCost {
            // The upfront one-time cost of the Reserved Instance.
            optional common_dto.CurrencyAmount fixed_cost = 1;

            // Hourly cost for usage, e.g. licensing fee.
            optional common_dto.CurrencyAmount usage_cost_per_hour = 2;

            // Hourly cost for reserved instance, regardless of usageCost.
            optional common_dto.CurrencyAmount recurring_cost_per_hour = 3;
        }

        // Coupons is a our internal way compare different instance types in a family. For example,
        // in AWS, they defined Normalization Factor (NFU) for different instance size:
        // https://aws.amazon.com/blogs/aws/new-instance-size-flexibility-for-ec2-reserved-instances/
        // In our internal mode, we defined the coupon is equal to NFU * 4, in this case, the smallest
        // unit is 1. And for reserved instances, it will sell coupons, and other service entity can
        // buy coupons from reserved instances, in this way, we can solve instance size flexibility
        // for reserved instances.
        message ReservedInstanceCoupons {
            // The total couponse of the reserved instance. And it is equal to
            // number of instances bought * number of coupons per instance. For each instance type,
            // its coupons is equal to its NFU * 4.
            optional int32 number_of_coupons = 1;

            // The number of coupons has been used by service entity. This number should be calculated
            // from EntityReservedInstanceCoverage, it should be equal to the sum of its consumers
            // coupons. The SDK probe will not set this field when discovering real time topology.
            optional double number_of_coupons_used = 2;
        }
    }
}

// A group fields of reserved instance fields in different combination, if any one of them changed,
// the reserved instance price could be also changed.
message ReservedInstanceSpec {
    // The id of reserved instance spec, when Topology Processor uploading RI bought data to Cost component,
    // Topology Processor will create a local id of this spec, and Cost component needs to change local id
    // to a real id.
    optional int64 id = 1;

    // A wrapper of reserved instance spec fields except reserved instance spec id.
    optional ReservedInstanceSpecInfo reserved_instance_spec_info = 2;
}

// A list of fields which can impact the price of the reserved instance.
message ReservedInstanceSpecInfo {

    // The type of the reserved instance.
    optional common_dto.ReservedInstanceType type = 1;

    // The tenancy of the reserved instance.
    optional common_dto.Tenancy tenancy = 2;

    // The operating system of the reserved instance.
    optional common_dto.OSType os = 3;

    // The entity profile id of the reserved instance using, such as t2.large.
    optional int64 tier_id = 4;

    // The region id of the reserved instance.
    optional int64 region_id = 5;
}

// Contains the relationship about which service entity is covered by what reserved instance and
// how many coupons are covered by each different reserved instance.
message EntityReservedInstanceCoverage {
    // The id of entity.
    optional int64 entity_id = 1;

    // The total coupons of this entity can sold.
    optional double total_coupons = 2;

    // The reserved instance coverage of this entity, which one entity could use a list of reserved
    // instance.
    repeated Coverage coverage = 3;

    message Coverage {
        // The id of reserved instance.
        optional int64 reserved_instance_id = 1;
        // The number of coupons covered by the reserve instance.
        optional double covered_coupons = 2;
    }
}


// A message used to retrieve account expenses.
message ExpenseRequest {
    // A filter to be applied to the account expense retrieved. If no filter is supplied
    // all account expenses are returned.
    optional ExpenseQueryFilter filter = 1;

    // The pagination parameters for the request.
    // If not set, the service will use the default sort order and limit.
    optional common.PaginationParameters pagination_params = 2;
}

// Response to the expense request
message ExpenseResponse {
    // The list of account expense.
    // The length of this list will not exceed the limit set in the request pagination parameters.
    // The account expense will be ordered according to the order in the request pagination parameters.
    repeated AccountExpenses account_expense = 1;

    // The response message containing pagination-related response parameters.
    optional common.PaginationResponse pagination_response = 2;
}

// A filter to be supplied with expense queries.
// The conditions in the query filter will be AND-ed together, so only
// expenses that match all of them will be returned.
message ExpenseQueryFilter {
    // There are two types of filters.
    // - Account filter: used to filter account
    // - Cloud service filter: used to filter Cloud service

    // Include only expenses in the given accounts. It's optional and return all expenses if empty.
    repeated int64 associated_account_id = 1;

    // Include only expenses in the given Cloud service. It's optional and return all expenses if empty.
    repeated int64 associated_cloud_service_id = 2;

    // date range for the request; dates are epoch longs, e.g. Unix Timestamp
    // We currently require both start_date and end_date to be not null.
    optional int64 start_date = 3;

    optional int64 end_date = 4;
}

// Discount associated with a specific business account.
// Customers negotiate discounts with Cloud Vendors:
// * Enterprise Program Discount [AWS]
// * Enterprise Agreement [Azure]
// Entity costs in Turbonomic should reflect what the customer actually pays
// All discounts to be entered by user [Cannot be discovered]
message Discount {
    // The oid for the discount
    optional int64 id = 1;

    // The associated business account oid
    optional int64 associated_account_id = 2;

    // Global level account discount, e.g. 10.0 % on Account A
    optional AccountLevelDiscount account_level_discount = 3;

    // Service level discount, e.g. 10.0 % on all EC2 for Account A
    optional ServiceLevelDiscount service_level_discount = 4;

    // Tier/Template level discount, e.g. 10.0 % on all t2.small for Account A
    optional TierLevelDiscount tier_level_discount = 5;

    message AccountLevelDiscount {
        // The global level discount, e.g. 10.0
        optional double discount_percentage = 1;
    }

    message ServiceLevelDiscount {
        // The service level discount, arranged by service ID, e.g. 111111 -> 10.0
        map<int64, double> discount_percentage_by_service_id = 1;
    }

    message TierLevelDiscount {
        // The Tier/Template level discount, arranged by tier ID, e.g. 2222222 -> 10.0
        map<int64, double> discount_percentage_by_tier_id = 1;
    }
}

// The Cloud entity cost. It can store calcuated and predicted (from Market to Cost component)
// entity cost, help persist to DB, and help calculate cost from REST API reqeusts.
message EntityCost {
    // The associated entity oid for the Cloud entity.
    optional int64 associated_entity_id = 1;

    // list of component costs, e.g. Compute and Storage costs.
    repeated ComponentCost component_cost = 2;

    // A pre-calcuate hourly total entity cost for speeding up calculation.
    // It's the summation of the list of component costs.
    optional common_dto.CurrencyAmount total_amount = 3;

    message ComponentCost {
        // Cost type represents the possible breakdown of an entity cost into separate components
        // Like Compute, Storage, licensing and so on.
        optional CostType cost_type = 1;

        // Hourly rate for Cloud entity
        optional common_dto.CurrencyAmount amount = 2;
    }
}

// Cost type represents the possible breakdown of an entity cost into separate components
// like Compute, Network, Storage, licensing and so on.
// As we increase support for more breakdowns this enum will be extended to support them.
// It's closly matched with the legacy definition in
// com.vmturbo.platform.VMTRoot.ManagedEntities.Abstraction.CostType class.
// Note: the RI_COMPUTE type is covered by ReservedInstance.proto
enum CostType {
    // Represents the compute cost associated with an entity.
    // For example the cost of a cloud template or for the CPU and memory resources
    COMPUTE = 0;

    // Represents the storage cost associated with an entity.
    // For example the cost of a cloud 100 GB storage
    STORAGE = 1;

    // Represents the additional IP address related costs associated with an entity.
    // For example cost of a static IP.
    IP = 2;

    // Represents the licensing related costs associated with an entity.
    // For example OS pricing, application licensing, DB licenses and so on.
    LICENSE = 3;
}


// A service responsible for getting information about cost information in Cloud.
service CostService {
    // Get information about account expense
    rpc GetAccountExpense (ExpenseRequest) returns (ExpenseResponse);
}

