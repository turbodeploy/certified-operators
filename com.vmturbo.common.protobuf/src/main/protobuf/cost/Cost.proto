syntax = "proto2";
package cost;

option java_package = "com.vmturbo.common.protobuf.cost";

import "CloudCostDTO.proto";
import "common/Pagination.proto";
import "CommonDTO.proto";
import "topology/TopologyDTO.proto";
import "stats/Stats.proto";

// Top down Cloud account expense discovered by the billing probe, associated with a specific account
message AccountExpenses {
    // The associated account oid
    optional int64 associated_account_id = 1;

    // account expenses info to store service and tier expenses
    optional AccountExpensesInfo account_expenses_info = 2;

    // The epoch milliseconds of the date at which the services/tiers were used.
    // Since all the expenses should be from yesterday and the minimal time frame is DAY,
    // all the expenses should have the same usage date.
    // The timestamp is from the first second of the day, for example:
    // 1575158400 = Sunday, December 1, 2019 12:00:00 AM (UTC)
    optional int64 expenses_date = 3;

    // Service and tier level account expense information. An account could have many service
    // and tier level expenses.
    message AccountExpensesInfo {
        // Account service expense, e.g. AWSLambda
        repeated ServiceExpenses service_expenses = 1;

        // Account tier expense, e.g. i3.large.
        repeated TierExpenses tier_expenses = 2;

        // Service level expense entry
        message ServiceExpenses {
            // Service id
            optional int64 associated_service_id = 1;

            // Service expenses, dollars per hour.
            optional common_dto.CurrencyAmount expenses = 2;
        }

        // Tier level expense entry.
        message TierExpenses {
            // Tier id
            optional int64 associated_tier_id = 1;

            // Tier expenses, dollars per hour
            optional common_dto.CurrencyAmount expenses = 2;
        }
    }
}

// A reserved instance is a reservation of resources and capacity and it provides a significant
// discount compared to on-demand instances. And it is reserved instance bought by user account.
message ReservedInstanceBought {
    // The id of the reserved instance.
    optional int64 id = 1;

    // The properties describe the reserved instance. Set the field tag to 10, in case of we need to
    // add more properties later.
    optional ReservedInstanceBoughtInfo reserved_instance_bought_info = 10;

    // Information describing the reserved instance. And it is not editable by the user, all the
    // reserved instance information are discovered by cloud probe.
    message ReservedInstanceBoughtInfo {
        // The business account id of the reserved instance.
        optional int64 business_account_id = 1;

        // The reserved instance id of probe send out, we use it to tell if two reserved instance bought
        // are same or not.
        optional string probe_reserved_instance_id = 2;

        // The start milliseconds since epoch.
        optional int64 start_time = 3;

        // The number of instances bought of the reserved instance.
        optional int32 num_bought = 4;

        // The availability zone of the reserved instance. It will only be set if the reserved instance
        // was made in a specific availability zone. Otherwise, it is local to a region, and the region
        // id in reserved instance spec will be set.
        optional int64 availability_zone_id = 5;

        // The id of reserved instance spec which this reserved instance refer to.
        optional int64 reserved_instance_spec = 6;

        // The cost of the reserved instance. It is the cost that user account payed when user bought this
        // reserved instance, it might be different from the current reserved instance cost.
        optional ReservedInstanceBoughtCost reserved_instance_bought_cost = 7;

        // The coupons information of the reserved instance.
        optional ReservedInstanceBoughtCoupons reserved_instance_bought_coupons = 8;

        // Reserved instance display name.
        optional string display_name = 9;

        // Reservation order ID. Currently it is used by Azure only.
        optional string reservation_order_id = 10;

        // Information about the scope within RI can be applied.
        optional ReservedInstanceScopeInfo reserved_instance_scope_info = 11;

        optional ReservedInstanceDerivedCost reserved_instance_derived_cost = 12;

        message ReservedInstanceBoughtCost {
            // The upfront one-time cost of the Reserved Instance.
            optional common_dto.CurrencyAmount fixed_cost = 1;

            // Hourly cost for usage, e.g. licensing fee.
            optional common_dto.CurrencyAmount usage_cost_per_hour = 2;

            // Hourly cost for reserved instance, regardless of usageCost.
            optional common_dto.CurrencyAmount recurring_cost_per_hour = 3;
        }

        // Holds costs derived from RI attributes and other data (including the price tables).
        // Attributes of this message should not be expected to be set on upload to the cost
        // component and may not be a stored value (e.g. on-demand rate is queried dynamically
        // at request time)
        message ReservedInstanceDerivedCost {

            // The up front + recurring costs of the RI, amortized over the term
            optional common_dto.CurrencyAmount amortized_cost_per_hour = 1;

            // The equivalent hourly on demand cost for the Reserved Instance.
            optional common_dto.CurrencyAmount on_demand_rate_per_hour = 2;
        }

        // Coupons is a our internal way compare different instance types in a family. For example,
        // in AWS, they defined Normalization Factor (NFU) for different instance size:
        // https://aws.amazon.com/blogs/aws/new-instance-size-flexibility-for-ec2-reserved-instances/
        // In our internal mode, we defined the coupon is equal to NFU * 4, in this case, the smallest
        // unit is 1. And for reserved instances, it will sell coupons, and other service entity can
        // buy coupons from reserved instances, in this way, we can solve instance size flexibility
        // for reserved instances.
        message ReservedInstanceBoughtCoupons {
            // The total couponse of the reserved instance. And it is equal to
            // number of instances bought * number of coupons per instance. For each instance type,
            // its coupons is equal to its NFU * 4.
            optional int32 number_of_coupons = 1;

            // The number of coupons has been used by service entity. This number should be calculated
            // from the entity's RI coverage, and it should be equal to the sum of its consumers
            // coupons. The SDK probe will not set this field when discovering real time topology.
            optional double number_of_coupons_used = 2;
        }

        // Information about the scope within RI can be applied.
        // Azure RIs can be either shared or single scoped. If RI is shared it can be applied to
        // several accounts in the billing family. These accounts are listed in
        // applicable_business_account_id field.
        // AWS RIs can also be shared or single scoped. However AWS shared RIs are the most common.
        // Currently we do not support single scope AWS RIs. So for AWS "shared" is always true.
        message ReservedInstanceScopeInfo {
            // Defines whether RI can be used by all accounts in the billing family.
            optional bool shared = 1 [default = true];

            // List of accounts that RI can be applied to. In case of single scoped (non-shared)
            // RI the list cannot contain more than one account ID. If this list is empty for
            // shared RI it means the RI can be applied to all accounts in the billing family.
            repeated int64 applicable_business_account_id = 2;
        }
    }
}

// A group fields of reserved instance fields in different combination, if any one of them changed,
// the reserved instance price could be also changed.
message ReservedInstanceSpec {
    // The id of reserved instance spec, when Topology Processor uploading RI bought data to Cost component,
    // Topology Processor will create a local id of this spec, and Cost component needs to change local id
    // to a real id.
    optional int64 id = 1;

    // A wrapper of reserved instance spec fields except reserved instance spec id.
    optional ReservedInstanceSpecInfo reserved_instance_spec_info = 2;
}

// A list of fields which can impact the price of the reserved instance.
message ReservedInstanceSpecInfo {

    // The type of the reserved instance.
    optional common_dto.ReservedInstanceType type = 1;

    // The tenancy of the reserved instance.
    optional common_dto.Tenancy tenancy = 2;

    // The operating system of the reserved instance.
    optional common_dto.OSType os = 3;

    // The entity profile id of the reserved instance using, such as t2.large.
    optional int64 tier_id = 4;

    // The region id of the reserved instance.
    optional int64 region_id = 5;

    // The property that determines if the RI is applicable to workloads running any platform or to
    // the workloads running the same platform as the RI's platform.
    optional bool platform_flexible = 6 [default = false];

    // The property defining whether RI is applicable to workloads in different tiers of the same
    // template family.
    optional bool size_flexible = 7 [default = false];
}

// The RI coverage of a particular entity and projected RI coverage after market.
// A single entity may be partially covered by multiple RI's from the same family.
message EntityReservedInstanceCoverage {
    // The id of the entity.
    optional int64 entity_id = 1;

    // A map of:
    // RI ID -> # coupons covered by the RI for the entity. It is possible for
    // an RI to provide coupons to more than one entity or for an entity to
    // consume coupons from more than one RI.
    //
    // For an explanation of coupons see: TypeSpecificInfo.ComputeTierInfo.
    map<int64, double> coupons_covered_by_ri = 10;

    // The number of coupons of the compute tier on which this entity is residing or it is going to
    // reside on (in case of projected).
    optional int32 entity_coupon_capacity = 11;

    // The number of coupons covered by BuyRI instances. This is applicable to only the projected
    // topology, in which BuyRIImpactAnalysis allocated buy RI instances on the projected topology
    // to estimate potential savings from buy RI recommendations
    map<int64, double> coupons_covered_by_buy_ri = 12;
}

// Message broadcast from the market component representing the after actions/projected
// ri coverage of entities in topology.
message ProjectedEntityReservedInstanceCoverage {
    // The ID of the projected topology the cost is for.
    optional int64 projected_topology_id = 1;

    oneof segment {
        Start start = 2;
        Data data = 3;
        End end = 4;
    }

    // Marker message, declaring the start of the broadcast
    message Start {
        // The basic information of the source topology
        optional .topology.TopologyInfo source_topology_info = 1;
    };

    // Message to hold real data of the entity costs.
    message Data {
        // Some number of projected entity costs.
        repeated EntityReservedInstanceCoverage projected_ris_coverage = 1;
    }

    // Message to appear at the very end of the broadcast
    message End {
        // Total number of costs sent (can be used for integrity checks)
        required uint64 total_count = 1;
    }

}


// A message used to retrieve account expenses.
message GetCurrentAccountExpensesRequest {
    // When scoping to a specific business account / billing family / group of accounts, then
    // "scope" should contain all the relevant account OIDs in specific_accounts.
    // If this is global scope (cloud page) then the scope should be set to all_accounts = true.
    optional AccountExpenseQueryScope scope = 1;
}

message AccountExpenseQueryScope {
    message IdList {
        repeated int64 account_ids = 1;
    }

    // Using a oneof to prevent accidentally asking for "all" with an empty ID list on
    // the client. We've been hit by those bugs multiple times, and each time it's a
    // high-priority performance issue.
    oneof scope {
        // A list of specific account IDs to get expenses for.
        // If the list is empty, returns no expenses.
        IdList specific_accounts = 1;

        // Get expenses for ALL account IDs in the latest uploaded expenses.
        bool all_accounts = 2;
    }
}

// Response to the expense request
message GetCurrentAccountExpensesResponse {
    // The list of account expense.
    // The length of this list will not exceed the limit set in the request pagination parameters.
    // The account expense will be ordered according to the order in the request pagination parameters.
    repeated AccountExpenses account_expense = 1;
}

// A message used to retrieve discounts.
message GetDiscountRequest {
    // A filter to be applied to the discount retrieved. If no filter is supplied
    // all account discounts are returned.
    optional DiscountQueryFilter filter = 1;
}

// A filter to be supplied with discount queries.
message DiscountQueryFilter {
    // Include only discounts in the given associated account id,
    // if asociated account id is not provided, response will be empty.
    repeated int64 associated_account_id = 1;
}

// create discount response
message CreateDiscountResponse {
    optional Discount discount = 1;
}

// delete discount request
message DeleteDiscountRequest {
    oneof id {
        // discount id
        int64 discount_id = 1;

        // it's associated account id
        int64 associated_account_id = 2;
    }
}

// create discount request
message CreateDiscountRequest {
    // associated account id
    optional int64 id = 1;

    // discount info to be created or updated
    optional DiscountInfo discount_info = 2;
}


// update account level discount
message UpdateDiscountRequest {
    oneof id {
        // discount id
        int64 discount_id = 1;

        // it's associated account id
        int64 associated_account_id = 2;
    }

    // discount info to be created or updated
    optional DiscountInfo new_discount_info = 3;
}

// delete discount response
message DeleteDiscountResponse {
    optional bool deleted = 1;
}

// update discount response
message UpdateDiscountResponse {
    optional Discount updated_discount = 1;
}

// delete plan costs request
message DeletePlanEntityCostsRequest {
    optional int64 plan_id = 1;
}

// delete plan entity costs response
message DeletePlanEntityCostsResponse {
    optional bool deleted = 1;
}

// Discount associated with a specific business account.
// Customers negotiate discounts with Cloud Vendors:
// * Enterprise Program Discount [AWS]
// * Enterprise Agreement [Azure]
// Entity costs in Turbonomic should reflect what the customer actually pays.
// All discounts to be entered by user [Cannot be discovered].
// It's one to one mappserviceng between busniess account and discount.
// Discount is assumed on global region basis. We could extend it to support tier-level if needed.
message Discount {
    // The oid for the discount
    optional int64 id = 1;

    // The associated business account oid, it is immutable after creation.
    optional int64 associated_account_id = 2;

    // All supported discount levels, it's editable.
    optional DiscountInfo discount_info = 3;
}

// Each discount info could have account-level, service-levels, and tier-levels.
message DiscountInfo {
    // The display name from user
    optional string display_name = 1;

    // Global level account discount, e.g. 10.0 % on Account A
    optional AccountLevelDiscount account_level_discount = 2;

    // Service level discount, e.g. 10.0 % on all EC2 for Account A
    optional ServiceLevelDiscount service_level_discount = 3;

    // Tier/Template level discount, e.g. 10.0 % on all t2.small for Account A
    optional TierLevelDiscount tier_level_discount = 4;

    message AccountLevelDiscount {
        // The global level discount, e.g. 10.0
        optional double discount_percentage = 1;
    }

    message ServiceLevelDiscount {
        // The service level discount, arranged by service ID, e.g. 111111 -> 10.0
        map<int64, double> discount_percentage_by_service_id = 1;
    }

    message TierLevelDiscount {
        // The Tier/Template level discount, arranged by tier ID, e.g. 2222222 -> 10.0
        map<int64, double> discount_percentage_by_tier_id = 1;
    }
}

// The Cloud entity cost. It can store calculated or predicted (from Market to Cost component)
// entity cost, help persist to DB, and help calculate cost from REST API requests.
message EntityCost {
    // The associated entity oid for the Cloud entity.
    optional int64 associated_entity_id = 1;

    // list of component costs, e.g. Compute and Storage costs.
    repeated ComponentCost component_cost = 2;

    // A pre-calcuated hourly total entity cost for speeding up calculation.
    // It's the summation of the list of component costs.
    optional common_dto.CurrencyAmount total_amount = 3;

    // The associated entity type, e.g. vm, app
    optional int32 associated_entity_type = 4;

    message ComponentCost {
        // Cost type represents the possible breakdown of an entity cost into separate components
        // Like Compute, Storage, licensing and so on.
        optional CostCategory category = 1;

        // Hourly rate for Cloud entity
        optional common_dto.CurrencyAmount amount = 2;

        optional CostSource costSource = 3;
    }
}

// This is the actual message that gets sent across the wire when broadcasting per-entity projected
// costs.
message ProjectedEntityCosts {
    // The ID of the projected topology the cost is for.
    optional int64 projected_topology_id = 1;

    oneof segment {
        Start start = 2;
        Data data = 3;
        End end = 4;
    }

    // Marker message, declaring the start of the broadcast
    message Start {
        // The basic information of the source topology
        optional .topology.TopologyInfo source_topology_info = 1;
    };

    // Message to hold real data of the entity costs.
    message Data {
        // Some number of projected entity costs.
        repeated EntityCost entity_costs = 1;
    }

    // Message to appear at the very end of the broadcast
    message End {
        // Total number of costs sent (can be used for integrity checks)
        required uint64 total_count = 1;
    }
}

// Cost category represents the possible breakdown of an entity cost into separate components
// like Compute, Network, Storage, licensing and so on.
// As we increase support for more breakdowns this enum will be extended to support them.
// It's closely matched with the legacy definition in
// com.vmturbo.platform.VMTRoot.ManagedEntities.Abstraction.CostType class.
enum CostCategory {
    // Compute cost of an entity = On_Demand_Compute cost + Ri_compute cost

    // Represents the on-demand compute cost associated with an entity.
    // For example the cost of a cloud template or for the CPU and memory resources
    // Business Account discount is already applied to this cost.
    ON_DEMAND_COMPUTE = 0;

    // Represents the storage cost associated with an entity.
    // For example the cost of a cloud 100 GB storage
    STORAGE = 1;

    // Represents the additional IP address related costs associated with an entity.
    // For example cost of a static IP.
    IP = 2;

    // Represents the licensing related costs associated with an entity.
    // For example OS pricing, application licensing, DB licenses and so on.
    ON_DEMAND_LICENSE = 3;

    // Represents the RI compute cost associated with an entity.
    // i.e. how much of the total entity compute cost is being contributed by RI.
    // Business Account discount is already applied to this cost.
    RI_COMPUTE = 4;

    // Represents the spot instance cost associated with an entity.
    SPOT = 5;

    // Represents the license costs associated with the RI coverage of a workload
    RESERVED_LICENSE = 6;

}

// The cost source represents the source of the cost in the cost category. For example the on Demand Compute cost
// may have an on demand rate source and an RI discounted rate source.
enum CostSource {

    ON_DEMAND_RATE = 1;

    RI_INVENTORY_DISCOUNT = 2;

    BUY_RI_DISCOUNT = 3;

    UNCLASSIFIED = 4;
}

// A request containing a snapshot of cost data to be stored by the cost service.
message UploadAccountExpensesRequest {
    // the checksum of the data in this request
    optional int64 checksum = 10;

    // the time the request was created
    optional int64 created_time = 11;

    // the topology id this upload is associated with. It will always be a realtime topology.
    optional int64 topology_id = 1;

    // Business Account expenses
    repeated AccountExpenses account_expenses = 2;
}

message UploadAccountExpensesResponse {
}

// A request containing a snapshot of cost data to be stored by the cost service.
message UploadRIDataRequest {
    // the checksum of the data in this request
    optional int64 checksum = 10;

    // the time the request was created
    optional int64 created_time = 11;

    // the topology id this upload is associated with. It will always be a realtime topology.
    optional int64 topology_id = 1;

    // The set of Reserved Instance configurations that have been purchased or are available.
    repeated ReservedInstanceSpec reserved_instance_specs = 3;

    // The set of RI bought by the customer.
    repeated ReservedInstanceBought reserved_instance_bought = 4;

    // The entity - RI coverage data
    repeated EntityRICoverageUpload reserved_instance_coverage = 5;

    // Contains the relationship about which service entity is covered by what reserved instance and
    // how many coupons are covered by each different reserved instance.
    //
    // This is the message used during the "upload" stage - when the Topology Processor uploads
    // the billing data it discoveres to the cost component.
    message EntityRICoverageUpload {
        // The id of entity.
        optional int64 entity_id = 1;

        // The total number of coupons this entity needs.
        // This is mainly used to calculate how much of the entity is being
        // covered by the various reserved instances.
        //
        // This should be less than or equals to the sum of "coverage.covered_coupons".
        optional double total_coupons_required = 2;

        // The reserved instance coverage of this entity, which one entity could use a list of reserved
        // instance.
        repeated Coverage coverage = 3;

        message Coverage {
            //Enumeration defining the sources which contribute to RI coverage for an entity.
            enum RICoverageSource {
                //Indicates that the RI Coverage information for an entity comes from the bill.
                BILLING = 0;

                //Indicates that the RI Coverage information for an entity comes from other sources such as the RI Allocator.
                SUPPLEMENTAL_COVERAGE_ALLOCATION = 1;
            }

            // The id of reserved instance.
            optional int64 reserved_instance_id = 1;

            // The reserved instance id of probe send out, we use it to tell if two reserved instance bought
            // are same or not.
            optional string probe_reserved_instance_id = 2;

            // The number of coupons covered by the reserve instance.
            optional double covered_coupons = 3;

            // The RI Coverage source for the entity
            optional RICoverageSource ri_coverage_source = 4;
        }
    }
}


message UploadRIDataResponse {
}

message GetAccountExpensesChecksumRequest {
}

message GetRIDataChecksumRequest {
}

message ChecksumResponse {
    optional int64 checksum = 1;
}

message RegionFilter {
    // A list of region ids need to filter by.
    repeated int64 region_id = 1;
}

message AvailabilityZoneFilter {
    // A list of availability zone ids need to filter by.
    repeated int64 availability_zone_id = 1;
}

message AccountFilter {
    // A list of account ids need to filter by.
    repeated int64 account_id = 1;
}

message EntityFilter {
    // A list of entity ids need to filter by.
    repeated int64 entity_id = 1;
}

message EntityTypeFilter {
    // A list of entity type need to filter by. E.g. App or VM
    repeated int32 entity_type_id = 1;
}

message ReservedInstanceBoughtFilter {
    optional bool exclusion_filter = 1 [default = false];
    repeated int64 ri_bought_id = 2;
}

// A request to get reserved instance bought by some filter condition. If provided more than one
// different filter type, it will perform AND logic.
message GetReservedInstanceBoughtByFilterRequest {
    optional RegionFilter region_filter = 1;
    optional AvailabilityZoneFilter zone_filter = 2;
    optional AccountFilter account_filter = 3;
}

// A response contains a list reserved instance bought.
message GetReservedInstanceBoughtByFilterResponse {
    // A list of reserved instance bought.
    repeated ReservedInstanceBought reserved_instance_boughts = 1;
}

message GetReservedInstanceBoughtByTopologyRequest {

    // If a topology context ID is not specified, the realtime context ID will be used to
    // resolve RIs in scope
    optional int64 topology_context_id = 1;
    optional .topology.TopologyType topology_type = 2;
    optional int32 scope_entity_type = 3;
    repeated int64 scope_seed_oids = 4;
}

// A response contains a list reserved instance bought.
message GetReservedInstanceBoughtByTopologyResponse {
    // A list of reserved instance bought.
    repeated ReservedInstanceBought reserved_instance_bought = 1;
}

// A request to get Buy reserved instances by some filter condition. If there is more than one
// filter type, it will consider all of them and perform AND logic.
message GetBuyReservedInstancesByFilterRequest {
    // get buy reserved instance recommendations filter by topology context id
    optional int64 topology_context_id = 1;

    // get buy reserved instance recommendations filter by region ids.
    optional RegionFilter region_filter = 2;

    // get buy reserved instance recommendations filter by account ids.
    optional AccountFilter account_filter = 3;

    // buy ri ids.
    repeated int64 buy_ri_id = 4;
}

// A response contains a list of buy RIs represented as reserved instance bought.
message GetBuyReservedInstancesByFilterResponse {
    // A list of buy RIs represented as reserved instance bought.
    repeated ReservedInstanceBought reserved_instance_boughts = 1;
}

// A request to get reserved instance bought count map.
message GetReservedInstanceBoughtCountRequest {
    // get reserved instance bought filter by region ids.
    optional RegionFilter region_filter = 1;

    // get reserved instance bought filter by availability zone ids.
    optional AvailabilityZoneFilter availability_zone_filter = 2;

    // get reserved instance bought filter by account ids.
    optional AccountFilter account_filter = 3;
}

// A response which contains the reserved instance count map.
message GetReservedInstanceBoughtCountResponse {
    // A map which key is computer tier id, the value is the count of reserved instance bought.
    map<int64, int64> reserved_instance_count_map = 1;
}

// Response contains ri bought count map by tier id
message GetReservedInstanceBoughtCountByTemplateResponse {
    // A map where key is the tier id and value is the number of the RIs bought for the tier id
    map<int64, int64> reserved_instance_count_map = 1;
}

// A request to get plan reserved instance bought count map.
message GetPlanReservedInstanceBoughtCountRequest {
    // get reserved instance bought filter by plan id.
    optional int64 plan_id = 1;
}

// Response contains plan ri bought count map by tier name
message GetPlanReservedInstanceBoughtCountByTemplateResponse {
    // A map where key is the tier id and value is the number of the RIs bought for the tier id
    map<string, int64> reserved_instance_count_map = 1;
}

// A request to get reserved instance bought by some filter condition. If both region
// and availability zone filters are provided, they will be OR'd. EIther filter
// will be AND'd with the account filter (if configured)
message GetPlanReservedInstanceBoughtRequest {
    optional int64 planId = 1;
}

// A request to get RI cost stats for both current and projected RIs.
message GetPlanReservedInstanceCostStatsRequest {
    optional int64 planId = 1;
    // if include buyRI = true - add ri Buy recommendation data to projected snapshot.
    optional bool include_buy_ri = 2 [default = false];
}

// A response with RIs cost stats.
message GetPlanReservedInstanceCostStatsResponse {
    repeated ReservedInstanceCostStat stats = 1;
}

// A request to get reserved instance specs
message GetReservedInstanceSpecByIdsRequest {
    // A list of reserved instance specs id need to retrieve.
    // If provide a empty spec ids list, it will return empty results.
    repeated int64 reserved_instance_spec_ids = 1;
}

// A response of a list of reserved instance specs.
message GetReservedInstanceSpecByIdsResponse {
    // A list of reserved instance spec.
    repeated ReservedInstanceSpec reserved_instance_spec = 1;
}

// A request to get reserved instance utilization stats
message GetReservedInstanceUtilizationStatsRequest {
    // The start date of the request
    optional uint64 start_date = 1;

    // The end date of the request
    optional uint64 end_date = 2;

    // get reserved instance utilization stats filter by region ids.
    optional RegionFilter region_filter = 3;

    // get reserved instance utilization stats filter by availability zone ids.
    optional AvailabilityZoneFilter availability_zone_filter = 4;

    // get reserved instance utilization stats filter by account ids.
    optional AccountFilter account_filter = 5;

    // whether utilization of Buy RI instances should be included in the
    // projected utilization stats returned
    optional bool include_buy_ri_utilization = 6 [default = false];

    // get reserved instance utilization stats by topology context id
    optional uint64 topology_context_id = 7;

}

// A response of reserved instance utilization stats.
message GetReservedInstanceUtilizationStatsResponse {
    // A list of reserved instance utilization stats records.
    repeated ReservedInstanceStatsRecord reserved_instance_stats_records = 1;
}

// A request to get reserved instance coverage stats.
message GetReservedInstanceCoverageStatsRequest {
    // The start date of the request.
    optional uint64 start_date = 1;

    // The end date of the request.
    optional uint64 end_date = 2;

    // get reserved instance bought filter by region ids.
    optional RegionFilter region_filter = 3;

    // get reserved instance bought filter by availability zone ids.
    optional AvailabilityZoneFilter availability_zone_filter = 4;

    // get reserved instance bought filter by account ids.
    optional AccountFilter account_filter = 5;

    optional EntityFilter entity_filter = 6;

    // whether coverage from BuyRI instances should be included in the
    // projected coverage stat returned.
    optional bool include_buy_ri_coverage = 7 [default = false];

    // get reserved instance coverage stats by topology context id
    optional uint64 topology_context_id = 8;
}

// A response of reserved instance coverage stats.
message GetReservedInstanceCoverageStatsResponse {
    // A list of reserved instance coverage stats records.
    repeated ReservedInstanceStatsRecord reserved_instance_stats_records = 1;
}

// A reserved instance stats record represents the stats (avg,max,min,total) value at a timestamp point.
message ReservedInstanceStatsRecord {
    // The actual snapshot_date for this stats record.
    optional int64 snapshot_date = 1;

    // The capacity value of this stats record.
    optional StatValue capacity = 2;

    // The used value of this stats record.
    optional StatValue values = 3;

    // Contains the detail value of stats record, such as, max, min, avg, total value.
    message StatValue {
        optional float max = 1;
        optional float min = 2;
        optional float avg = 3;
        optional float total = 4;
    }
}

// A request to get bottom up Cloud cost stats
message GetCloudExpenseStatsRequest {
    // The start date of the request
    optional uint64 start_date = 1;

    // The end date of the request
    optional uint64 end_date = 2;

    // Entity ids filter, return all entities if not set
    optional EntityFilter entity_filter = 3;

    // Entity type filter, could be VM or APP, return all entities if not set
    optional EntityTypeFilter entity_type_filter = 4;

    // A property names to aggregate stats over, as in an SQL 'group by' clause.
    optional GroupByType group_by = 5;

    // When scoping to a specific business account / billing family / group of accounts, then
    // "scope" should contain all the relevant account OIDs in specific_accounts.
    // If this is global scope (cloud page) then the scope should be set to all_accounts = true.
    optional AccountExpenseQueryScope scope = 6;

    enum GroupByType {
        // Cloud service provider
        CSP = 1;

        // Business Account
        BUSINESS_UNIT = 2;

        // Cloud Service
        CLOUD_SERVICE = 3;
    }
}

message CostCategoryFilter {
    optional bool exclusion_filter = 1 [default = false];
    repeated CostCategory cost_category = 2;
}

// A request to get bottom up Cloud cost stats
message GetCloudCostStatsRequest {

    repeated CloudCostStatsQuery cloud_cost_stats_query = 1;
}

message CloudCostStatsQuery {

    // The start date of the request
    // If the start date is set and the end date is not set, we will only get the latest stats.
    optional int64 query_id = 1;

    // The end date of the request
    // If the end date is set and the start date is not set, we will only get the latest stats.
    optional uint64 start_date = 2;

    // Entity ids filter, return all entities if not set
    optional uint64 end_date = 3;

    // Whether or not to request projected bottom-up costs.
    //
    // Note - this will add the projected stats to any historical stats specified by the
    // start_date and end_date parameters. There is no way to get ONLY the projected stats.
    optional bool request_projected = 4;

    // Entity ids filter, return all entities if not set
    optional EntityFilter entity_filter = 5;

    // Cost category filter, return all entities if not set
    optional CostCategoryFilter cost_category_filter = 6;

    // Entity type filter, could be VM or APP, return all entities if not set
    optional EntityTypeFilter entity_type_filter = 7;

    // A property names to aggregate stats over, as in an SQL 'group by' clause.
    repeated GroupBy group_by = 8;

    // Filter associated cost based on its source, return cost from all sources if empty.
    optional CostSourceFilter cost_source_filter = 9;

    // get entity cost filtered by region ids.
    optional RegionFilter region_filter = 10;

    // get entity cost filtered by availability zone ids.
    optional AvailabilityZoneFilter availability_zone_filter = 11;

    // get entity cost filtered by account ids.
    optional AccountFilter account_filter = 12;

    // get entity cost filter by topology context id
    optional uint64 topology_context_id = 13;

    enum GroupBy {
        COST_CATEGORY = 1;
        ENTITY = 2;
        ENTITY_TYPE = 3;
    }

    // The filter used for filtering cost items in a cost query.
    message CostSourceFilter {
        // If true the cost sources specified will be excluded. If false, only the cost items that are
        // in cost sources will be returned.
        optional bool exclusion_filter = 1 [default = false];
        // The cost source types that will be used for filtering based on the exclusion filter.
        repeated CostSource cost_sources = 2;
    }
}

// Bottom up Cloud cost stats response
message GetCloudCostStatsResponse {
    // The returned stats are in sorted order(increasing order) of the snapshot date
    // i.e. from earlier to the latest date.
    repeated CloudCostStatRecord cloud_stat_record = 1;
}

// Cloud cost stat record, used for both top down and bottom up
message CloudCostStatRecord {
    // the actual snapshot_date for this response
    optional int64 snapshot_date = 1;

    // the individual stat_records collected
    repeated StatRecord stat_records = 2;

    //this the query id used in CloudCostStatsQuery to uniquely identity a query in the list.
    optional uint64 query_id = 3;

    // an individual stats value.
    message StatRecord {

        // name of the stat, e.g. costPrice
        optional string name = 1;

        // units suffix for this commodity
        optional string units = 2;

        // The associated entity oid for the Cloud entity.
        optional int64 associated_entity_id = 3;

        // The associated entity type, e.g. vm, app
        optional int32 associated_entity_type = 4;

        // Cost category, E.g. Computer, IP,
        optional CostCategory category = 5;

        // Stat value
        optional StatValue values = 7;

        // Contains the detail value of stats record, such as, max, min, avg, total value.
        message StatValue {
            optional float max = 1;
            optional float min = 2;
            optional float avg = 3;
            optional float total = 4;
        }
    }
}

// A request to set a new interval for buy RI scheduler.
message SetBuyRIAnalysisScheduleRequest {
    // The new interval in hours.
    optional uint64 interval_hours = 1;
}

// A response of setting a new interval of buy RI scheduler.
message SetBuyRIAnalysisScheduleResponse {
    // The new interval in hours.
    optional uint64 interval_hours = 1;
}

message GetEntityReservedInstanceCoverageRequest {
    // Filter by a list of Entities.
    optional EntityFilter entity_filter = 1;
}

message GetEntityReservedInstanceCoverageResponse {
    // A map from entity ID to the reserved instance coverage for that entity.
    map<int64, EntityReservedInstanceCoverage> coverage_by_entity_id = 1;
}

message GetProjectedEntityReservedInstanceCoverageRequest {
    // Filter by a list of Entities.
    optional EntityFilter entity_filter = 1;
}

message GetProjectedEntityReservedInstanceCoverageResponse {
    // A map from entity ID to the reserved instance coverage for that entity.
    map<int64, EntityReservedInstanceCoverage> coverage_by_entity_id = 1;
}

message StartBuyRIAnalysisRequest {
    // the topology info
    optional .topology.TopologyInfo topologyInfo = 1;

    // the list of platforms to analyze buy RI
    repeated common_dto.OSType platforms = 2;

    // the list of regions to analyze buy RI
    repeated int64 regions = 3;

    // the list of tenancies to analyze buy RI
    repeated common_dto.Tenancy tenancies = 4;

    // the list of business accounts to analyze buy RI
    repeated int64 accounts = 5;

    // the RI purchase profile
    optional RIPurchaseProfile purchaseProfile = 6;

    // the demand type
    optional common_dto.DemandType demandType = 7;
}

message GetTierPriceForEntitiesRequest{
    optional int64 oid = 1;
    optional CostCategory costCategory = 2;
}

message GetTierPriceForEntitiesResponse{
    map <int64, common_dto.CurrencyAmount> before_tier_price_by_entity_oid = 1;
    map <int64, common_dto.CurrencyAmount> after_tier_price_by_entity_oid = 2;
}


// the RI purchase profile for buy RI recommendations
message RIPurchaseProfile {
    // the reserved instance type. The type of RIs which will be suggested in the Buy RI results
    optional common_dto.ReservedInstanceType riType = 1;
}

message StartBuyRIAnalysisResponse {
}

message GetRIBuyContextRequest {
    optional string actionId = 1;
}

message DeleteRIBuyContextDataRequest {
    optional int64 topologyContextId = 1;
}

message DeleteRIBuyContextDataResponse {
    optional bool deleted = 1;
}

message DeletePlanReservedInstanceStatsRequest {
    optional int64 topologyContextId = 1;
}

message DeletePlanReservedInstanceStatsResponse {
    optional bool deleted = 1;
}

// A service for getting reserved instance bought
service ReservedInstanceBoughtService {
    // Get reserved instance bought by some filter condition, such as filter by region, availability zones
    // or account.
    // TODO (roman, Oct 18 2018): We should have an option in the RIBought request
    // to include spec definitions.
    rpc GetReservedInstanceBoughtByFilter(GetReservedInstanceBoughtByFilterRequest) returns
    (GetReservedInstanceBoughtByFilterResponse);

    rpc GetReservedInstanceBoughtByTopology(GetReservedInstanceBoughtByTopologyRequest) returns
        (GetReservedInstanceBoughtByTopologyResponse);

    // Get reserved instance count in the users inventory by template type
    rpc GetReservedInstanceBoughtCountByTemplateType(GetReservedInstanceBoughtCountRequest) returns
    (GetReservedInstanceBoughtCountByTemplateResponse);

    // Get the reserved instance bought count map which key is computer tier id, value is the count of
    // reserved instance bought.
    rpc GetReservedInstanceBoughtCount(GetReservedInstanceBoughtCountRequest) returns
    (GetReservedInstanceBoughtCountResponse);
}

// A service for getting reserved instance spec.
service ReservedInstanceSpecService {
    // Get the reserved instance spec by a list of spec id.
    rpc GetReservedInstanceSpecByIds(GetReservedInstanceSpecByIdsRequest) returns (GetReservedInstanceSpecByIdsResponse);
}

// A service for getting Buy RIs
service BuyReservedInstanceService {
    // Get buy RIs by some filter condition, such as filter by topology context id, region, business account.
    rpc GetBuyReservedInstancesByFilter(GetBuyReservedInstancesByFilterRequest) returns
    (GetBuyReservedInstancesByFilterResponse);
}

// A service for reserved instance utilization and coverage stats.
service ReservedInstanceUtilizationCoverageService {
    // Get the reserved instance utilization stats.
    rpc GetReservedInstanceUtilizationStats(GetReservedInstanceUtilizationStatsRequest)
    returns(GetReservedInstanceUtilizationStatsResponse);

    // Get the reserved instance coverage stats.
    rpc GetReservedInstanceCoverageStats(GetReservedInstanceCoverageStatsRequest)
    returns(GetReservedInstanceCoverageStatsResponse);

    // Get the per-entity RI coverage information - how much of an entity is covered by which RIs.
    rpc GetEntityReservedInstanceCoverage(GetEntityReservedInstanceCoverageRequest) returns
    (GetEntityReservedInstanceCoverageResponse);

    // Get the projected reserved instance coverage stats.
    rpc GetProjectedEntityReservedInstanceCoverageStats(GetProjectedEntityReservedInstanceCoverageRequest)
    returns(GetProjectedEntityReservedInstanceCoverageResponse);
}

// A service for buy reserved instance analysis.
service BuyRIAnalysisService {
    // Set a new interval for buy RI analysis schedule. Note that this will
    // trigger buy RI analysis immediately.
    rpc SetBuyRIAnalysisSchedule(SetBuyRIAnalysisScheduleRequest)
    returns (SetBuyRIAnalysisScheduleResponse);

    rpc StartBuyRIAnalysis(StartBuyRIAnalysisRequest) returns (StartBuyRIAnalysisResponse);
}

// A service for getting plan reserved instance
service PlanReservedInstanceService {
    // Get reserved instance bought by some filter condition, such as filter by region, availability zones
    // or account.
    rpc GetPlanReservedInstanceBought(GetPlanReservedInstanceBoughtRequest) returns
    (GetReservedInstanceBoughtByFilterResponse);

    // Get reserved instance count in the users inventory by template type for the plan
    rpc GetPlanReservedInstanceBoughtCountByTemplateType(GetPlanReservedInstanceBoughtCountRequest) returns
    (GetPlanReservedInstanceBoughtCountByTemplateResponse);

    // Delete plan reserved instance stats
    rpc DeletePlanReservedInstanceStats(DeletePlanReservedInstanceStatsRequest) returns
    (DeletePlanReservedInstanceStatsResponse);

    // Get plan reserved instance cost stats
    rpc GetPlanReservedInstanceCostStats(GetPlanReservedInstanceCostStatsRequest) returns
    (GetPlanReservedInstanceCostStatsResponse);
}

// A service responsible for getting information about cost information in Cloud.
service CostService {

    rpc GetTierPriceForEntities (GetTierPriceForEntitiesRequest) returns (GetTierPriceForEntitiesResponse);

    // Get account discounts by associated account ids
    rpc GetDiscounts(GetDiscountRequest) returns (stream Discount);

    // Create a discount for given associated account id and info
    rpc CreateDiscount(CreateDiscountRequest) returns (CreateDiscountResponse);

    // Delete a discount for a given associated account id
    rpc DeleteDiscount(DeleteDiscountRequest) returns (DeleteDiscountResponse);

    // Update a discount for given discount id and info
    //
    // Returns NOT_FOUND if the discount id or discount info is not found
    rpc UpdateDiscount(UpdateDiscountRequest) returns (UpdateDiscountResponse);

    // Get bottom up Cloud cost stats
    rpc GetCloudCostStats(GetCloudCostStatsRequest) returns (GetCloudCostStatsResponse);

    // Get information about account expense
    rpc GetAccountExpenseStats(GetCloudExpenseStatsRequest) returns (GetCloudCostStatsResponse);

    rpc GetCurrentAccountExpenses(GetCurrentAccountExpensesRequest) returns (GetCurrentAccountExpensesResponse);

    // Delete plan entity costs
    rpc DeletePlanEntityCosts(DeletePlanEntityCostsRequest) returns (DeletePlanEntityCostsResponse);
}

// Stats Request Time Window with options for start_date and end_date.
message StatsRequestTimeWindow {
    message TimeWindow {
        optional int64 start_date = 1;
        optional int64 end_date = 2;
    }

    optional TimeWindow time_window = 1;
    // if query_latest = true send bought RI info with current snapshot time. if false no current snapshot data is sent
    optional bool query_latest = 2 [default = false];
}

// projectedRI = true && include buy RI = true - send projected snapshopt with bought RI info + ri buy info
// projectedRI = true && include buy RI = false - send projected snapshot with bought RI info only.
// projectedRI = false && include buy RI = true - do not send projected snapshot info.
// projectedRI = false && include buy RI = false - do not send projected snapshot info.

message GetReservedInstanceCostStatsRequest {
    optional StatsRequestTimeWindow time_window = 1;
    // if include projected = true - build projected snapshot with latest bought RI info
    optional bool include_projected = 2 [default = false];
    // if include buyRI = true - add ri Buy recommendation data to projected snapshot.
    optional bool include_buy_ri = 3 [default = false];

    // get buy reserved instance recommendations filter by topology context id
    optional int64 topology_context_id = 4;

    // get buy reserved instance recommendations filter by region ids.
    optional RegionFilter region_filter = 5;

    // ggetTierPriceForEntitieset buy reserved instance recommendations filter by account ids.
    optional AccountFilter account_filter = 6;

    optional AvailabilityZoneFilter availability_zone_filter = 7;

    optional GroupBy group_by = 8;

    enum GroupBy {
        // if GroupBY = NONE, you will get individual costs for RIs in scope.
        NONE = 0;
        // if GroupBy = Snapshot, you will get aggregated costs of all RIs in scope.
        SNAPSHOT_TIME = 1;
    }
}

message GetReservedInstanceCostStatsResponse {
    repeated ReservedInstanceCostStat stats = 1;
}

// Structure representing the RI Cost Stat obtained from ReservedInstanceCostService.
message ReservedInstanceCostStat {
    // Snapshot time for the requested stat
    required uint64 snapshot_time = 1;
    // RI oid. Will be null if request is grouped by SNAPSHOT_TIME.
    optional int64 reserved_instance_oid = 2;
    // Total RI Fixed Cost. This cost takes the number of RIs of a specific type into account. (count * individualRIFixedCost)
    optional double fixed_cost = 3;
    // Total RI Recurring Cost. This cost takes the number of RIs of a specific type into account. (count * individualRIRecurringCost)
    optional double recurring_cost = 4;
    // Total RI Amortized Cost. This cost takes the number of RIs of a specific type into account. (count * individualRIAmortizedCost)
    optional double amortized_cost = 5;
}

// A service responsible for getting the RI Cost Stats for both current and projected RIs.
service ReservedInstanceCostService {
    rpc GetReservedInstanceCostStats(GetReservedInstanceCostStatsRequest) returns (GetReservedInstanceCostStatsResponse);
}

service RIAndExpenseUploadService {
    rpc UploadAccountExpenses(UploadAccountExpensesRequest) returns (UploadAccountExpensesResponse);

    rpc GetAccountExpensesChecksum(GetAccountExpensesChecksumRequest) returns (ChecksumResponse);

    rpc UploadRIData(UploadRIDataRequest) returns (UploadRIDataResponse);

    rpc GetRIDataChecksum(GetRIDataChecksumRequest) returns (ChecksumResponse);
}

message riBuyDemandStats {
    // the actual snapshot_date for this response
    optional uint64 snapshot_date = 1;

    repeated stats.StatSnapshot statSnapshots = 2;
}

service RIBuyContextFetchService {
    // Get buy RIs by some filter condition, such as filter by topology context id, region, business account.
    rpc GetRIBuyContextData(GetRIBuyContextRequest) returns (riBuyDemandStats);

    // Deletes the data corresponding to context topology id from action_context table.
    rpc DeleteRIBuyContextData(DeleteRIBuyContextDataRequest)
        returns (DeleteRIBuyContextDataResponse);
}
