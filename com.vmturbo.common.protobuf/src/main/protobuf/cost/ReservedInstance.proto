syntax = "proto2";
package cost;

option java_package = "com.vmturbo.common.protobuf.cost";

// A reserved instance is a reservation of resources and capacity and it provides a significant
// discount compared to on-demand instances. And it is reserved instance bought by user account.
message ReservedInstance {
    // The id of the reserved instance.
    optional int64 id = 1;

    // The properties describe the reserved instance. Set the field tag to 10, in case of we need to
    // add more properties later.
    optional ReservedInstanceInfo reserved_instance_info = 10;

    // Information describing the reserved instance. And it is not editable by the user, all the
    // reserved instance information are discovered by cloud probe.
    message ReservedInstanceInfo {
        // The business account id of the reserved instance.
        optional int64 business_account_id = 1;

        // The start milliseconds since epoch.
        optional int64 start_time = 2;

        // The number of instances bought of the reserved instance.
        optional int32 num_bought = 3;

        // The availability zone of the reserved instance. It will only be set if the reserved instance
        // was made in a specific availability zone. Otherwise, it is local to a region, and the region
        // id in reserved instance spec will be set.
        optional int64 availability_zone_id = 4;

        // The id of reserved instance spec which this reserved instance refer to.
        optional int64 reserved_instance_spec = 5;

        // The cost of the reserved instance. It is the cost that user account payed when user bought this
        // reserved instance, it might be different from the current reserved instance cost.
        optional ReservedInstanceCost reserved_instance_cost = 6;

        // The coupons information of the reserved instance.
        optional ReservedInstanceCoupons reserved_instance_coupons = 7;

        message ReservedInstanceCost {
            // The upfront one-time cost of the Reserved Instance.
            optional double fixed_cost = 1;

            // Hourly cost for usage, e.g. licensing fee.
            optional double usage_cost_per_hour = 2;

            // Hourly cost for reserved instance, regardless of usageCost.
            optional double recurring_cost_per_hour = 3;
        }

        // Coupons is a our internal way compare different instance types in a family. For example,
        // in AWS, they defined Normalization Factor (NFU) for different instance size:
        // https://aws.amazon.com/blogs/aws/new-instance-size-flexibility-for-ec2-reserved-instances/
        // In our internal mode, we defined the coupon is equal to NFU * 4, in this case, the smallest
        // unit is 1. And for reserved instances, it will sell coupons, and other service entity can
        // buy coupons from reserved instances, in this way, we can solve instance size flexibility
        // for reserved instances.
        message ReservedInstanceCoupons {
            // The total couponse of the reserved instance. And it is equal to
            // number of instances bought * number of coupons per instance. For each instance type,
            // its coupons is equal to its NFU * 4.
            optional int32 number_of_coupons = 1;

            // The number of coupons has been used by service entity. This number should be calculated
            // from EntityReservedInstanceCoverage, it should be equal to the sum of its consumers
            // coupons. The SDK probe will not set this field when discovering real time topology.
            optional double number_of_coupons_used = 2;
        }
    }
}

// A group fields, if any one of them changed, the reserved instance will also be changed.
message ReservedInstanceSpec {
    // The id of reserved instance spec, when Topology Processor uploading RI bought data to Cost component,
    // Topology Processor will create a local id of this spec, and Cost component needs to change local id
    // to a real id.
    optional int64 id = 1;

    // The type of the reserved instance.
    optional ReservedInstanceType type = 2;

    // The tenancy of the reserved instance.
    optional Tenancy tenacy = 3;

    // The operating system of the reserved instance.
    optional OS os = 4;

    // The entity profile id of the reserved instance using, such as t2.large.
    optional int64 tier_id = 5;

    // The region id of the reserved instance.
    optional int64 region_id = 6;

    // Identifies the type of "reservation" for the instance, and the
    // payment conditions.
    message ReservedInstanceType {
        enum OfferingClass {
            STANDARD = 1;
            CONVERTIBLE = 2;
        }
        enum PaymentOption {
            ALL_UPFRONT = 1;
            PARTIAL_UPFRONT = 2;
            NO_UPFRONT = 3;
        }

        // The type of offering.
        optional OfferingClass offering_class = 1;

        // The payment option for this reserved instance.
        optional PaymentOption payment_option = 2;

        // The term, in years.
        optional uint32 term_years = 3;
    }
}

// The tenancy of an instance defines what hardware the instance is running on.
enum Tenancy {
    // Instance runs on shared/default hardware.
    // This is typically the cheapest option.
    DEFAULT = 1;

    // Instance runs on single-tenant hardware.
    // That means your instance runs on a host that's separate from other customers,
    // but the host details are abstracted away, and you're not paying for the whole host.
    DEDICATED = 2;

    // Instance runs on a dedicated Host.
    // This means your instance runs on a specific host, and you are paying for the full host and
    // are responsible for managing it.
    HOST = 3;
}

// The supported operating systems.
enum OS {
    UNKNOWN_OS = 0;

    // Unix OS.
    LINUX = 2;
    SUSE = 3;
    RHEL = 4;

    // Windows OS.
    WINDOWS = 20;
    WINDOWS_WITH_SQL_STANDARD = 21;
    WINDOWS_WITH_SQL_WEB = 22;
    WINDOWS_WITH_SQL_ENTERPRISE = 23;
    WINDOWS_BYOL = 24;
}

// Contains the relationship about which service entity is covered by what reserved instance and
// how many coupons are covered by each different reserved instance.
message EntityReservedInstanceCoverage {
    // The id of entity.
    optional int64 entity_id = 1;

    // The total coupons of this entity can sold.
    optional double total_coupons = 2;

    // The reserved instance coverage of this entity, which one entity could use a list of reserved
    // instance.
    repeated Coverage coverage = 3;

    message Coverage {
        // The id of reserved instance.
        optional int64 reserved_instance_id = 1;
        // The number of coupons covered by the reserve instance.
        optional double covered_coupons = 2;
    }
}