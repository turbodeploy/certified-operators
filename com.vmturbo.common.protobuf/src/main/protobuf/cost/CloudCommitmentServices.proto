syntax = "proto2";
package cloud_commitment;

option java_package = "com.vmturbo.common.protobuf.cloud";
option java_outer_classname = "CloudCommitmentServices";

import "cloud/CloudCommitmentDTO.proto";
import "cloud/CloudCommon.proto";
import "topology/TopologyDTO.proto";

message CloudCommitmentData {
    repeated CloudCommitmentDataBucket utilization_data = 1;
    repeated CloudCommitmentDataBucket coverage_data = 2;

    // container for coverage ***OR*** utilization data points from a particular time
    message CloudCommitmentDataBucket {
        // The timestamp is expected to conform to the granularity and will be truncated to match.
        // For example, with daily granularity, any time passed 00:00:00 will truncated.
        optional int64 timestamp_millis = 1;
        repeated CloudCommitmentDataPoint sample = 2;
        optional cloud_common.CloudStatGranularity granularity = 6;

        // one sample of cloud commitment coverage ***OR*** utilization data
        message CloudCommitmentDataPoint {
            optional int64 commitment_id = 1;
            // entity to which the commitment applies
            optional int64 entity_id = 2;
            // service to which the commitment applies
            optional int64 cloud_service_id = 3;
            // region to which the commitment applies
            optional int64 region_id = 4;

            optional int64 account_id = 5;

            optional int64 service_provider_id = 6;

            // must be populated or else this object has no meaning at all. both fields must
            // use the same unit(coupons or CurrencyAmount).
            optional cloud_commitment_dto.CloudCommitmentAmount used = 7;
            optional cloud_commitment_dto.CloudCommitmentAmount capacity = 8;
        }
    }
}

message UploadCloudCommitmentDataRequest {
    optional CloudCommitmentData cloud_commitment_data = 1;
}

message UploadCloudCommitmentDataResponse {
    // empty message
}

message GetHistoricalCloudCommitmentUtilizationRequest {

    // The start_time (inclusive) and end_time (exclusive), represented as milliseconds since epoch in UTC,
    // are the window in which utilization stats should be queried. If start_time is not set, stats
    // since epoch are returned. If end_time is not set, stats up until current are returned.
    optional uint64 start_time = 1;
    optional uint64 end_time = 2;

    optional cloud_common.CloudStatGranularity granularity = 3 [default = HOURLY];

    // filters become necessary when scopes other than global are supported
    // Region filter representing the purchasing region. Therefore, global cloud
    // commitment utilization data will not be returned when a specific filter is
    // requested
    optional cloud_common.RegionFilter region_filter = 4;
    optional cloud_common.AccountFilter account_filter = 5;
    optional cloud_common.CloudCommitmentFilter cloud_commitment_filter = 6;
    optional cloud_common.ServiceProviderFilter service_provider_filter = 7;

    // returned stats will always be grouped by the timestamp
    repeated GroupByCondition group_by = 8;

    // The number of stat records to return per chunk. The max value is 100.
    optional uint32 chunk_size = 9 [default = 100];

    enum GroupByCondition {
        CLOUD_COMMITMENT = 1;
        SERVICE_PROVIDER = 2;
        ACCOUNT = 3;
    }
}

message GetHistoricalCloudCommitmentUtilizationResponse {
    repeated CloudCommitmentStatRecord commitment_stat_record_chunk = 1;
}

message GetHistoricalCommitmentCoverageStatsRequest {

    // The start_time (inclusive) and end_time (exclusive), represented as milliseconds since epoch in UTC,
    // are the window in which utilization stats should be queried. If start_time is not set, stats
    // since epoch are returned. If end_time is not set, stats up until current are returned.
    optional uint64 start_time = 1;
    optional uint64 end_time = 2;

    optional cloud_common.CloudStatGranularity granularity = 4 [default = HOURLY];

    // filters become necessary when scopes other than global are supported
    // Region filter representing the purchasing region. Therefore, global cloud
    // commitment utilization data will not be returned when a specific filter is
    // requested
    optional cloud_common.RegionFilter region_filter = 5;
    optional cloud_common.AccountFilter account_filter = 6;
    optional cloud_common.ServiceProviderFilter service_provider_filter = 7;

    // returned stats will always be grouped by the timestamp
    repeated GroupByCondition group_by = 8;

    // The number of stat records to return per chunk. The max value is 100.
    optional uint32 chunk_size = 9 [default = 100];

    enum GroupByCondition {
        ACCOUNT = 1;
        REGION = 2;
        SERVICE_PROVIDER = 3;
        CLOUD_SERVICE = 4;
    }
}

message GetHistoricalCommitmentCoverageStatsResponse {
    repeated CloudCommitmentStatRecord commitment_stat_record_chunk = 1;
}

message CloudCommitmentStatRecord {
    optional int64 snapshot_date = 1;

    optional StatValue capacity = 2;

    optional StatValue values = 3;

    optional int64 sample_count = 4;

    optional int64 commitment_id = 5;
    // entity to which the commitment applies
    optional int64 entity_id = 6;
    // service to which the commitment applies
    optional int64 cloud_service_id = 7;
    // region to which the commitment applies or is purchased within
    optional int64 region_id = 8;
    // account to which the commitment applies (if coverage) or is purchased within (if utilization)
    optional int64 account_id = 9;

    optional int64 service_provider_id = 10;

    message StatValue {
        optional cloud_commitment_dto.CloudCommitmentAmount max = 1;
        optional cloud_commitment_dto.CloudCommitmentAmount min = 2;
        optional cloud_commitment_dto.CloudCommitmentAmount avg = 3;
        optional cloud_commitment_dto.CloudCommitmentAmount total = 4;
    }
}

service CloudCommitmentUploadService {
    rpc UploadCloudCommitmentData(UploadCloudCommitmentDataRequest) returns (UploadCloudCommitmentDataResponse);
}

enum TopologyType {
    TOPOLOGY_TYPE_UNKNOWN = 0;
    TOPOLOGY_TYPE_SOURCE = 1;
    TOPOLOGY_TYPE_PROJECTED = 2;
}

message GetTopologyCommitmentCoverageStatsRequest {

    // The number of stat records to return per chunk.
    optional uint32 chunk_size = 1 [default = 100];

    // The topology type field is required; if not specified, the response will be empty.
    optional TopologyType topology_type = 2 [default = TOPOLOGY_TYPE_UNKNOWN];
}

message GetTopologyCommitmentCoverageStatsResponse {
    repeated cloud_commitment_dto.CloudCommitmentCoverage commitment_coverage_stat_chunk = 1;
}

message GetTopologyCommitmentUtilizationStatsRequest {

    // The number of stat records to return per chunk.
    optional uint32 chunk_size = 1 [default = 100];

    // The topology type field is required; if not specified, the response will be empty.
    optional TopologyType topology_type = 2 [default = TOPOLOGY_TYPE_UNKNOWN];
}

message GetTopologyCommitmentUtilizationStatsResponse {
    repeated CloudCommitmentUtilizationRecord commitment_utilization_record_chunk = 1;

    message CloudCommitmentUtilizationRecord {
        optional int64 commitment_oid = 1;
        optional cloud_commitment_dto.CloudCommitmentUtilization utilization = 2;
    }
}

service CloudCommitmentStatsService {
    rpc GetHistoricalCommitmentUtilization(GetHistoricalCloudCommitmentUtilizationRequest)
    returns (stream GetHistoricalCloudCommitmentUtilizationResponse);

    rpc GetHistoricalCommitmentCoverageStats(GetHistoricalCommitmentCoverageStatsRequest)
    returns (stream GetHistoricalCommitmentCoverageStatsResponse);

    rpc GetTopologyCommitmentCoverage(GetTopologyCommitmentCoverageStatsRequest)
    returns (stream GetTopologyCommitmentCoverageStatsResponse);

    rpc GetTopologyCommitmentUtilization(GetTopologyCommitmentUtilizationStatsRequest)
    returns (stream GetTopologyCommitmentUtilizationStatsResponse);
}

message GetCloudCommitmentInfoForAnalysisRequest {
    optional topology.TopologyInfo topology_info = 1;
}

message GetCloudCommitmentInfoForAnalysisResponse {
    repeated CommitmentInfoBucket commitment_bucket = 1;

    message CommitmentInfoBucket {

        optional int64 timestamp_millis = 1;

        optional cloud_common.CloudStatGranularity granularity = 2 [default = HOURLY];

        repeated cloud_commitment_dto.CloudCommitmentMapping cloud_commitment_mapping = 3;

        map<int64, cloud_commitment_dto.CloudCommitmentAmount> cloud_commitment_overhead = 4;
    }
}

service CloudCommitmentService {
    rpc GetCloudCommitmentInfoForAnalysis(GetCloudCommitmentInfoForAnalysisRequest)
    returns (GetCloudCommitmentInfoForAnalysisResponse);
}