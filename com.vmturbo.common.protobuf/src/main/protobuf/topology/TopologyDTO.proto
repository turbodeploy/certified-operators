syntax = "proto2";
package topology;

option java_package = "com.vmturbo.common.protobuf.topology";

import "common/EnvironmentTypeEnum.proto";
import "plan/PlanDTO.proto";
import "CloudCostDTO.proto";
import "CommonDTO.proto";

// Different entity types may have additional configuration options that get discovered by the
// SDK. We could represent these options as part of the loose-form entity properties, but it
// becomes difficult to work with and maintain - especially as the SDK changes.
//
// This message should contain all the type-specific configuration options we need to use in XL or
// display in the UI.
message TypeSpecificInfo {

    oneof type {
        // The field number is the index of the entity type.
        ApplicationInfo application = 1;
        VirtualMachineInfo virtual_machine = 10;
        PhysicalMachineInfo physical_machine = 14;
        DatabaseInfo database = 46;
        ComputeTierInfo compute_tier = 56;
        VirtualVolumeInfo virtual_volume = 60;
        StorageInfo storage = 70;
    }

    message ApplicationInfo {
        // the IP Address to connect to the application
        optional IpAddress ip_address = 1;
    }

    message VirtualMachineInfo {
        // The OS type.
        optional .common_dto.OSType guest_os_type = 1 [default = UNKNOWN_OS];

        // If set, the tenancy of the VM. This is only applicable
        // in a cloud environment (in an on-prem environment you're always on a host).
        optional .common_dto.Tenancy tenancy = 2;

        // List of IP addresses for the VM.
        repeated IpAddress ip_addresses = 3;
    }

    // Properties unique to a PhysicalMachine in the model
    message PhysicalMachineInfo {
        // The cpu_model for this machine, if known, used to scale the CPU performance
        optional string cpu_model = 1;

        // The vendor (or manufacturer) of this Physical Machine (Host)
        optional string vendor = 2;

        // The model identifier of this Physical Machine (Host)
        optional string model = 3;
    }

    // specific data for compute tier
    message ComputeTierInfo {
        // An identifier for matching compute tiers that belong to the same family.
        optional string family = 1;

        // Specifies the dedicated storage configuration state for the compute tier.
        // Market uses this to decide whether or not to combine IOThroughput and NetThroughput that
        // vm is buying and add them together as consumption, then check with compute tier.
        optional common_dto.EntityDTO.ComputeTierData.DedicatedStorageNetworkState dedicated_storage_network_state = 2;

        // A quantitative way to compare different tiers in a family. Each tier provides a certain
        // number of coupons, with the smallest tier in a family providing 1. Coupon is a our
        // internal way compare different tiers in a family. AWS defines Normalization
        // Factor (NFU) for different tier size:
        // https://aws.amazon.com/blogs/aws/new-instance-size-flexibility-for-ec2-reserved-instances/
        // In our internal mode, we defined the coupon to be NFU * 4. For example, "nano" has a NFU
        // of 0.25, so its coupon size is 0.25 * 4 = 1.
        optional int32 num_coupons = 3;
    }

    message DatabaseInfo {
        // Edition
        optional .common_dto.DatabaseEdition edition = 1;

        // Engine
        optional .common_dto.DatabaseEngine engine = 2;

        // LicenseModel
        optional .common_dto.LicenseModel license_model = 3;

        // DeploymentType
        optional .common_dto.DeploymentType deployment_type = 4;
    }

    // specific data for virtual volume
    message VirtualVolumeInfo {
        // float iops capacity of volume needed for cost calculations
        optional float storage_access_capacity = 1;

        // float storage capacity (MB) of volume needed for cost calculations
        optional float storage_amount_capacity = 2;

        // String identifying the replication type needed for cost calculations
        optional .common_dto.EntityDTO.VirtualVolumeData.RedundancyType redundancy_type = 3;
    }

    // specific data for a Storage entity
    message StorageInfo {
        // some number of different external names for this storage as known to the provider(s)
        repeated string external_name = 1;

        // What basic type of storage does this represent, e.g. GENERIC_BLOCK, ISCSI, FIBER_CHANNEL, etc
        optional .common_dto.EntityDTO.StorageType storage_type = 2;
    }
}

message TopologyEntityDTO {

    // type of entity
    required int32 entity_type = 1;

    // Type-specific configuration of the entity.
    optional TypeSpecificInfo type_specific_info = 30;

    // object identifier
    required int64 oid = 2;

    // name to display in the UI
    optional string display_name = 3;

    // The environment type for the entity.
    //
    // The environment type is closely related to the origin, but we keep it outside
    // the origin because they are distinct concepts. The origin outlines how the entity came to
    // be included in the topology. The environment type specifies the subset of the topology the
    // entity belongs to.
    //
    // Some entities will only ever have one environment type (e.g. COMPUTE_TIER -> CLOUD,
    // PHYSICAL_MACHINE -> ON_PREM), whereas others (e.g. VMs) can have either.
    optional .common.EnvironmentType environment_type = 14;

    // list of commodities sold
    repeated CommoditySoldDTO commodity_sold_list = 4;

    // list of commodities bought group
    repeated CommoditiesBoughtFromProvider commodities_bought_from_providers = 5;

    // The commodities bought by this entity from a given provider. An entity may buy multiples sets
    // of commodities from the same provider and may not have providers. Consider the following potential
    // CommodityBoughtGroupings:
    // ["host1" -> { FOO, BAR }] and ["host1" -> { FOO }, "host1" -> { BAR }] and [ -> { QUX }]
    // In the top expression, the entity must buy FOO and BAR commodities from THE SAME provider and
    // that provider is currently "host1". If the market were to try to have this entity buy BAR commodity
    // from "host2" instead of "host1", the entity would also have to buy its FOO from "host2" as well.
    // In the second expression, the entity also must buy FOO and BAR commodities, but those are permitted
    // to come from DIFFERENT providers, it just happens that at this moment in time they are coming
    // from the same "host1" provider. So if the market were to decide to have this entity buy BAR
    // from "host2", it could continue to buy FOO from "host1" without issue.
    // In the third expressions, the entity want to but QUX, but it doesn't have a particular supplier.
    //
    // Note also that this message defines a market-related type of relationship between 2 entities.
    // This relationship is unidirectional and the semantic is consumer -> provider:
    // the entity defined in this TopologyEntityDTO is a consumer that buys a set of commodities
    // from the specified provider.
    // If the 2 entities only have a market-related type of relationship, then having this message
    // is enough, and you don't need to use the below "connected_entity_list" field (unless you have
    // other connections with other different entities, where a consumer->provider semantic is not
    // needed).
    message CommoditiesBoughtFromProvider {
        // id of provider, it could be empty when the entity is currently unplaced, or not have a
        // supplier for a particular set of commodities that it is buying
        optional int64 provider_id = 1;

        // entity type of provider. it represents commodities should bought
        // from which kind of entity type. Right now, it will not been used by Market, but in future,
        // this value could be useful in Market.
        // TODO: To make sure provider entity type is always non-empty.
        optional int32 provider_entity_type = 2;

        // a list of commodities bought from this provider
        repeated CommodityBoughtDTO commodity_bought = 3;

        // Whether the group of commodities bought can be moved from one provider to another provider.
        // If unset, the movable value for an entity will be calculated based on its entityType from
        // the list of movable types in AnalysisUtil.
        optional bool movable = 4;

        // id of the volume which is associated with this set of bought commodities, it is used to
        // support volumes in the cloud
        optional int64 volume_id = 5;
    }

    // entity state
    optional EntityState entity_state = 6 [default = POWERED_ON];

    // entity properties in free (string <-> string) form, used for probe-defined values.
    map<string, string> entity_property_map = 7;

    // Contains all settings for market analysis purpose.
    optional AnalysisSettings analysis_settings = 8;

    message AnalysisSettings {
        // Whether the entity could be a potential provider for consumers.
        optional bool is_available_as_provider = 1 [default = true];

        // ShopsTogether is set by the Probe and will be passed to Market.
        optional bool shop_together = 2 [default = false];

        // Whether the Market can clone this entity.
        // If unset, the clonable value for an entity will be calculated based on its entityType from
        // the list of ENABLE_PROVISION in EntitySettings.
        optional bool cloneable = 3;

        // Whether the Market can suspend this entity. And it's default value should be true.
        // If unset, the suspendable value for an entity will be calculated in Market component based
        // on its entityType from the list of ENABLE_SUSPEND types in EntitySettings.
        optional bool suspendable = 4 [default = true];

        // The desired utilization target value. Together with the
        // desired_utilization_range below, they describe the min and max
        // desired utilization values.
        optional float desired_utilization_target = 5 ;

        // The desired utilization target range
        optional float desired_utilization_range = 6 ;

        // Whether the entity can be resized down by Market. If true, Market is able to generate resize
        // down actions, if false, Market will not generate resize down actions.
        optional bool is_eligible_for_resize_down = 7 [default = false];

        // Whether the entity is in "control" state -- there are moves occurring on the entity so that
        // it can not move, clone, suspend, accept entities move into or out of itself
        optional bool controllable = 8 [default = true];
    }

    optional Origin origin = 10;
    optional Edit edit = 11;

    // The Origin tracks where and how an entity came to be included in the topology.
    // An entity can have one of three possible Origins:
    //   1) discovered from a probe target (or multiple targets).
    //   2) created by a Placement Reservation
    //   3) Added as part of a plan scenario, such as an entity added by an "add workload" config,
    //      or headroom vm's added for cluster headroom calculation.
    message Origin {
        oneof origin_type {
            DiscoveryOrigin discovery_origin = 1;
            ReservationOrigin reservation_origin = 2;
            PlanOrigin plan_origin = 3;
        }
    }

    // An entity that was discovered by a probe.
    message DiscoveryOrigin {
        // The ids of the one or more targets that discovered this entity.
        //
        // If more than one target is present in the list, those targets may or may not be associated
        // with the same type of probe.
        //
        // An example where the targets belong to the same type of probe: 3 VC targets discover
        // the same shared storage
        //
        // An example where the targets belong to different types of probe: 1 VC target and 1 NetApp target
        // discover the same storage device.
        //
        // The id of at least one target will always be in this list.
        // No guarantees are made about the order of the targets in the list.
        repeated int64 discovering_target_ids = 1;

        // The time that the data for this entity was last updated.
        //
        // If the entity was discovered by multiple targets, this time is the time at which the
        // most recent update across all those targets provided new information for this entity.
        //
        // Important note: This is the time that TopologyProcessor received this data from the probe,
        // not the actual time that the probe retrieved the information from the target.
        //
        // This field may be used as a heuristic for the recency of the data in the absence of better information.
        // The time is in "computer time" and not necessarily UTC, however, times on TopologyEntityDTOs
        // are comparable. See documentation in Java's System#currentTimeMillis() for further details.
        optional int64 last_updated_time = 2;
    }

    // an entity that was created via a Placement reservation. Has a reference to it's reservation
    // id.
    message ReservationOrigin {
        required int64 reservation_id = 1;
    }

    // an entity can be created by a plan configuration to support plan scenarios, such as "Add
    // Workload", "Replace". Phantom Entities are also created in special situations, such as for
    // calculating headroom in the cluster headroom plan. The plan origin for these entities will
    // refer to the plan id the entity was added to support.
    message PlanOrigin {
        required int64 plan_id = 1;
    }

    // if the entity has met a (potentially grisly) end, describe it. Currently there are only two
    // edits being tracked:
    //   1) Removed -- the entity was Removed as part of a "remove" or "decommission" plan scenario
    //   2) Replaced -- the entity was Replaced in a plan scenario change.
    // We have discussed other possible types of edits in the future, such as "change workload", but
    // those are not necessary for modeling at this time and have alternate approaches available as
    // well.
    message Edit {
        oneof change_type {
            Removed removed = 1;
            Replaced replaced = 2;
        }
    }

    // this entity was Removed as part of a place scenario configuration.
    message Removed {
        required int64 plan_id = 1; // the plan calling for the entity's removal
    }

    // this entity was Replaced by another entity as part of a place scenario configuration.
    // We could potentially track the "replaced by" entity id here too, but that requires additional
    // complexity. We don't seem to need it yet, so leaving it out.
    message Replaced {
        required int64 plan_id = 1; // the plan calling for the entity's replacement
    }

    // List of entities that are topologically connected with the entity that this probuf defines.
    repeated ConnectedEntity connected_entity_list = 12;

    // This message defines a topological connection between 2 entities.
    // This relationship is unidirectional, the semantic depends on the ConnectionType itself.
    // This message needs to be used only to represent a topological relationship where the 2
    // entities are connected to each other, but they are not trading any resources between them;
    // for relationship where there is a consumer->provider semantic need, you need to use the above
    // "commodities_bought_from_providers" field.
    message ConnectedEntity {

        // Id of the entity on the other side of the connection
        optional int64 connected_entity_id = 1;

        // Type of the entity on the other side of the connection
        optional int32 connected_entity_type = 2;

        // Type of connection that this message is representing. different types means different
        // semantics
        optional ConnectionType connection_type = 3;

        // Type of connection that this message is representing. different types means different
        // semantics
        enum ConnectionType {

            // Normal connection is a basic topology connection, where 2 entities are physically or
            // virtually connected. This means that from each one of those entities we should be able to
            // see the connection and navigate to the other one.
            // There is no well-defined direction in this connection, but given that we want to represent
            // only unidirectional connections, this means that the direction to be used here is a
            // convention decided by the author/code that will generate this dto (but it should be
            // consistent across the topology).
            // Example: the connection from pm to storage can be defined in both directions, but
            // we decided that will always be from pm -> storage.
            NORMAL_CONNECTION = 1;

            // Owns connection is used where 2 entities not only are topologically connected, but
            // in addition, the entity defined in this protobuf is the owner of the entity at the other
            // side of the connection.
            // This relationship is unidirectional and the semantic is owner -> owned (or master -> slave).
            // This relationship can in the future drive behaviors like:
            // - when the master is deleted, delete also all the slaves
            // - group all the slaves by master
            // - aggregate slaves stats/metrics by master
            OWNS_CONNECTION = 2;
        }
    }

    // Entity tags
    map<string, TagValuesDTO> tags = 13;

    message TagValuesDTO {
        repeated string values = 1;
    }
}

// Message to hold original topology broadcast message.
message Topology {
    // The ID of the topology
    required int64 topology_id = 1;

    oneof segment {
        Start start = 2;
        Data data = 3;
        End end = 4;
    }

    // Marker message, declaring the start of topology broadcast
    message Start {
        // The basic information of topology
        optional TopologyInfo topology_info = 1;
    };
    // Message to hold real data of the topology - it is the chunk
    message Data {
        // The entities in the topology
        repeated TopologyEntityDTO entities = 1;
    }
    // Message to appear at the very end of topology broadcast
    message End {
        // Total number of entities sent (can be used for integrity checks)
        required uint64 total_count = 1;
    }
}

message ProjectedTopologyEntity {
    // The entity DTO representing the entity in the
    // projected topology.
    optional TopologyEntityDTO entity = 1;

    // The original price index of the entity. It is sent along with the projected topology
    // because we don't know the price index of an entity until the market analyzes a topology.
    // It is the consumer's responsibility to associate the price index with the TopologyEntityDTO
    // of the entity in the original (NOT the projected) topology.
    //
    // Note: If an entity from the original topology was skipped during conversion and does not
    // appear in the projected topology, it's the consumer's responsibility to use a default
    // price index for that entity.
    //
    // This will be unset if the entity did not exist in the original
    // topology.
    optional double original_price_index = 10 [default = 1.0];

    // The projected price index of the entity.
    optional double projected_price_index = 11 [default = 1.0];
}

// Message to hold topology, projected by market.
message ProjectedTopology {
    // GeneratedId of the topology created after the plan
    required int64 topology_id = 1;

    oneof segment {
        Start start = 2;
        Data data = 3;
        End end = 4;
    }

    // Marker message, declaring the start of topology broadcast
    message Start {
        // The basic information of the source topology
        optional TopologyInfo source_topology_info = 1;

        // Entities in the source topology that were skipped in the analysis.
        // These entities will not have associated entries in the projected
        // topology.
        repeated int64 skipped_entities = 2;
    };
    // Message to hold real data of the topology - it is the chunk
    message Data {
        // The entities in the projected topology.
        repeated ProjectedTopologyEntity entities = 2;

        // The entities in the topology. This is deprecated.
        repeated TopologyEntityDTO __deprecated__entities = 1 [deprecated = true];
    }
    // Message to appear at the very end of topology broadcast
    message End {
        // Total number of entities sent (can be used for integrity checks)
        required uint64 total_count = 1;
    }
}

// Message to hold basic fields of topology
message TopologyInfo {
    // The ID of the topology
    optional int64 topology_id = 1;

    // For a plan it is the plan ID, for real time topology it is a number that uniquely identifies the source topology processor
    optional int64 topology_context_id = 2;

    // The time of the topology created.
    optional int64 creation_time = 3;

    // The type of topology
    optional TopologyType topology_type = 4 [default = REALTIME];

    // If the topology is to be scoped, the OIDs specified here seed the scoping expansion.
    repeated int64 scope_seed_oids = 5;

    // Plan-specific topology information.
    // Present IFF TopologyType is PLAN.
    optional PlanTopologyInfo plan_info = 6;
}

// Information specific to a topology generated for the purpose of a plan.
message PlanTopologyInfo {
    // The type of the plan project that initiated the topology broadcast.
    optional plan.PlanProjectType plan_project_type = 1 [default = USER];

    // The type of the plan initiated.
    optional string plan_type = 2;
}

enum EntityState {
    POWERED_ON = 0;
    POWERED_OFF = 1;
    SUSPENDED = 2;
    MAINTENANCE = 3;
    FAILOVER = 4;
    UNKNOWN = 5;
}

enum TopologyType {
    REALTIME = 0;
    PLAN = 1;
}

message CommodityType {
    // Type of commodity
    required int32 type = 1;

    // The key of this commodity type
    optional string key = 2;
}

// Standard attributes of a commodity
enum CommodityAttribute {
    // The capacity of a commodity is the "raw capacity" -- i.e. the total amount of the commodity
    // available for use, before considering any restrictions such as limits or utilization
    // threshold percentages.
    CAPACITY = 0;

    // If a limit exists on a commodity, it represents a cap or ceiling on the capacity that
    // should restrict the amount of the commodity that is actually available for allocation. Without
    // considering a utilization threshold policy, the amount of the commodity available for allocation
    // should be the minimum of (capacity, limit). Also, limit should be smaller than capacity for
    // the limit to be meaningful.
    //
    // Limits are optional, and by default, commodities are "unlimited". It seems that limits are
    // only used on VM CPU, Memory, and Network commodities.
    LIMIT = 1;

    // A reservation on a commodity functions almost like the opposite of a limit. If a commodity
    // has a "reserved" amount set, then that amount cannot be allocated. It is considered "reserved"
    // for a specific consumer for potential use and not available to other consumers.
    //
    // This is probably most relevant for commodities that can be overprovisioned, such as CPU or
    // Memory. A VM with a 2gb reservation and 8gb capacity, for example, would guarantee that the
    // PM sets aside at least 2gb for that VM to use, even if the actual amount in use is smaller.
    //
    // Reservations are also optional and the default state would be reserved = 0.
    RESERVED = 2;
}

message CommodityBoughtDTO {

    required CommodityType commodityType = 1;

    optional double used = 2 [default = 0.0];

    optional double peak = 3 [default = 0.0];

    // Whether the commodity is active or not
    optional bool active = 4 [default = true];

    // A scale factor to multiply this commodity by before analysis, if present
    optional double scaling_factor = 5;
}

message CommoditySoldDTO {

    required CommodityType commodityType = 1;

    optional double used = 2 [default = 0.0];

    optional double peak = 3 [default = 0.0];

    optional double capacity = 4 [default = 100];

    optional double effectiveCapacityPercentage = 5 [default = 100];

    optional double reservedCapacity = 6 [default = 0.0];

    optional bool isResizeable = 7 [default = true];

    optional bool isThin = 8 [default = true];

    // For DSPM_ACCESS commodity this is the id of the PhysicalMachine associated with the Storage
    // that sells this commodity. For DATASTORE commodity this is the id of the Storage associated
    // with the PhysicalMachine that sells this commodity.
    optional int64 accesses = 9;

    // Whether the commodity is active or not
    optional bool active = 10 [default = true];

    // related to resize increment
    optional float capacity_increment = 11 [default = 1.0];

    // The historic max value(within the data retention period)
    optional double max_quantity = 12;

    // A scale factor to multiply this commodity by before analysis, if present
    optional double scaling_factor = 13;
}

message IpAddress {
    // a single IP Address
    optional string ip_address = 1;

    // true if the ipAddress is elastic.  This is relevant for cloud targets only.
    optional bool is_elastic = 2;
}

// A request to assemble the current topology and broadcast it to all listeners for the topology.
message TopologyBroadcastRequest {
    // Currently no properties.
}

// The response to a request to broadcast the topology.
message TopologyBroadcastResponse {
    // Currently no properties.
    // TODO: Make topology broadcasts a first-class object similar to all TP operations (discovery, action, etc).
}

service TopologyService {
    // Request that the topology processor broadcast the latest topology to all its listeners.
    // Does not actually provide the topology in the response.
    rpc RequestTopologyBroadcast(TopologyBroadcastRequest) returns (TopologyBroadcastResponse);

    // Request that the topology processor broadcast the latest topology to all its listeners AND
    // return the topology to the caller as a stream of Topology messages.
    rpc BroadcastAndReturnTopology(TopologyBroadcastRequest) returns (stream Topology);
}
