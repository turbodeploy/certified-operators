syntax = "proto2";
package topology;

option java_package = "com.vmturbo.common.protobuf.topology";

import "common/EnvironmentTypeEnum.proto";
import "plan/PlanProject.proto";
import "plan/Scenario.proto";
import "plan/PlanExportDTO.proto";
import "CloudCostDTO.proto";
import "CommonDTO.proto";
import "tag/Tag.proto";
import "ncm/Matrix.proto";
import "CommonCost.proto";

// Different entity types may have additional configuration options that get discovered by the
// SDK. We could represent these options as part of the loose-form entity properties, but it
// becomes difficult to work with and maintain - especially as the SDK changes.
//
// This message should contain all the type-specific configuration options we need to use in XL or
// display in the UI.
message TypeSpecificInfo {

    oneof type {
        // The field number is the index of the entity type.
        ApplicationInfo application = 1;
        VirtualMachineInfo virtual_machine = 10;
        PhysicalMachineInfo physical_machine = 14;
        BusinessAccountInfo business_account = 28;
        DatabaseInfo database = 46;
        ComputeTierInfo compute_tier = 56;
        VirtualVolumeInfo virtual_volume = 60;
        StorageInfo storage = 70;
        DiskArrayInfo disk_array = 71;
        LogicalPoolInfo logical_pool = 72;
        StorageControllerInfo storage_controller = 73;
        DesktopPoolInfo desktop_pool = 74;
        BusinessUserInfo business_user = 75;
        RegionInfo region = 76;
        WorkloadControllerInfo workload_controller = 77;
        DatabaseTierInfo database_tier = 78;
        DatabaseServerTierInfo database_server_tier = 79;
        CloudCommitmentInfo cloud_commitment_data = 80;
        NamespaceInfo namespace = 81;
        ContainerPlatformClusterInfo container_platform_cluster = 82;
        ContainerInfo container = 83;
        ContainerPodInfo container_pod = 84;
        ServiceInfo service = 85;
        ApplicationServiceInfo application_service = 86;
        CloudApplicationInfo cloud_application = 87;
    }

    message ApplicationInfo {
        // the IP Address to connect to the application
        optional IpAddress ip_address = 1;
        // The CPU frequency of the kubernetes node hosting this application.
        // This value as of now is needed only to be able to convert the vcpu capacity of this
        // application in capacity and usage widgets, if its hosted on a container.
        // We show container data in millicores but the app data in Mhz because that is
        // more consistent for the application when stitched with APM probes or when the
        // application is reported without the cloud native entities.
        optional double hostingNodeCpuFrequency = 2;

    }

    message CloudApplicationInfo {
        // Number of deployment slots.
        optional int32 deployment_slot_count = 1;
        // hybrid connection count
        optional int32 hybrid_connection_count = 2;
    }

    message ApplicationServiceInfo {
        // Platform (can also be OS)
        optional Platform platform = 1;
        // Tier (also known as Pricing Tier)
        optional Tier tier = 2;
        // Maximum number of worker VMs for this component.
        optional int32 max_instance_count = 3;
        // Number of worker VMs for this component.
        optional int32 current_instance_count = 4;
        // Number of apps contained within this app service
        optional int32 app_count = 5;
        // Whether or not the app service is zone redundant
        optional bool zone_redundant = 6;
        // Number of days the app service has had no apps.
        optional int32 days_empty = 7;

        enum Platform {
            UNKNOWN = 0;
            LINUX = 1;
            WINDOWS = 2;
        }

        enum Tier {
            OTHER_APP_SERVICE_PLAN_SERVICE_TIER = 0;
            FREE = 1;
            SHARED = 2;
            BASIC = 3;
            STANDARD = 4;
            PREMIUM = 5;
            PREMIUMV2 = 6;
            PREMIUMV3 = 7;
            ISOLATED = 8;
            ISOLATEDV2 = 9;
            PREMIUMCONTAINER = 10;
            ELASTICPREMIUM = 11;
            WORKFLOWSTANDARD = 12;
            DYNAMIC = 13;
        }
    }

    message VirtualMachineInfo {
        // The OS info.
        optional OS guest_os_info = 1;

        // If set, the tenancy of the VM. This is only applicable
        // in a cloud environment (in an on-prem environment you're always on a host).
        optional .common_dto.Tenancy tenancy = 2;

        // List of IP addresses for the VM.
        repeated IpAddress ip_addresses = 3;

        // Total number of CPUs for the VM.
        optional int32 num_cpus = 4;

        // This specifies if the VM is using a spot instance or not.
        optional .common_dto.EntityDTO.VirtualMachineData.VMBillingType billingType = 5 [default = ONDEMAND];

        // display name of all of the networks that connected to the VM.
        repeated string connected_networks = 6;

        // The licensing model of the VM (license included in compute price vs. BYOL)
        optional .common_dto.EntityDTO.LicenseModel license_model = 7 [default = LICENSE_INCLUDED];

        // Information about the drivers that this VM has
        optional DriverInfo driverInfo = 8;

        // Architecure of the VM
        optional Architecture architecture = 9;

        // Virtualization Type of the VM
        optional VirtualizationType virtualizationType = 10;

        // If present, info about any read-only locks that might prevent VM action execution.
        optional string locks = 11;

        // Whether the VM memory is allocated dynamically
        optional bool dynamic_memory = 12;

        message DriverInfo {
            // Does the VM have driver for Elastic Network adapter? It is an AWS specific driver.
            optional bool hasEnaDriver = 1;
            // Does the VM have driver for NVMe? It is an AWS specific driver.
            optional bool hasNvmeDriver = 2;
        }

        // Maps vStorage key to partition
        map<string,string> partitions = 13;

        // The number of cores which is provided by one socket
        optional int32 coresPerSocketRatio = 14 [default = 1];

        // The mark that shows whether cores per socket property of the VM can be changed or not
        optional bool coresPerSocketChangeable = 15 [default = false];

        // Corresponding setting from CommonDTO.proto's VirtualMachineData coming from probe.
        // Count of how many ephemeral disks (instance stores for AWS, or local SSDs for GCP) are
        // currently attached to the VM. Required because GCP supports multiple disk count options.
        optional int32 numEphemeralStorages = 16;

        // contains settings required for proper CPU scaling action adjustments
        optional CpuScalingPolicy cpu_scaling_policy = 17;

        // Policy settings that describes required CPU scaling adjustments
        message CpuScalingPolicy {
            // target cores per socket value has to be populated in case cores per socket
            // has to be adjusted
            optional int32 cores_per_socket = 1 [default = 1];
            // target sockets value has to be populated in case sockets configuration has
            // to be changed according to policy requirements
            optional int32 sockets = 2 [default = 1];
        }
        // The vendor tool version for this virtual machine
        optional string vendorToolsVersion = 18;

        // The mark that shows whether the VM belongs to an Azure VDI instance or not.
        optional bool is_vdi = 19 [default = false];
    }

    // Properties unique to a PhysicalMachine in the model
    message PhysicalMachineInfo {
        // The cpu_model for this machine, if known, used to scale the CPU performance
        optional string cpu_model = 1;

        // The vendor (or manufacturer) of this Physical Machine (Host)
        optional string vendor = 2;

        // The model identifier of this Physical Machine (Host)
        optional string model = 3;

        // The total number of CPU cores on the host
        optional int32 num_cpus = 4;

        // The timezone of this host
        optional string timezone = 5;

        // The total number of CPU sockets on the host
        optional int32 num_cpu_sockets = 6;

        // The CPU Core MHz on the host
        optional int32 cpu_core_mhz = 7;

        // Disk Groups for vSAN storages
        repeated .common_dto.EntityDTO.DiskGroupData diskGroup = 8;

        //Whether the host is a failover or not
        optional bool dedicatedFailover = 9;

        // Automation level of the physical machine
        optional .common_dto.EntityDTO.AutomationLevel automationLevel = 10 [default = NOT_AUTOMATED];

        // Migration level specified for the cluster of the PM
        optional string migrationLevel = 11;

        // The total number of CPU threads on the host.
        optional int32 num_cpu_threads = 12;
    }

    message BusinessAccountInfo {
        // target for a master BA can discover multiple BAs (master BA + sub BAs), only master BA
        // has associated target, but not sub BAs. They all have discovering target ids (which is
        // the target for master BA), but sub BAs are not added as targets. So we need this field to
        // indicate whether there is an associated target for this BA (equivalent to that whether
        // entities for this BA are discovered or not)
        // THIS FIELD HAS BEEN DEPRECATED IN FAVOR OF associated_target_id
        optional bool obsolete_has_associated_target = 1 [deprecated = true];

        // The OID of the target that discovered the entities in this BusinessAccount if one exists.
        optional int64 associated_target_id = 5;

        // The account id used by the third party provider.  For example, for Azure this would be
        // the subscription ID.
        optional string account_id = 2;

        // A list of provider specific account attributes that are used to identify the pricing
        // applied to an account.  For example, Azure uses offer ID and enrollment number.
        repeated .common_dto.PricingIdentifier pricing_identifiers = 3;

        // Flag to indicate RI support status.
        optional bool riSupported = 4;

        // Account type: Standard, Government_US, etc.
        optional common_dto.EntityDTO.BusinessAccountData.AccountType account_type = 6;
    }

    // Specific data for region
    message RegionInfo {

        // region should have a geo data info
        optional GeoDataInfo geo_data = 1;
    }

    // specific data for compute tier
    message ComputeTierInfo {
        // An identifier for matching compute tiers that belong to the same family.
        optional string family = 1;

        // Quota family is the group that comprises of profiles that count towards the usage limit for
        // a defined category imposed on a Business Account.
        optional string quota_family = 15;

        // Specifies the dedicated storage configuration state for the compute tier.
        // Market uses this to decide whether or not to combine IOThroughput and NetThroughput that
        // vm is buying and add them together as consumption, then check with compute tier.
        optional common_dto.EntityDTO.ComputeTierData.DedicatedStorageNetworkState dedicated_storage_network_state = 2;

        // A quantitative way to compare different tiers in a family. Each tier provides a certain
        // number of coupons, with the smallest tier in a family providing 1. Coupon is a our
        // internal way compare different tiers in a family. AWS defines Normalization
        // Factor (NFU) for different tier size:
        // https://aws.amazon.com/blogs/aws/new-instance-size-flexibility-for-ec2-reserved-instances/
        // In our internal mode, we defined the coupon to be NFU * 4. For example, "nano" has a NFU
        // of 0.25, so its coupon size is 0.25 * 4 = 1.
        optional int32 __deprecated__num_coupons = 3 [deprecated = true];
        optional double num_coupons = 11;

        // Specifies the number of cores that the tier has
        // This is used for license price calculation (since not all templates are used by VMs)
        optional int32 num_cores = 4[deprecated = true];

        // Information about the types of customers this compute tier can support
        optional SupportedCustomerInfo supported_customer_info = 5;

        message SupportedCustomerInfo {
            // Can the template only support VMs which have driver for ENA?
            optional bool supportsOnlyEnaVms = 1;
            // Can the template only support VMs which have driver for NVMe?
            optional bool supportsOnlyNVMeVms = 2;
            // The architectures of VMs that are supported by this compute tier.
            repeated Architecture supportedArchitectures = 3;
            // The virtualization type of VMs that are supported by this compute tier.
            repeated VirtualizationType supportedVirtualizationTypes = 4;
        }

        // DEPRECATED: Use newer 'instance_disk_counts' instead.
        //Number of Ephemeral disks supported by this tier
        optional int32 num_instance_disks = 6 [deprecated = true];
        //Size of each Ephemeral disk supported by this tier in GB
        optional int32 instance_disk_size_gb = 7;
        //disk type of Ephemeral storage
        optional common_dto.EntityDTO.InstanceDiskType instance_disk_type = 8;

        //property to determine if this computeTier supports burstable CPUs.
        optional bool burstableCPU = 9;

        optional ScalingPenalty scale_penalty = 10;
        message ScalingPenalty {
           optional float penalty = 1;
           // deprecated from a single value in 8.0.7, 8.1.0 to a list.
           optional common_dto.EntityDTO.ScalingPenaltyReason reason = 2 [deprecated = true];
           repeated common_dto.EntityDTO.ScalingPenaltyReason reasons = 3;
        }

        // Possible disk counts supported for compute tier. Normally single value like 8 for AWS,
        // but others like GCP support multiple options like: 2, 4, 8, 16, or 24
        repeated int32 instance_disk_counts = 12;

        // Number of cores - supports fractional number of cores.
        // Recommended to be used in place of num_cores
        optional double num_of_cores = 14;
     }



    message DatabaseTierInfo {
        // Edition type of the specified database engine
        optional string edition = 1;
        // license model of database server; e.g. BYOL or license included
        optional string family = 2;
    }

    message DatabaseServerTierInfo {
        // license model of database server; e.g. BYOL or license included
        optional string family = 1;
        // storage tier for current database server tier.
        optional string storage_tier = 2;
    }

    message CloudCommitmentInfo {
        oneof scope {
            common_dto.EntityDTO.CloudCommitmentData.ServiceRestricted service_restricted = 1; // can be applied anywhere
            common_dto.EntityDTO.CloudCommitmentData.FamilyRestricted family_restricted = 2; // restricted to one instance family
        }

        // A commitment can be spend based (savings plans) or coupon based (Reserved Instances)
        oneof commitment {
            common_dto.CurrencyAmount spend = 3;
            int64 number_coupons = 4;
            common_dto.EntityDTO.CloudCommitmentData.CommittedCommoditiesBought commodities_bought = 10;
        }
        optional common_dto.PaymentOption payment = 5;
        optional int64 term_milliseconds = 6;
        optional int64 start_time_milliseconds = 7;
        optional int64 expiration_time_milliseconds = 8;
        optional common_dto.EntityDTO.CloudCommitmentData.ProviderType provider_specific_type = 9;
        optional common_dto.EntityDTO.CloudCommitmentData.CloudCommitmentStatus commitment_status = 11;
        optional common_dto.EntityDTO.CloudCommitmentData.CloudCommitmentScope commitment_scope = 12;
    }

    // Architectures
    enum Architecture {
        BIT_32 = 0;
        BIT_64 = 1;
        ARM_64 = 2;
    }

    // Virtualization types
    enum VirtualizationType {
        HVM = 0;
        PVM = 1;
    }

    message DatabaseInfo {
      // Edition
      optional .common_dto.DatabaseEdition edition = 1;

      // Engine
      optional .common_dto.DatabaseEngine engine = 2;

      // LicenseModel
      optional .common_dto.LicenseModel license_model = 3;

      // DeploymentType
      optional .common_dto.DeploymentType deployment_type = 4;

      // DB version
      optional string version = 5;

      // Raw DB edition
      optional string rawEdition = 6;

      // list of lower bound capacity limits while scaling up per commodity that applies to this Database.
      repeated .common_dto.CommodityCapacityLimit lower_bound_scale_up = 7;

      // Average number of billed operations (e.g. reads, writes) per hour.
      optional double hourly_billed_ops = 8;

      // Total number of HA replicas for Azure vCore Hyperscale SQL DB.
      optional int64 ha_replica_count = 9;
    }

    // specific data for virtual volume
    message VirtualVolumeInfo {
        // float iops capacity of volume needed for cost calculations
        // The field is deprecated because the value is now carried in the sold commodity
        optional float storage_access_capacity = 1 [deprecated = true];

        // float storage capacity (MB) of volume needed for cost calculations
        // The field is deprecated because the value is now carried in the sold commodity
        optional float storage_amount_capacity = 2 [deprecated = true];

        // String identifying the replication type needed for cost calculations
        optional .common_dto.EntityDTO.VirtualVolumeData.RedundancyType redundancy_type = 3;

        // List of files for VC storage browsing.
        repeated .common_dto.EntityDTO.VirtualVolumeData.VirtualVolumeFileDescriptor files = 4;

        // string snapshot ID of volume needed for entity details
        optional string snapshotId = 5;

        // Volume attachment state. It is set to IN_USE only in particular cases like AWS volume.
        // In other cases, the attachment state will be deduced based on the association with VM.
        optional .common_dto.EntityDTO.VirtualVolumeData.AttachmentState attachment_state = 6;

        // Boolean encryption enabled on volume
        optional bool encryption = 7;

        // Boolean ephemeral storage
        optional bool isEphemeral = 8;

        // float IO throughput capacity (MiB/s) needed for cost calculations
        // The field is deprecated because the value is now carried in the sold commodity
        optional float io_throughput_capacity = 9 [deprecated = true];

        // Average number of billed operations (e.g. reads, writes) per hour. The field is used in
        // cost calculation for AWS Magnetic (Standard) volumes.
        optional double hourly_billed_ops = 12;

        // Storage compatibility type for volume's consumer(VM that consumes the volume).
        // Consumer's compatibility type will affect volume's analysis. If consumer is
        // Premium compatible, the volume can be Premium/Standard storage type. However,
        // if consumer is Standard only compatible, the volume can only stay on Standard type.
        optional .common_dto.EntityDTO.VirtualVolumeData.StorageCompatibilityType storage_compatibility_for_consumer = 13;

        // Usage for the volume, i.e. what the volume is used for.
        optional .common_dto.EntityDTO.VirtualVolumeData.UsageType usage_type = 14;

        // If present, info about any locks that might prevent Volume action execution.
        optional string locks = 15;

        //number of days volume is unattached
        optional int32 days_unattached = 16;
    }

    // specific data for a Storage entity
    message StorageInfo {
        // some number of different external names for this storage as known to the provider(s)
        repeated string external_name = 1;

        // What basic type of storage does this represent, e.g. GENERIC_BLOCK, ISCSI, FIBER_CHANNEL, etc
        optional .common_dto.EntityDTO.StorageType storage_type = 2;

        // boolean that marks a storage connected with isLocalSupported true from mediation and is connected
        // to just 1 PM as local
        optional bool is_local = 3;

        // boolean indicating that wasted storage actions should not be generated for this storage
        // this is set to true for storages where storage browsing is disabled for at least one
        // discovering target.
        // note: no longer used any more, since such files have been cleared before broadcast
        optional bool ignore_wasted_files = 4 [default = false, deprecated = true];

        // vSAN storage policy
        optional .common_dto.EntityDTO.StorageData.StoragePolicy policy = 5;

        // storage raw capacity
        optional .common_dto.EntityDTO.StorageData.RawCapacity rawCapacity = 6;
    }

    // specific data for a disk array
    message DiskArrayInfo {
        optional DiskTypeInfo disk_type_info = 1;
    }

    // specific data for a logical pool
    message LogicalPoolInfo {
        optional DiskTypeInfo disk_type_info = 1;
    }

    // specific data for a storage controller
    message StorageControllerInfo {
        optional DiskTypeInfo disk_type_info = 1;
    }

    //specific data for a desktop pools
    message DesktopPoolInfo {

        // how desktops are allocated to users
        optional .common_dto.EntityDTO.DesktopPoolData.DesktopPoolAssignmentType assignment_type = 1;

        // defines when the desktops are created
        optional .common_dto.EntityDTO.DesktopPoolData.DesktopPoolProvisionType provision_type = 2;

        // type (engine) of a desktop created in the pool
        optional .common_dto.EntityDTO.DesktopPoolData.DesktopPoolCloneType clone_type = 3;

        // Desktop pools give users remote access to virtual machine-based desktops.
        // Desktop pools use a virtual machine template or snapshot
        // to create a pool of identical virtual machines.
        // A separate virtual machine is created for the user when connected to the desktop pool
        // using a virtual machine template or snapshot.
        oneof clone_source_reference {

            // reference to the virtual machine used to create a pool of identical virtual machines
            VmWithSnapshot vm_with_snapshot = 4;

            // id of a virtual machine template used to create a pool of identical virtual machines
            int64 template_reference_id = 5;
        }

        // reference to the virtual machine used to create a pool of identical virtual machines
        message VmWithSnapshot {

            // id of a virtual machine snapshot used to create a pool of identical virtual machines
            required int64 vm_reference_id = 1;

            // reference to a snapshot used to create desktops
            optional string snapshot = 2;
        }
    }

    // specific data for a business user
    message BusinessUserInfo {

        // Map of the VM id to the session duration
        map<int64, int64> vm_oid_to_session_duration = 1;
    }

    // Specific data for Workload Controller entity types. These come
    // in various flavors captured by the enclosed oneof.
    message WorkloadControllerInfo {
        oneof controller_type {
            CronJobInfo cron_job_info = 1;
            CustomControllerInfo custom_controller_info = 2;
            DaemonSetInfo daemon_set_info = 3;
            DeploymentInfo deployment_info = 4;
            JobInfo job_info = 5;
            ReplicaSetInfo replica_set_info = 6;
            ReplicationControllerInfo replication_controller_info = 7;
            StatefulSetInfo stateful_set_info = 8;
        }
        optional int32 replica_count = 9;
    }

    message CronJobInfo {
        // CronJob specific data goes here.
    }

    message CustomControllerInfo {
        // Type of a custom controller. For example, "DeploymentConfig" for an Openshift DeploymentConfig.
        optional string custom_controller_type = 1;
    }

    message DaemonSetInfo {
        // DaemonSet specific data goes here.
    }

    message DeploymentInfo {
        // Deployment specific data goes here.
    }

    message JobInfo {
        // Job specific data goes here.
    }

    message ReplicaSetInfo {
        // ReplicaSet specific data goes here.
    }

    message ReplicationControllerInfo {
        // ReplicationController specific data goes here.
    }

    message StatefulSetInfo {
        // StatefulSet specific data goes here.
    }

    // Data specific to a Namespace entity.
    message NamespaceInfo {
        // The average CPU frequency of the kubernetes nodes running in the cluster that
        // the namespace belongs to. This value can be used to convert namespace
        // CPU commodities (ie LimitQuota and RequestQuota) from MHz to millicores.
        // The units on this value are in MHz/core (not MHz/millicore)
        optional double average_node_cpu_frequency = 1 [default = 1.0];
    }

    // Data specific to a ContainerPlatformCluster entity.
    message ContainerPlatformClusterInfo {
        // Container CPU limits overcommitment ratio on the nodes (VMs) in a container platform
        // cluster. The value represents the ratio of total containers VCPU capacity / total nodes
        // VCPU capacity.
        optional double vcpu_overcommitment = 1;
        // Container memory limits overcommitment ratio on the nodes (VMs) in a container platform
        // cluster. The value represents the ratio of total containers VMem capacity / total nodes
        // VMem capacity.
        optional double vmem_overcommitment = 2;
    }

    // Data specific to a ContainerPod entity.
    message ContainerPodInfo {
        // The CPU frequency of the kubernetes node hosting this pod.
        // This value as of now is needed only to be able to convert the vcpu capacity of this
        // pod in capacity and usage widgets.
        // We show pod data in millicores but the VM data in Mhz, therefor the capacity picked
        // from VM for VCPU bought commodity needs conversion to millicores.
        optional double hostingNodeCpuFrequency = 1;
    }

    message ContainerInfo {
        // Whether a container has CPU limits set.
        // If a container has CPU limits set, the discovered VCPU commodity capacity is the
        // specified CPU limits; otherwise, the discovered VCPU commodity capacity is node (VM)
        // VCPU capacity.
        optional bool has_cpu_limit = 1;
        // Whether a container has memory limits set.
        // If a container has memory limits set, the discovered VMem commodity capacity is the
        // specified memory limits; otherwise, the discovered VMem commodity capacity is node (VM)
        // VMem capacity.
        optional bool has_mem_limit = 2;
        // The CPU frequency of the kubernetes node hosting this container.
        // This value as of now is needed only to be able to convert the vcpu capacity of this
        // container to be used by the hosted application in capacity and usage widgets.
        // We show container data in millicores but the app data in Mhz because that is
        // more consistent for the application when stitched with APM probes or when the
        // application is reported without the cloud native entities.
        optional double hostingNodeCpuFrequency = 3;
    }

    message ServiceInfo {
        // Platform specific service info
        oneof service_info {
            .common_dto.EntityDTO.KubernetesServiceData kubernetes_service_data = 1;
        };
    }
}

// A batch of Partial Entities.
//
// When returning a stream, it is more efficient to batch the entities into chunks, instead of
// returning each entity individual.
message PartialEntityBatch {
    repeated PartialEntity entities = 1;
}

// When components request entity information from the repository they typically don't need all
// fields of an entity. In fact, they usually need just a few fields. In large topologies it is
// very wasteful to return full DTOs (which can be several kB in size) when we only need a few
// bytes of information. In the future we will have a generic mechanism for components to specify
// exactly the fields they need. For now, the "Partial Entity" is the placeholder to achieve
// a similar result, with more hard-coding :) This is the place for components to specify their
// own type, with the subset of the TopologyEntityDTO that the component needs for its
// computation.
message PartialEntity {

    // These line up with the message types declared below.
    enum Type {
        // The following are "generic" detail levels.
        FULL = 1;
        MINIMAL = 2;
        WITH_CONNECTIONS = 5;
        WITH_ONLY_ENVIRONMENT_TYPE_AND_TARGETS = 13;

        // The following are component-specific.
        // Some components require fairly specific subsets of the TopologyEntityDTO, and it would be
        // too confusing and inaccurate to come up with general-sounding terms to represent those
        // subsets. We opt for clarity.
        ACTION = 10;
        API = 11;
        HEADROOM_PLAN = 12;
    }

    // A minimal entity contains just the bare essentials.
    message MinimalEntity {
        required int64 oid = 1;

        optional string display_name = 2;

        optional int32 entity_type = 3;

        optional .common.EnvironmentType environment_type = 4;

        repeated int64 discovering_target_ids = 5;

        optional .topology.EntityState entity_state = 6 [default = POWERED_ON];
    }

    // The entity, as well as the entitie
    message EntityWithConnections {
        required int64 oid = 1;

        optional string display_name = 2;

        optional int32 entity_type = 3;

        // The entities this entity is connected to.
        repeated TopologyEntityDTO.ConnectedEntity connected_entities = 10;
    }

    // Just the entity oid, the environment type and the discovering targets. Used when calculating
    // group environment type, so there's no need to include any other entity data in the message.
    message EntityWithOnlyEnvironmentTypeAndTargets {
        required int64 oid = 1;

        optional .common.EnvironmentType environment_type = 2;

        repeated int64 discovering_target_ids = 5;
    }

    // Contains the fields required by the action orchestrator to calculate action modes.
    message ActionPartialEntity {
        required int64 oid = 1;

        optional string display_name = 2;

        optional int32 entity_type = 3;

        repeated int64 discovering_target_ids = 4;

        // The oid of the primary provider
        // If an entity has only one provider, then that is the primary provider.
        // If an entity has multiple providers, then which provider is the primary one depends on the type of entity.
        // Check TopologyDTOUtil::getPrimaryProviderIndex
        optional int64 primary_provider_id = 5;

        // Contains the commodities the action orchestrator needs.
        repeated int32 comm_types_with_hot_replace = 10;

        // Type specific info
        optional ActionEntityTypeSpecificInfo type_specific_info = 11;

        // The entities this entity is connected to.
        repeated TopologyEntityDTO.ConnectedEntity connected_entities = 12;

        // The action orchestrator only needs certain fields from the TypeSpecificInfo of a
        // topology entity. We outline those fields here. This significantly reduces the memory
        // impact of loading ActionPartialEntities into the Action Orchestrator.
        message ActionEntityTypeSpecificInfo {

            oneof type {
                ActionVirtualMachineInfo virtual_machine = 1;
                ActionPhysicalMachineInfo physical_machine = 2;
                ActionComputeTierInfo compute_tier = 3;
                ActionStorageInfo storage = 4;
                ActionVolumeInfo volume = 5;
            }

            message ActionComputeTierInfo {
                optional string family = 1;
                optional string quota_family = 15;
                optional int32 num_cores = 12;
                optional .topology.TypeSpecificInfo.ComputeTierInfo.SupportedCustomerInfo supported_customer_info = 5;
            }

            message ActionVirtualMachineInfo {
                optional .topology.TypeSpecificInfo.VirtualMachineInfo.DriverInfo driver_info = 1;
                optional .topology.TypeSpecificInfo.Architecture architecture = 2;
                optional string locks = 3;
                optional .topology.TypeSpecificInfo.VirtualizationType virtualization_type = 4;
                // The CPU core MHz on the VM
                optional double cpu_core_mhz = 5;
                // Maps vStorage key to partition
                map<string,string> partitions = 6;
                //units for cpu reservation: mHz
                //units for mem reservation: MBytes
                map<int32,double> reservation_info = 7;

                // Count of how many ephemeral (e.g GCP Local SSD) disks are currently attached
                // to this VM. Set from VirtualMachineInfo.numEphemeralStorages.
                optional int32 attached_ephemeral_volumes = 8;

                // Whether any execution constraint related info was optionally sent by probe.
                // Used for GCP to disallow execution of scale actions with local SSDs attached.
                optional string execution_constraint = 9;

                // The minimum CPU platform required, if any. Sent by probe.
                // Used for GCP to disallow execution of scale actions for these VMs.
                optional string min_cpu_platform = 10;
            }

            message ActionPhysicalMachineInfo {
                // The CPU Core MHz on the host
                optional int32 cpu_core_mhz = 7;
            }

            message ActionStorageInfo {
                optional .common_dto.EntityDTO.StorageType storage_type = 1;
            }

            message ActionVolumeInfo {
               optional string locks = 1;
            }

        }
    }

    // Contains the fields required by the API for conversion to the external API's entities.
    //
    // Note - the API sometimes requires the full entity, but this is the detail level that will
    // work in most of the API's use cases.
    message ApiPartialEntity {
        required int64 oid = 1;

        optional string display_name = 2;

        required int32 entity_type = 3;

        optional .common.EnvironmentType environment_type = 4;

        optional .topology.EntityState entity_state = 5 [default = POWERED_ON];

        optional .tag.Tags tags = 10;

        // only used for real time market where the topology graph is available, otherwise it
        // would be expensive to get
        repeated RelatedEntity consumers = 19;

        repeated RelatedEntity providers = 20;

        repeated RelatedEntity connected_to = 22;

        // this is deprecated since this information can be obtained from origin
        map<int64, PerTargetEntityInformation> discovered_target_data = 23 [deprecated = true];

        message RelatedEntity {

            required int64 oid = 1;

            optional int32 entity_type = 2;

            // Currently this is populated only for realtime, since we don't need this information
            // for plan API calls
            // TODO: when this field is populated for plans, changes in ArangoDB will be required as well
            optional string display_name = 3;
        }

        // whether the entity is 'outdated' i.e. successfully discovered too long ago
        // defined at entity level although different parts of entity may have different 'staleness'
        optional bool stale = 18 [default = false];

        optional TopologyEntityDTO.Origin origin = 9;
    }

    // Contains the fields required by cluster headroom plan.
    message HeadroomPlanPartialEntity {
        required int64 oid = 1;

        optional string display_name = 2;

        required int32 entity_type = 3;

        optional .topology.EntityState entity_state = 4 [default = POWERED_ON];

        // list of commodities sold, which can be found in PlanDTOUtil
        repeated CommoditySoldDTO commodity_sold = 5;
    }

    // The type of the entity.
    // The index should align with the Type value.
    oneof type {
        .topology.TopologyEntityDTO full_entity = 1;
        MinimalEntity minimal = 2;
        EntityWithConnections with_connections = 4;
        EntityWithOnlyEnvironmentTypeAndTargets with_only_environment_type_and_targets = 12;

        ActionPartialEntity action = 10;
        ApiPartialEntity api = 11;
    }
}

message TopologyEntityDTO {

    // type of entity
    required int32 entity_type = 1;

    // Type-specific configuration of the entity.
    optional TypeSpecificInfo type_specific_info = 30;

    // object identifier
    required int64 oid = 2;

    // name to display in the UI
    optional string display_name = 3;

    // The environment type for the entity.
    //
    // The environment type is closely related to the origin, but we keep it outside
    // the origin because they are distinct concepts. The origin outlines how the entity came to
    // be included in the topology. The environment type specifies the subset of the topology the
    // entity belongs to.
    //
    // Some entities will only ever have one environment type (e.g. COMPUTE_TIER -> CLOUD,
    // PHYSICAL_MACHINE -> ON_PREM), whereas others (e.g. VMs) can have either.
    optional .common.EnvironmentType environment_type = 14;

    // list of commodities sold
    repeated CommoditySoldDTO commodity_sold_list = 4;

    // list of commodities bought group
    repeated CommoditiesBoughtFromProvider commodities_bought_from_providers = 5;

    // Describes errors related to this entity in various stages of the topology pipeline.
    // If unset, this entity has no errors.
    optional EntityPipelineErrors pipeline_errors = 15;

    // The commodities bought by this entity from a given provider. An entity may buy multiples sets
    // of commodities from the same provider and may not have providers. Consider the following potential
    // CommodityBoughtGroupings:
    // ["host1" -> { FOO, BAR }] and ["host1" -> { FOO }, "host1" -> { BAR }] and [ -> { QUX }]
    // In the top expression, the entity must buy FOO and BAR commodities from THE SAME provider and
    // that provider is currently "host1". If the market were to try to have this entity buy BAR commodity
    // from "host2" instead of "host1", the entity would also have to buy its FOO from "host2" as well.
    // In the second expression, the entity also must buy FOO and BAR commodities, but those are permitted
    // to come from DIFFERENT providers, it just happens that at this moment in time they are coming
    // from the same "host1" provider. So if the market were to decide to have this entity buy BAR
    // from "host2", it could continue to buy FOO from "host1" without issue.
    // In the third expressions, the entity want to but QUX, but it doesn't have a particular supplier.
    //
    // Note also that this message defines a market-related type of relationship between 2 entities.
    // This relationship is unidirectional and the semantic is consumer -> provider:
    // the entity defined in this TopologyEntityDTO is a consumer that buys a set of commodities
    // from the specified provider.
    // If the 2 entities only have a market-related type of relationship, then having this message
    // is enough, and you don't need to use the below "connected_entity_list" field (unless you have
    // other connections with other different entities, where a consumer->provider semantic is not
    // needed).
    message CommoditiesBoughtFromProvider {
        // id of provider, it could be empty when the entity is currently unplaced, or not have a
        // supplier for a particular set of commodities that it is buying
        optional int64 provider_id = 1;

        // entity type of provider. it represents commodities should bought
        // from which kind of entity type. Right now, it will not been used by Market, but in future,
        // this value could be useful in Market.
        // TODO: To make sure provider entity type is always non-empty.
        optional int32 provider_entity_type = 2;

        // a list of commodities bought from this provider
        repeated CommodityBoughtDTO commodity_bought = 3;

        // Whether the group of commodities bought can be moved from one provider to another provider.
        // If unset, the movable value for an entity will be calculated based on its entityType from
        // the list of movable types in AnalysisUtil.
        optional bool movable = 4;

        // Whether the group of commodities bought can be started on a one provider.
        optional bool startable = 6 [default = true];

        // Whether this entity is scalable.
        optional bool scalable = 7 [default = true];

        // id of the volume which is associated with this set of bought commodities, it is used to
        // support volumes in the cloud
        // volumes are either provider for vm (cloud) or connected from vm (on-prem)
        optional int64 volume_id = 5 [deprecated = true];
    }

    // entity state
    optional EntityState entity_state = 6 [default = POWERED_ON];

    // entity properties in free (string <-> string) form, used for probe-defined values.
    map<string, string> entity_property_map = 7;

    // Contains all settings for market analysis purpose.
    optional AnalysisSettings analysis_settings = 8;

    message AnalysisSettings {
        // Whether the entity could be a potential provider for consumers.
        optional bool is_available_as_provider = 1 [default = true];

        // ShopsTogether is set by the Probe and will be passed to Market.
        optional bool shop_together = 2 [default = false];

        // Whether the Market can clone this entity.
        // If unset, the clonable value for an entity will be calculated based on its entityType from
        // the list of ENABLE_PROVISION in EntitySettings.
        optional bool cloneable = 3;

        // Whether the Market can suspend this entity. And it's default value should be true.
        // If unset, the suspendable value for an entity will be calculated in Market component based
        // on its entityType from the list of ENABLE_SUSPEND types in EntitySettings.
        optional bool suspendable = 4 [default = true];

        // The desired utilization target value. Together with the
        // desired_utilization_range below, they describe the min and max
        // desired utilization values.
        optional float desired_utilization_target = 5 ;

        // The desired utilization target range
        optional float desired_utilization_range = 6 ;

        // Whether the entity can be resized down by Market. If true, Market is able to generate resize
        // down actions, if false, Market will not generate resize down actions.
        optional bool is_eligible_for_resize_down = 7 [default = false];

        // Whether the entity is in "control" state -- there are moves occurring on the entity so that
        // it can not move, clone, suspend, accept entities move into or out of itself
        optional bool controllable = 8 [default = true];

        // Whether a trader's provider should clone when the trader clones
        optional bool provider_must_clone = 9;

        // Whether the Market can delete this entity. Default is true.
        // If false, Market will not generate Delete Actions.
        optional bool deletable = 10 [default = true];

        // If true, it means we can consider resize up
        // and down for entity.
        optional bool is_eligible_for_scale = 11 [default = true];

        // Whether the trader is a daemon. Entities that cannot move off of their supplier and have
        // no meaning if moved off of that supplier are called daemons.  Daemons are identified by
        // the probes.  In Classic applications with type GuestLoad are also considered daemons,
        // even though the probes that create them do not currently mark them as daemons.
        optional bool daemon = 12 [default = false];

        // Rate of resize setting.
        optional float rate_of_resize = 13;

        // Can we reconfigure this trader.
        optional bool reconfigurable = 14;

        // The consistent scaling factor is used in the market on entities that consistently
        // scale. It converts values on commodities from the normalized units that the market
        // uses for computations back into the unit that commodities need to be consistent in
        // in the real world. For example, on containers in a scaling group that are required
        // to have a VCPU capacity consistent in millicores, the consistent_scaling_factor
        // can be used to convert VCPU capacities, used values, etc. from the normalized MHz
        // values that the market uses into millicores. This is important to ensure the market
        // generates actions that make sense in the unit the consistent scaling group must be
        // consistent in.
        optional float consistent_scaling_factor = 15 [default = 1.0];

        // Minimum replicas of trader during horizontal scale
        optional int32 min_replicas = 16;

        // Maximum replicas of trader during horizontal scale
        optional int32 max_replicas = 17;
    }

    optional Origin origin = 10;
    optional Edit edit = 11;

    // The Origin tracks where and how an entity came to be included in the topology.
    // An entity can have one of four possible Origins:
    //   1) discovered from a probe target (or multiple targets).
    //   2) created by a Placement Reservation
    //   3) Added as part of a plan scenario, such as an entity added by an "add workload" config,
    //      or headroom vm's added for cluster headroom calculation.
    //   4) Added by the market - for example, as a clone of an existing entity. This should never
    //      be set in a live or plan-over-live source topology, but entities in the projected
    //      topology or the plan-over-plan source topology may have this origin.
    message Origin {
        oneof origin_type {
            DiscoveryOrigin discovery_origin = 1;
            ReservationOrigin reservation_origin = 2;
            PlanScenarioOrigin plan_scenario_origin = 3;
            AnalysisOrigin analysis_origin = 4;
        }
    }

    // An entity that was discovered by a probe.
    message DiscoveryOrigin {
        // The ids of the one or more targets that discovered this entity.
        //
        // If more than one target is present in the list, those targets may or may not be associated
        // with the same type of probe.
        //
        // An example where the targets belong to the same type of probe: 3 VC targets discover
        // the same shared storage
        //
        // An example where the targets belong to different types of probe: 1 VC target and 1 NetApp target
        // discover the same storage device.
        //
        // The id of at least one target will always be in this list.
        // No guarantees are made about the order of the targets in the list.
        // deprecated in favor of discovered_target_data
        // please note that this deprecation/extension does not affect discovering_target_ids in
        // MinimalEntity/ActionPartialEntity/Group.DiscoveredOrigin, but does affect ApiPartialEntity
        repeated int64 discovering_target_ids = 1 [deprecated = true];

        // The time that the data for this entity was last updated.
        //
        // If the entity was discovered by multiple targets, this time is the time at which the
        // most recent update across all those targets provided new information for this entity.
        //
        // Important note: This is the time that TopologyProcessor received this data from the probe,
        // not the actual time that the probe retrieved the information from the target.
        //
        // This field may be used as a heuristic for the recency of the data in the absence of better information.
        // The time is in "computer time" and not necessarily UTC, however, times on TopologyEntityDTOs
        // are comparable. See documentation in Java's System#currentTimeMillis() for further details.
        optional int64 last_updated_time = 2;

        // non-empty map of target oid to related discovery information,
        // for all targets that contribute into entity (send the information)
        map<int64, PerTargetEntityInformation> discovered_target_data = 3;
    }

    // an entity that was created via a Placement reservation. Has a reference to it's reservation
    // id.
    message ReservationOrigin {
        required int64 reservation_id = 1;
    }

    // an entity can be created by a plan configuration to support plan scenarios, such as "Add
    // Workload", "Replace". Phantom Entities are also created in special situations, such as for
    // calculating headroom in the cluster headroom plan. The plan origin for these entities will
    // refer to the plan id the entity was added to support.
    message PlanScenarioOrigin {
        required int64 plan_id = 1;

        // the id of the entity it was cloned from.
        optional int64 original_entity_id = 2;

        // the target ids of the original entity
        repeated int64 original_entity_discovering_target_ids = 3;
    }

    // An entity created by the market's analysis, and included in the projected topology.
    message AnalysisOrigin {
        // If this entity was cloned by the market, this is the id of the entity it was cloned
        // from.
        optional int64 original_entity_id = 1;
    }

    // if the entity has met a (potentially grisly) end, describe it. Currently there are only two
    // edits being tracked:
    //   1) Removed -- the entity was Removed as part of a "remove" or "decommission" plan scenario
    //   2) Replaced -- the entity was Replaced in a plan scenario change.
    // We have discussed other possible types of edits in the future, such as "change workload", but
    // those are not necessary for modeling at this time and have alternate approaches available as
    // well.
    message Edit {
        oneof change_type {
            Removed removed = 1;
            Replaced replaced = 2;
        }
    }

    // this entity was Removed as part of a place scenario configuration.
    message Removed {
        required int64 plan_id = 1; // the plan calling for the entity's removal
    }

    // this entity was Replaced by another entity as part of a place scenario configuration.
    // We could potentially track the "replaced by" entity id here too, but that requires additional
    // complexity. We don't seem to need it yet, so leaving it out.
    message Replaced {
        required int64 plan_id = 1; // the plan calling for the entity's replacement
        optional int64 replacement_id = 2; // new entity that is replacing the target entity
    }

    // List of entities that are topologically connected with the entity that this probuf defines.
    repeated ConnectedEntity connected_entity_list = 12;

    // This message defines a topological connection between 2 entities.
    // This message needs to be used only to represent a topological relationship where the 2
    // entities are connected to each other, but they are not trading any resources between them.
    //
    // A connection between two entities A and B will appear only once in the broadcast,
    // either as one of the connections of A or as one of the connections of B. Which one
    // is used depends on the type of the connection.
    message ConnectedEntity {

        // Id of the entity on the other side of the connection
        optional int64 connected_entity_id = 1;

        // Type of the entity on the other side of the connection
        optional int32 connected_entity_type = 2;

        // Type of connection that this message is representing.
        optional ConnectionType connection_type = 3;

        // Type of connection that this message is representing. Different types means different
        // semantics
        enum ConnectionType {
            // Normal connection is a basic topology connection between two entities,
            // which only serves the purpose of traversability from the one to the other.
            // No other more precise semantics is implied.
            //
            // There is no direction in this connection; it should be understood as symmetrical.
            // Examples of normal connections:
            // (a) the connection between a compute tier and a storage tier
            // (b) the connection between a VM and a virtual volume
            // (c) the connection between a virtual volume and the availability zone it resides in
            //     (changing the semantics of this case is to be deferred for the future)
            //
            // In the topology broadcast, the connection appears only on one of the
            // records of the two connected entities.
            // (a) The connection between compute and storage tier
            //     appears in the compute tier record
            // (b) the connection between VM and volume appears in the VM record
            // (c) the connection between volume and zone appears in the volume record
            NORMAL_CONNECTION = 1;

            // Ownership is used when two entities not only are topologically connected,
            // but, in addition, one of the entities (the owned entity) cannot meaningfully exist
            // without the other (the owner). Examples of ownerships:
            // (a) Business accounts own workloads in the cloud (e.g., VMs, DBs)
            //     and applications
            // (b) Business accounts can own sub-accounts
            // (c) Regions own availability zones
            // (d) Cloud services own tiers
            //
            // The relationship is directional and should never form circles.
            // Each entity can have at most one owner.
            //
            // In the topology broadcast, the connection appears always in the record of the owner.
            OWNS_CONNECTION = 2;

            // Aggregation is a directional relationship between two entities, the "aggregator"
            // and the "aggregated entity". It denotes a notion of containment (e.g.,
            // the aggregated can be understood to be "inside" the aggregator), but it is less
            // strict than ownership, in two ways:
            // (a) An entity can have more than one aggregator
            // (b) An aggregated entity can exist meaningfully without its aggregator(s)
            // Aggregation should not form circles in the topology.
            //
            // Examples of aggregation:
            // (a) Availability zones aggregate cloud workloads
            // (b) In the absence of availability zones (e.g., Azure), regions aggregate cloud workloads
            // (c) Regions aggregate tiers
            // (d) Datacenters aggregate storage and PMs
            //
            // Attention!  In the topology broadcast, the connection appears always in the record of the
            // *aggregated entity*. This is the opposite of the convention that we use for ownership.
            // The reason for this inconsistent convention has to do with the memory efficiency
            // of the Market and the Cost component, which use TopologyEntityDTO objects directly
            // in their logic. Note that this is also the reverse of the SDK AGGREGATES_CONNECTION
            // connection type.
            AGGREGATED_BY_CONNECTION = 3;

            // Controlling is a directional relationship between two entities, the "controller"
            // and the "controlled entity".The semantics of a CONTROLLED_BY_CONNECTION are that the
            // "controlled" entities participate in the market and the market generates the action on these
            // "controlled" entities, but the action is actually executed on the "controller" entity.
            // The controller contains the information like size, number of instances.
            // When entities are controlled by controller:
            // 1. A controller may maintain the "desired state" for the controlled entities and will continuously
            // drive the controlled entities toward that desired state. Executing an action on the controlled entity
            // without adjusting the controller's desired state is futile because the controller will change the entity back.
            // 2. Often controlled entities are created as identical replicas specified by a configuration
            // known to and managed by the controller. When the market generates actions for these replicas, they may be
            // merged together on the controller where they are executed to minimize disruption and to make the actions
            // more understandable to the user in the UI.
            // Examples of Controls:
            // (a) WorkloadController controls the ContainerSpec
            // (b) AWS Auto-scaling-group controls the individual VMs under it
            // (c) Azure ScaleSet controls the individual VMs under it
            CONTROLLED_BY_CONNECTION = 4;
        }
    }

    // Entity tags
    optional .tag.Tags tags = 13;

    message EntityPipelineErrors {
        // Stitching-related errors, encoded in bit-array format.
        //
        // DO NOT compare this integer to the value of StitchingErrorCode below! This integer
        // is a bitfield where each bit represents a particular error code. The error codes
        // are defined in StitchingErrorCode, and the
        // com.vmturbo.common.protobuf.StitchingErrors utility class is available to work
        // with them in Java.
        optional int32 stitching_errors = 1;

        enum StitchingErrorCode {
            // A default error code for safety if we somehow end up working with different
            // versions of the protobuf.
            UNKNOWN = 0;

            // A commodity is bought from a provider that doesn't exist or is otherwise invalid.
            INVALID_COMM_BOUGHT = 1;

            // A commodity is sold to an entity that doesn't exist or is otherwise invalid.
            INVALID_COMM_SOLD = 2;

            // An entity is layered over an entity that doesn't exist or is otherwise invalid.
            INVALID_LAYERED_OVER = 3;

            // An entity consists of some entities that don't exist or are otherwise invalid.
            INVALID_CONSISTS_OF = 4;

            // There is a mismatch between the local ID used by an entity to address another
            // entity, and that entity's self-declared local ID.
            INCONSISTENT_KEY = 5;

            // An entity with a normal connection to another entity that does not exist.
            INVALID_NORMAL_CONNECTION = 6;

            // An entity with an owns connection to another entity that does not exist.
            INVALID_OWNS_CONNECTION = 7;

            // An entity with an aggregated by connection to another entity that does not exist.
            INVALID_AGGREGATED_BY_CONNECTION = 8;

            // An entity with an controlled by connection to another entity that does not exist.
            INVALID_CONTROLLED_BY_CONNECTION = 9;
        }
    }

    // the reason for unplaced entity
    repeated UnplacementReason unplaced_reason = 16;

    message UnplacementReason {
        // A list of resources that causes the unplacement.
        repeated FailedResources failed_resources = 1;

        message FailedResources {
            // The commodity type that causes the unplacement.
            optional CommodityType comm_type = 1;
            // The amount of quantity requested by buyer.
            optional double requested_amount = 2;
            // The max available amount quantity, only exist if there is a closest seller.
            optional double max_available = 3;
        }
        // The provider entity type which an unplaced entity looks for. It may not exist in certain
        // cases, e.g: add VM which comes from template that buys certain commodity no one
        // sells.
        optional int32 provider_type = 2;
        // The closest seller, for most cloud cases it doesnt exist.
        optional int64 closest_seller = 3;
        // Reason for the unplacement, other than insufficient resources.
        optional PlacementProblem placement_problem = 4;
        // The oid of the owner to whom the failed resource bundle belongs. Typically it is a
        // volume id.
        optional int64 resource_owner_oid = 5;

        // Types of placement Problems.
        enum PlacementProblem {
            // Cost data is not found which contributes to the unplacement.
            COSTS_NOT_FOUND = 0;

            // Entity is not controllable and it was not processed for placement.
            NOT_CONTROLLABLE = 1;
        }
        // Whether the reservation is failed in current timespan or historical timespan.
        optional bool is_current = 6;
        // The cluster or storage cluster name of the closest seller. It can be obtained in analysis.
        optional string closest_seller_cluster_name = 7;
        // The cluster or storage cluster oid of the closest seller. It can not be obtained in
        // analysis.
        optional int64 closest_seller_cluster_oid = 8;
    }

    repeated .common_dto.EntityDTO.EntityDetail details = 17;

    // whether the entity is 'outdated' i.e. successfully discovered too long ago
    // defined at entity level although different parts of entity may have different 'staleness'
    optional bool stale = 18 [default = false];
}

// related information for the target that discovers the entity
message PerTargetEntityInformation {
    // identifier for the entity as vendor sees it ("local name")
    // to be retained and passed to action execution, needs not be set
    optional string vendor_id = 1;
    // specifies the origin of an entity from the target
    optional .common_dto.EntityDTO.EntityOrigin origin = 2;
}

// The Topology Extension.
// Due to the fact that Action Merging/Action Conversion is tied to a particular Topology, the need for Topology Extensions arises.
// The Action Merging/Action Conversion is discovered by a probe, and is valid for a lifetime of a topology, which that particular discovery is a part of.
// We have to preserve the Action Merging/Action Conversion specs, so that any Plans for that topology will generate same types of actions as a real-time Market.
// By same type of action we mean that if actions would be merged/converted in a real-time Market, they would be merged/converted when running a Plan over
// the same Topology.
// So, essentially, the Topology Extension is something that is tied to a Topology, has the lifetime of that Topology, yet not a part of Topology.
// The Communication Matrix (Communication Topology) and Action Merging/Conversion data serve as examples.
message TopologyExtension {
    oneof extension {
        Matrix matrix = 1;
    }
    // The Network Topology extension.
    message Matrix {
        repeated OverlayVertex vertices = 1;
        repeated OverlayEdge edges = 2;
        repeated UnderlayStruct underlay = 3;
        repeated ConsumerToProvider consumer_to_provider = 4;
    }
}

// Message to hold original topology broadcast message.
message Topology {
    // The ID of the topology
    required int64 topology_id = 1;

    oneof segment {
        Start start = 2;
        Data data = 3;
        End end = 4;
    }

    // Marker message, declaring the start of topology broadcast
    message Start {
        // The basic information of topology
        optional TopologyInfo topology_info = 1;
    };
    // Message to hold real data of the topology - it is the chunk
    message Data {
        // The segments in the topology
        repeated DataSegment entities = 3;
    }
    // Data segment
    message DataSegment {
        oneof data_segment {
            TopologyEntityDTO entity = 1;
            TopologyExtension extension = 2;
        }
    }
    // Message to appear at the very end of topology broadcast
    message End {
        // Total number of entities sent (can be used for integrity checks)
        required uint64 total_count = 1;
    }
}

message ProjectedTopologyEntity {
    // The entity DTO representing the entity in the
    // projected topology.
    optional TopologyEntityDTO entity = 1;

    // Whether or not the entity is removed from the projected topology.
    // These are entities that are removed from the source topology by some action (e.g. a DELETE
    // action on Virtual Volumes).
    optional bool deleted = 2 [default = false];

    // The original price index of the entity. It is sent along with the projected topology
    // because we don't know the price index of an entity until the market analyzes a topology.
    // It is the consumer's responsibility to associate the price index with the TopologyEntityDTO
    // of the entity in the original (NOT the projected) topology.
    //
    // Note: If an entity from the original topology was skipped during conversion and does not
    // appear in the projected topology, it's the consumer's responsibility to use a default
    // price index for that entity.
    //
    // This will be unset if the entity did not exist in the original
    // topology.
    optional double original_price_index = 10 [default = 1.0];

    // The projected price index of the entity.
    optional double projected_price_index = 11 [default = 1.0];
}

// Message to hold topology, projected by market.
message ProjectedTopology {
    // GeneratedId of the topology created after the plan
    required int64 topology_id = 1;

    oneof segment {
        Metadata metadata = 2;
        Data data = 3;
        End end = 4;
    }

    // Marker message, declaring the start of the projected topology broadcast.
    // Includes auxiliary information specific to the projected topology that helps clients
    // process it properly.
    message Metadata {
        // The basic information of the source topology
        optional TopologyInfo source_topology_info = 1;

        optional int64 projected_topology_id = 3;

        // The OIDs of entities in the projected topology that are involved in actions.
        // This can be used by listeners to treat these entities differently from the rest.
        repeated int64 entities_involved_in_actions = 10;
    }

    // Message to hold real data of the topology - it is the chunk
    message Data {
        // The entities in the projected topology.
        repeated ProjectedTopologyEntity entities = 2;

        // The entities in the topology. This is deprecated.
        repeated TopologyEntityDTO __deprecated__entities = 1 [deprecated = true];
    }
    // Message to appear at the very end of topology broadcast
    message End {
        // Total number of entities sent (can be used for integrity checks)
        required uint64 total_count = 1;
    }
}

// Message to hold basic fields of topology
message TopologyInfo {
    // The ID of the topology
    optional int64 topology_id = 1;

    // For a plan it is the plan ID, for real time topology it is a number that uniquely identifies the source topology processor
    optional int64 topology_context_id = 2;

    // The time of the topology created.
    optional int64 creation_time = 3;

    // The type of topology
    optional TopologyType topology_type = 4 [default = REALTIME];

    // If the topology is to be scoped, the OIDs specified here seed the scoping expansion.
    repeated int64 scope_seed_oids = 5;

    // Plan-specific topology information.
    // Present IFF TopologyType is PLAN.
    optional PlanTopologyInfo plan_info = 6;

    // types of analyses to run with this topology
    repeated AnalysisType analysis_type = 7;

    // Scope's Entity Type (can be one of the values in .common_dto.EntityDTO.EntityType)
    optional int32 scope_entity_type = 8;
}

enum AnalysisType {
    MARKET_ANALYSIS = 0;
    WASTED_FILES = 1;
    BUY_RI_IMPACT_ANALYSIS = 2;
    WASTED_APP_SERVICE_PLANS = 3;
}

// Information specific to a topology generated for the purpose of a plan.
message PlanTopologyInfo {
    // The type of the plan project that initiated the topology broadcast.
    optional plan.PlanProjectType plan_project_type = 1 [default = USER];

    // The type of the plan initiated. For example, the plan_type could be OPTIMIZE_CLOUD_PLAN.
    optional string plan_type = 2;

    // The sub-type of the plan initiated. For example, the plan_sub_type could be the specific
    // optimize cloud plan type (like OPTIMIZE_CLOUD__RIBUY_ONLY)
    optional string plan_sub_type = 3;

    // Plan global setting
    optional plan.PlanGlobalSetting __deprecated_plan_global_setting = 4 [deprecated = true];
}

enum EntityState {
    POWERED_ON = 0;
    POWERED_OFF = 1;
    SUSPENDED = 2;
    MAINTENANCE = 3;
    FAILOVER = 4;
    UNKNOWN = 5;
}

enum TopologyType {
    REALTIME = 0;
    PLAN = 1;
}

message CommodityType {
    // Type of commodity
    required int32 type = 1;

    // The key of this commodity type
    optional string key = 2;
}

// Standard attributes of a commodity
// Numeration in the enum has to match exactly to ActionExecution.proto:CommodityAttribute
enum CommodityAttribute {
    // The capacity of a commodity is the "raw capacity" -- i.e. the total amount of the commodity
    // available for use, before considering any restrictions such as limits or utilization
    // threshold percentages.
    CAPACITY = 0;

    // If a limit exists on a commodity, it represents a cap or ceiling on the capacity that
    // should restrict the amount of the commodity that is actually available for allocation. Without
    // considering a utilization threshold policy, the amount of the commodity available for allocation
    // should be the minimum of (capacity, limit). Also, limit should be smaller than capacity for
    // the limit to be meaningful.
    //
    // Limits are optional, and by default, commodities are "unlimited". It seems that limits are
    // only used on VM CPU, Memory, and Network commodities.
    LIMIT = 1;

    // A reservation on a commodity functions almost like the opposite of a limit. If a commodity
    // has a "reserved" amount set, then that amount cannot be allocated. It is considered "reserved"
    // for a specific consumer for potential use and not available to other consumers.
    //
    // This is probably most relevant for commodities that can be overprovisioned, such as CPU or
    // Memory. A VM with a 2gb reservation and 8gb capacity, for example, would guarantee that the
    // PM sets aside at least 2gb for that VM to use, even if the actual amount in use is smaller.
    //
    // Reservations are also optional and the default state would be reserved = 0.
    RESERVED = 2;
}

//Changeable entity attributes, which can be target of Reconfigure actions
enum EntityAttribute {
    CORES_PER_SOCKET = 1;
    SOCKET = 2;
}

message CommodityBoughtDTO {

    required CommodityType commodityType = 1;

    optional double used = 2 [default = 0.0];

    optional double peak = 3 [default = 0.0];

    // Whether the commodity is active or not
    optional bool active = 4 [default = true];

    // A scale factor to multiply this commodity by before analysis, if present
    optional double scaling_factor = 5 [default = 1];

    // A collection of aggregated in different ways history values.
    optional HistoricalValues historical_used = 6;

    // A collection of aggregated in different ways history peak values.
    optional HistoricalValues historical_peak = 7;

    // The display name for specific commodity like port channel and net throughput.
    optional string display_name = 8;

    // The commodity keys of aggregate commodities, mainly for UCS port channel and net throughput.
    // Aggregates are the commodities under the same entity and parts of the current commodity, say
    // a port channel may be combined with multiple net throughputs, and these net throughputs are
    // the aggregates.
    repeated string aggregates = 9;

    optional double reserved_capacity = 10 [default = 0.0];

    // The resize target utilization used as a coefficient when resizing commodity quantity.
    optional double resize_target_utilization = 11 [default = 1.0];

    // Collection of commodity utilization points. The collection contains series of usage points
    // with given timestamp and interval between points.
    // Certain probes may send more than one point per discovery request.
    optional UtilizationData utilizationData = 12;
}

message CommoditySoldDTO {

    required CommodityType commodityType = 1;

    optional double used = 2 [default = 0.0];

    optional double peak = 3 [default = 0.0];

    optional double capacity = 4 [default = 0.0];

    optional double effectiveCapacityPercentage = 5 [default = 100];

    // This field is deprecated - No need to set reservedCapacity for CommoditySoldDTO
    optional double reservedCapacity = 6 [deprecated = true];

    optional bool isResizeable = 7 [default = true];

    optional bool isThin = 8 [default = true];

    // For DSPM_ACCESS commodity this is the id of the PhysicalMachine associated with the Storage
    // that sells this commodity. For DATASTORE commodity this is the id of the Storage associated
    // with the PhysicalMachine that sells this commodity.
    optional int64 accesses = 9;

    // Whether the commodity is active or not
    optional bool active = 10 [default = true];

    // related to resize increment
    optional float capacity_increment = 11 [default = 1.0];

    // A scale factor to multiply this commodity by before analysis, if present
    optional double scaling_factor = 13 [default = 1];

    // The min amount resource can be provided to consumer
    optional double min_amount_for_consumer = 14;

    // The max amount resource can be provided to consumer
    optional double max_amount_for_consumer = 15;

    // The max ratio between this commodity and a base commodity
    optional RatioDependency ratio_dependency = 16;

    // A collection of aggregated in different ways history values.
    optional HistoricalValues historical_used = 17;

    // A collection of aggregated in different ways history peak values.
    optional HistoricalValues historical_peak = 18;

    // The resize target utilization. This will be used to resize entities already on cloud or
    // moving to the cloud in cloud migration plans.
    optional double resize_target_utilization = 19 [default = 1.0];

    // for VMem and VCpu include info on hot add/hot remove
    optional HotResizeInfo hot_resize_info = 20;

    // The display name for specific commodity like port channel and net throughput.
    optional string display_name = 21;

    // The commodity keys of aggregate commodities, mainly for UCS port channel and net throughput.
    // Aggregates are the commodities under the same entity and parts of the current commodity, say
    // a port channel may be combined with multiple net throughputs, and these net throughputs are
    // the aggregates.
    repeated string aggregates = 22;

    // Collection of commodity utilization points. The collection contains series of usage points
    // with given timestamp and interval between points.
    // Certain probes may send more than one point per discovery request.
    optional UtilizationData utilizationData = 23;

    // The thresholds (Ex. min/Max) for the commodity.
    optional Thresholds thresholds = 24;

    // A resold commodity is designed to model situations in which the true source of supply for
    // that resold commodity is further down the supply chain rather than directly through the entity
    // providing the commodity. In these cases, the true supplier is responsible for setting the
    // price of the resold commodity. For a real-life economic analogy, consider the case of buying
    // a BigMac at McDonald's - the individual restaurant does not get to set the price. Instead,
    // the price may be set by the franchise based on national or regional prices of its
    // ingredients along with other factors. Useful in situations where an entity's direct provider
    // represents more of a logical grouping of entities rather than a proper supplier of resources ie
    // a Container buying from a ContainerPod.
    optional bool is_resold = 25;

    // Whether min is a strict constraint. True when consumer must consume amount above min.
    optional bool check_min_amount_for_consumer = 26 [default = false];

    optional .common_dto.CommodityDTO.RangeDependency range_dependency = 27;

    // The max amount resource will be decided by another commodity's usage on the consumer
    message RatioDependency {
        // The type of commodity whose usage will be used as a factor.
        optional CommodityType base_commodity = 1;
        // The ratio which will be used to multiply with base commodity's usage.
        optional double max_ratio = 2;
        // The min ratio which will be used to multiply with base commodity's usage.
        optional double min_ratio = 3;
        // When consumer consumes amount more than (base amount * max_ratio), whether can directly
        // increase base amount to achieve max ratio dependency.
        optional bool increase_base_amount_default_supported = 4 [default = false];
    }

    message HotResizeInfo {
        optional bool hot_replace_supported = 1 [default = false];
        // whether or not this commodity supports hot add
        optional bool hot_add_supported = 2 [default = false];
        // whether or not this commodity supports hot remove
        optional bool hot_remove_supported = 3 [default = false];
    }

    // Threshold set for the commodity. The min/Max will be used by market to adjust resize actions.
    message Thresholds {
        // The min threshold of the commodity. We keep this to adjust the resize down actions.
        optional double min = 1;
        // The Max threshold of the commodity. We keep this to adjust the resize up actions.
        optional double max = 2;
    }

}

message IpAddress {
    // A single IP Address.
    optional string ip_address = 1;

    // True if the ipAddress is elastic.  This is relevant for cloud targets only.
    optional bool is_elastic = 2;
}

message OS {
    // The OS type for cloud cost calculation.
    optional .common_dto.OSType guest_os_type = 1 [default = UNKNOWN_OS];

    // The original OS name.
    optional string guest_os_name = 2;
}

message DiskTypeInfo {
    // Number of discovered solid state drives.
    optional int64 num_ssd = 1;

    // Number of discovered 7200 RPM disks.
    optional int64 num_7200_disks = 2;

    // Number of discovered 10000 RPM disks.
    optional int64 num_10_k_disks = 3;

    // Number of discovered 15000 RPM disks.
    optional int64 num_15_k_disks = 4;

    // Number of discovered VSeries disks.
    optional int64 num_v_series_disks = 5;
}

// Specific data for geo locations.
message GeoDataInfo {
    // latitude coordinates of geo location.
    required double latitude = 1;

    // longitude coordinates of geo location.
    required double longitude = 2;
}

// A message containing the id of a projected topology
message ProjectedTopologyInfo {
    optional int64 projected_topology_id = 1;
}

// Aggregated commodity historical values for analysis.
// Certain commodities may have more than one kind of a value.
message HistoricalValues {
    // Absolute maximum value within retention period.
    optional double max_quantity = 1;

    // Weighted average with previous utilization - peaks are smoothed out.
    // The latest point is the most significant one.
    optional double hist_utilization = 2;

    // Values averaged across equal time periods within a day for specified observation window.
    repeated double time_slot = 3;

    // Nth percentile of utilizations across specified observation window.
    optional double percentile = 4;

    // A combination of the moving mean and moving standard deviation of
    // the usage. A common value might be something like:
    // mean + 2 * std_deviation.
    optional double moving_mean_plus_standard_deviations = 5;
}

// Represents a collection of utilization data points.
message UtilizationData {
    // Array of data points. The last element in the array refers to the latest point in time.
    repeated double point = 1;

    // The timestamp of the last (the most recent) point in the array.
    required int64 lastPointTimestampMs = 2;

    // Interval in milliseconds between 2 consecutive points in the array.
    required int32 intervalMs = 3;
}

// A short description of what a topology contains. The description is useful when you are interested
// in the IDEA of topologies but you don't want to have to read the whole thing!
//
// Note - some components may persist this in the database, so changes to this message need to be
// backwards compatible.
message TopologySummary {

    // Information about the topology.
    optional TopologyInfo topology_info = 1;

    // Whether or not the topology was successfully broadcast.
    oneof result {
        // If the topology broadcast successfully, this can contain additional information.
        TopologyBroadcastSuccess success = 10;

        // If the topology failed to broadcast, this contains information about why it failed.
        TopologyBroadcastFailure failure = 11;
    }
}

// Notification that a topology was successfully broadcast.
message TopologyBroadcastSuccess {
    // TBD: a summary of the contents of the topology, including the workload count or the raw
    // data that can be used to derive the workload count, so that we can resolve OM-37431
}

// Notification that a topology failed to broadcast due to some fatal error during the running
// of the topology pipeline.
message TopologyBroadcastFailure {
    // The description of the error.
    optional string error_description = 1;
}

// A summary message containing information about the action plan generated by a market analysis.
message ActionPlanSummary {
    optional int64 action_plan_id = 1;
}

// A message containing the results obtained by the analysis of the market
message AnalysisSummary {
    optional ProjectedTopologyInfo projected_topology_info = 1;
    optional TopologyInfo source_topology_info = 2;
    optional ActionPlanSummary action_plan_summary = 3;
}

// A message containing a list of entities that changed state and an id that can be compared with
// topology ids
message EntitiesWithNewState {
    // The entities that changed state
    repeated TopologyEntityDTO topology_entity = 1;

    // This represent the same incremental id used for topologies. With this we can easily
    // compare topologies that have been built after the events were detected
    optional int64 state_change_id = 2;
}

// A notification describing changes regarding a plan export operation.
message PlanExportNotification {
    oneof type {
        // Updates regarding activity of an in-progress export.
        PlanExportUpdate progress_update = 1;

        // Updates state changes to an export operation.
        PlanExportUpdate state_change = 2;
    }
}

// A message describing changes in the status of a plan export operation.
message PlanExportUpdate {
    // The OID for the plan destination to which the export is directed.
    required int64 plan_destination_id = 1;

    // The new state for the export operation.
    required plan.PlanExportStatus status = 2;
}

// A request to assemble the current topology and broadcast it to all listeners for the topology.
message TopologyBroadcastRequest {
    // Currently no properties.
}

// The response to a request to broadcast the topology.
message TopologyBroadcastResponse {
    // Currently no properties.
    // TODO: Make topology broadcasts a first-class object similar to all TP operations (discovery, action, etc).
}

service TopologyService {
    // Request that the topology processor broadcast the latest topology to all its listeners.
    // Does not actually provide the topology in the response.
    rpc RequestTopologyBroadcast(TopologyBroadcastRequest) returns (TopologyBroadcastResponse);

    // Request that the topology processor broadcast the latest topology to all its listeners AND
    // return the topology to the caller as a stream of Topology messages.
    rpc BroadcastAndReturnTopology(TopologyBroadcastRequest) returns (stream Topology);
}

// Reservation Mode specification to determine what the type of behavior Placement entities should
// take.
enum ReservationMode {

    // Entities of the same reservation may be placed across multiple ReservationGroupings.
    NO_GROUPING = 1;

    // Entities of the same reservation will be placed within the same ReservationGrouping.
    AFFINITY = 2;
}

// Reservation Grouping specification to determine what group type entities should be placed on
// corresponding to the Mode of the reservation.
enum ReservationGrouping {

    // Do not restrict ReservationMode behavior on a specific grouping level.
    NONE = 1;

    // Restrict ReservationMode behavior on a Cluster level.
    CLUSTER = 2;
}
