syntax = "proto2";
package topology;

option java_package = "com.vmturbo.common.protobuf.topology";

import "plan/PlanDTO.proto";

message TopologyEntityDTO {

    // type of entity
    required int32 entityType = 1;

    // object identifier
    required int64 oid = 2;

    // name to display in the UI
    optional string displayName = 3;

    // list of commodities sold
    repeated CommoditySoldDTO commoditySoldList = 4;

    // list of commodities bought group
    repeated CommoditiesBoughtFromProvider commodities_bought_from_providers = 5;

    // The commodities bought by this entity from a given provider. An entity may buy multiples sets
    // of commodities from the same provider and may not have providers. Consider the following potential
    // CommodityBoughtGroupings:
    // ["host1" -> { FOO, BAR }] and ["host1" -> { FOO }, "host1" -> { BAR }] and [ -> { QUX }]
    // In the top expression, the entity must buy FOO and BAR commodities from THE SAME provider and
    // that provider is currently "host1". If the market were to try to have this entity buy BAR commodity
    // from "host2" instead of "host1", the entity would also have to buy its FOO from "host2" as well.
    // In the second expression, the entity also must buy FOO and BAR commodities, but those are permitted
    // to come from DIFFERENT providers, it just happens that at this moment in time they are coming
    // from the same "host1" provider. So if the market were to decide to have this entity buy BAR
    // from "host2", it could continue to buy FOO from "host1" without issue.
    // In the third expressions, the entity want to but QUX, but it doesn't have a particular supplider.
    message CommoditiesBoughtFromProvider {
        // id of provider, it could be empty when the entity is currently unplaced, or not have a
        // supplier for a particular set of commodities that it is buying
        optional int64 provider_id = 1;

        // entity type of provider. it represents commodities should bought
        // from which kind of entity type. Right now, it will not been used by Market, but in future,
        // this value could be useful in Market.
        // TODO: To make sure provider entity type is always non-empty.
        optional int32 provider_entity_type = 2;

        // a list of commodities bought from this provider
        repeated CommodityBoughtDTO commodity_bought = 3;

        // Whether the group of commodities bought can be moved from one provider to another provider.
        // If unset, the movable value for an entity will be calculated based on its entityType from
        // the list of movable types in AnalysisUtil.
        optional bool movable = 4;
    }

    // entity state
    optional EntityState entityState = 6 [default = POWERED_ON];

    // entity properties in free (string <-> string) form, used for probe-defined values.
    map<string, string> entityPropertyMap = 7;

    // Contains all settings for market analysis purpose.
    optional AnalysisSettings analysis_settings = 8;

    message AnalysisSettings {
        // Whether the entity could be a potential provider for consumers.
        optional bool is_available_as_provider = 1 [default = true];

        // ShopsTogether is set by the Probe and will be passed to Market.
        optional bool shop_together = 2 [default = false];

        // Whether the Market can clone this entity.
        // If unset, the clonable value for an entity will be calculated based on its entityType from
        // the list of ENABLE_PROVISION in EntitySettings.
        optional bool cloneable = 3;

        // Whether the Market can suspend this entity.
        // If unset, the suspendable value for an entity will be calculated based on its entityType from
        // the list of ENABLE_SUSPEND types in EntitySettings.
        optional bool suspendable = 4;

        // The desired utilization target value. Together with the
        // desired_utilization_range below, they describe the min and max
        // desired utilization values.
        optional float desired_utilization_target = 5 ;

        // The desired utilization target range
        optional float desired_utilization_range = 6 ;
    }
}

// Message to hold original topology broadcast message.
message Topology {
    // The ID of the topology
    required int64 topology_id = 1;

    oneof segment {
        Start start = 2;
        Data data = 3;
        End end = 4;
    }

    // Marker message, declaring the start of topology broadcast
    message Start {
        // The basic information of topology
        optional TopologyInfo topology_info = 1;
    };
    // Message to hold real data of the topology - it is the chunk
    message Data {
        // The entities in the topology
        repeated TopologyEntityDTO entities = 1;
    }
    // Message to appear at the very end of topology broadcast
    message End {
        // Total number of entities sent (can be used for integrity checks)
        required uint64 total_count = 1;
    }
}

// Message to hold topology, projected by market.
message ProjectedTopology {
    // GeneratedId of the topology created after the plan
    required int64 topology_id = 1;

    oneof segment {
        Start start = 2;
        Data data = 3;
        End end = 4;
    }

    // Marker message, declaring the start of topology broadcast
    message Start {
        // The basic information of the source topology
        optional TopologyInfo source_topology_info = 1;
    };
    // Message to hold real data of the topology - it is the chunk
    message Data {
        // The entities in the topology
        repeated TopologyEntityDTO entities = 1;
    }
    // Message to appear at the very end of topology broadcast
    message End {
        // Total number of entities sent (can be used for integrity checks)
        required uint64 total_count = 1;
    }
}

// Message to hold basic fields of topology
message TopologyInfo {
    // The ID of the topology
    optional int64 topology_id = 1;

    // For a plan it is the plan ID, for real time topology it is a number that uniquely identifies the source topology processor
    optional int64 topology_context_id = 2;

    // The time of the topology created.
    optional int64 creation_time = 3;

    // The type of topology
    optional TopologyType topology_type = 4 [default = REALTIME];

    // If the topology is to be scoped, the OIDs specified here seed the scoping expansion.
    repeated int64 scope_seed_oids = 5;

    // Plan-specific topology information.
    // Present IFF TopologyType is PLAN.
    optional PlanTopologyInfo plan_info = 6;
}

// Information specific to a topology generated for the purpose of a plan.
message PlanTopologyInfo {
    // The type of the plan project that initiated the topology broadcast.
    optional plan.PlanProjectType plan_type = 1 [default = USER];
}

enum EntityState {
    POWERED_ON = 0;
    POWERED_OFF = 1;
    SUSPENDED = 2;
    MAINTENANCE = 3;
    FAILOVER = 4;
    UNKNOWN = 5;
}

enum TopologyType {
    REALTIME = 0;
    PLAN = 1;
}

message CommodityType {
    // type of commodity
    required int32 type = 1;

    // the key of this commodity type
    optional string key = 2;
}

message CommodityBoughtDTO {

    required CommodityType commodityType = 1;

    optional double used = 2 [default = 0.0];

    optional double peak = 3 [default = 0.0];

    // Whether the commodity is active or not
    optional bool active = 4 [default = true];
}

message CommoditySoldDTO {

    required CommodityType commodityType = 1;

    optional double used = 2 [default = 0.0];

    optional double peak = 3 [default = 0.0];

    optional double capacity = 4 [default = 100];

    optional double effectiveCapacityPercentage = 5 [default = 100];

    optional double reservedCapacity = 6 [default = 0.0];

    optional bool isResizeable = 7 [default = true];

    optional bool isThin = 8 [default = true];

    // For DSPM_ACCESS commodity this is the id of the PhysicalMachine associated with the Storage
    // that sells this commodity. For DATASTORE commodity this is the id of the Storage associated
    // with the PhysicalMachine that sells this commodity.
    optional int64 accesses = 9;

    // Whether the commodity is active or not
    optional bool active = 10 [default = true];

    // related to resize increment
    optional float capacity_increment = 11 [default = 1.0];
}

// A request to assemble the current topology and broadcast it to all listeners for the topology.
message TopologyBroadcastRequest {
    // Currently no properties.
}

// The response to a request to broadcast the topology.
message TopologyBroadcastResponse {
    // Currently no properties.
    // TODO: Make topology broadcasts a first-class object similar to all TP operations (discovery, action, etc).
}

service TopologyService {
    // Request that the topology processor broadcast the latest topology to all its listeners.
    rpc RequestTopologyBroadcast(TopologyBroadcastRequest) returns (TopologyBroadcastResponse);
}
