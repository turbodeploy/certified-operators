syntax = "proto2";
package cca;

option java_package = "com.vmturbo.common.protobuf.cca";
option java_outer_classname = "CloudCommitmentAnalysis";

import "CloudCostDTO.proto";

// Demand classification based on the allocated compute tier of the entity
enum AllocatedDemandClassification {

    // The demand represents the current allocated tier of the represented entities.
    ALLOCATED = 1;

    // Demand for an entity, which is not the current/last allocated tier of the entity, but could
    // flexibly be covered by the same commitment as the entities current/latest allocation.
    FLEXIBLY_ALLOCATED = 2;

    // Demand for an entity that is not the current/last allocated tier of the entity and is not
    // within the same instance family.
    STALE_ALLOCATED = 3;

    // Represents short lived demand that should be ignored for coverage and recommendation analysis.
    EPHEMERAL = 4;
}

enum ProjectedDemandClassification {

    // Represents demand for an entity where allocated = market derived demand for a configurable
    // duration of time.
    OPTIMIZED = 1;

    // Represents demand where the market derived demand is consistent for a configurable duration
    // of time. Essentially, this is an entity (VM, DB, etc) with a consistent recommendation to
    // scale to a specific instance size.
    STABLE = 2;

    // Represents market derived demand in which the destination tier is not consistent for a single
    // entity, but all demand tiers are withing a "familY'. For example, for VM demand, a VM may
    // have scaling actions to scale to a t2.medium and t2.large. To be categorized as flexibly stable,
    // the source tier of the entity must be in a different family from the destination.
    FLEXIBLY_STABLE = 3;

    // Represents market derived demand similar to flexibly stable demand. However, for flexibly optimized
    // demand, the source and destination tiers of the entity must be in the same family.
    FLEXIBLY_OPTIMIZED = 4;

    // A market derived demand classification, in which the the demand does not fit any of the other market
    // derived classifications. Unstable demand may be due to inconsistent scaling actions of an entity
    // or a lack of sufficient demand to accurately classify the demand (e.g. if the workload recently
    // launched).
    UNSTABLE = 5;
}

// The scope of demand supported for an analysis.
message DemandScope {

    repeated int64 entity_oid = 1;

    repeated int64 service_provider_oid = 2;

    repeated int64 account_oid = 3;

    repeated int64 region_oid = 4;

    repeated int64 cloud_tier_oid = 5;

    // For different types of demand (e.g. compute vs. database tiers), this is the tier-specific
    // scoping supported by CCA.
    oneof type_specific_scope {
        ComputeTierDemandScope compute_tier_scope = 7;
    }

    // Scoping of compute tier demand, which allows filtering by the OS and tenancy of the demand.
    message ComputeTierDemandScope {
        repeated common_dto.OSType platform = 1;
        repeated common_dto.Tenancy tenancy = 2;
    }
}

message DemandSelection {
    optional DemandScope scope = 1;

    // Whether terminated instances should be included in the analysis|recommendation. Terminated
    // entities are determined by the presence (or lack thereof) of the entity within the topology.
    optional bool include_terminated_entities = 6 [default = true];

    // Whether suspended instances should be included in the analysis|recommendation. Suspended
    // entities are  determined by the state of the entity not being POWERED_ON
    optional bool include_suspended_entities = 7 [default = true];

}

message AllocatedDemandSelection {

    optional DemandSelection demand_selection = 1;

    // Whether flexibly allocated demand should be included for coverage/recommendation analysis.
    // Only allocated and flexibly allocated demand are currently supported - ephemeral and
    // stale demand will always be dropped.
    optional bool include_flexible_demand = 2 [default = true];
}

message ProjectedDemandSelection {
    required DemandSelection demand_selection = 1;

    repeated ProjectedDemandClassification classifications = 2;
}

// Contains info to resolve the topology to use during analysis
message TopologyReference {

    // If the topology context ID is not assigned, the realtime topology will be assumed.
    optional int64 topology_context_id = 1;

    // While the repository accepts a topology ID for realtime topologies, it is only used for plans
    // to resolve the corresponding topology
    optional int64 topology_id = 2;
}

// A configuration for a complete cloud commitment analysis.
message CloudCommitmentAnalysisConfig {

    // The topology associated with the analysis. This topology info will be used to verify
    // entity termination and check the validity of cloud commitment specs against the existing
    // cloud tiers. If the topology reference is not specified, the latest realtime topology will
    // be used.
    optional TopologyReference topology_reference = 1;

    // A tag used by the analysis in any log messages. The contents of the tag have no impact on
    // the analysis.
    optional string analysis_tag = 2 [default = ""];

    // The configuration for which demand should be considered by the entire analysis. This specifies
    // which demand should be pulled from the database
    required HistoricalDemandSelection demand_selection = 3;

    // The configuration for how selected demand should be classified and which demand should be
    // selected for analysis (uncovered demand calculations & recommendations). Generally, configuration
    // provides a way for allocated recommendations to ignore stale demand,
    optional DemandClassificationSettings demand_classification_settings = 4;

    // The purchase profiles to recommend. The purchase profiles are scoped to demand so that a single
    // analysis may recommend a certain RI configuration for AWS and another for Azure. The purchase
    // profile will also indicates which demand classifications can drive the recommendations.
    required CommitmentPurchaseProfile purchase_profile = 5;

    // The cloud commitment (RI, savings plan, etc) inventory to consider in calculating uncovered
    // demand from the total demand stored in the DB.
    optional CloudCommitmentInventory cloud_commitment_inventory = 6;

    optional DebugConfiguration debug_configuration = 7;
}

// The historical demand to select as the source of the analysis.
message HistoricalDemandSelection {

    // The type of demand to select (e.g. compute or DB server).
    required CloudTierType cloud_tier_type = 1;

    optional AllocatedDemandSelection allocated_selection = 2;

    optional ProjectedDemandSelection projected_selection = 3;

    // The time (in UTC epoch millisecond) for which the analysis should filter an demand
    // prior. If not specified, all recorded demand in scope is considered. Any demand in which the
    // demand segment stretches across the look_back_start_time will be split.
    optional int64 look_back_start_time = 4;

    // If true, a detailed summary of historical demand is collected and logged. The detailed summary
    // includes a breakdown of demand by cloud tier and day.
    optional bool log_detailed_summary = 5 [default = false];

    enum CloudTierType {
        COMPUTE_TIER = 1;
    }
}

// Contains criteria for how selected demand should be classified and once classified, which demand
// (based on the classifications) should be considered for analysis (calculating uncovered demand and
// making recommendations).
message DemandClassificationSettings {

    // How to classify the selected allocated historical demand
    optional AllocatedClassificationSettings allocated_classification_settings = 1;

    // How to classify the selected projected historical demand
    optional ProjectedClassificationSettings projected_classification_settings = 2;

    // If true, a detailed summary of classified demand is collected and logged. The detailed summary
    // includes a breakdown of demand by cloud tier, region, and account.
    optional bool log_detailed_summary = 3 [default = false];


    message AllocatedClassificationSettings {
        // This is the minimum amount of time an entity must be powered on for a single allocation
        // segment (single instance in which it is powered on) for the demand to not be considered
        // ephemeral.
        optional int64 min_stability_millis = 1 [default = 0];
    }

    // Specifies how to classify projected demand, which is based on the scaling behavior
    // of individual entities
    message ProjectedClassificationSettings {

        // The minimum total time required to classify an instance. Any instance with uptime less
        // that the minimum observation time will be classified as UNSTABLE. The uptime of an entity
        // is the aggregate uptime across the look back window. For example, if a VM is powered on
        // from 9 am -> 5 pm every day, after 3 days it would have an aggregate observation time
        // of 24 hours.
        optional int64 min_observation_millis = 1 [default = 0];

        // For the total observed time of an instance, how much of the observed time must the
        // entity be in a consistent state in order to be classified as (flexibly) stable or optimized.
        optional double scaling_consistency_percent = 2 [default = 100.0];

        // This is the minimum consecutive allocated time of all allocation segments (all instances
        // the entity is powered on) before the VM will have a stable allocated instance type. For example,
        // If the min_allocation_millis = 24 hours and a VM is powered on for 8 hours of the day, it will
        // need 3 consecutive days on the same instance type before we consider it's allocated instance
        // type as stable. Without an allocated instance type, all demand will be considered unstable.
        optional int64 min_allocation_millis = 3 [default = 0];

        // Whether to only consider the latest classification of an entity. This setting will only tie
        // in when the scaling_consistency_percent is less than 100%. For example, if the scaling
        // consistency is 95% of an entities observed time and a VM is optimized for the first
        // 95% and unstable for the remaining 5%, any demand outside the latest will be classified
        // as unstable (if use_latest == true).
        optional bool use_latest = 4 [default = false];
    }
}

// The purchase profile to recommend.
message CommitmentPurchaseProfile {

    // The commitment recommendation demand selection may have distinct demand from the demand
    // selection above. However, any demand not included in the demand selection will be ignored.

    optional AllocatedDemandSelection allocated_selection = 1;

    optional ProjectedDemandSelection projected_selection = 2;

    // The settings to use as part of the purchase profile, including the target savings over
    // on-demand and whether terminated instance demand should be included in the recommendation.
    optional RecommendationSettings recommendation_settings = 3;

    // The specific attributes of a purchase profile or a type of cloud commitment (e.g. RIs).
    oneof commitment_specific_profile {
        ReservedInstancePurchaseProfile ri_purchase_profile = 4;
    }

    // If true, a detailed summary of the CCA spec matcher is collected and logged. The detailed
    // summary includes a breakdown of total uncovered demand and the number of specs matched to the
    // demand.
    optional bool log_detailed_summary = 5 [default = false];

    // Settings beyond the purchase profile which will drive the recommendation analysis after
    // uncovered demand is calculated
    message RecommendationSettings {

        // The minimum savings over on-demand is the minimum percentage (0.0 -> 100.0) expected
        // from a potential CC buy recommendation, in order to generate a buy action.
        optional double minimum_savings_over_on_demand_percent = 1 [default = 10.0];

        // This setting is a way to specify the maximum coverage percentage to consider in
        // justifying a recommendation. It represents the max percentage of the total demand in scope
        // of a potential recommend that can be considered to justify the recommendation. For example,
        // if the max_demand_percent == 80% and there are 10 VMs that may be covered by a recommendation,
        // of which 6 are already covered by existing RIs, the RI recommendation may only consider the
        // remaining 2 instances under 80% of the total demand in justifying a purchase recommendation.
        //
        // Note: If a recommendation is purchased, this setting does not guarantee the coverage percentage
        // of the environment will not be above this maximum. It only indicates that the recommendation
        // can be justified, based on the percentage of demand specified.
        optional double max_demand_percent = 2 [default = 100.0];

    }

    // A purchase profile specific to buying a reserved instance.
    message ReservedInstancePurchaseProfile {
        map<int64, common_dto.ReservedInstanceType> ri_type_by_region_oid = 1;
    }
}

enum CloudCommitmentType {
    RESERVED_INSTANCE = 1;
}

message CloudCommitmentInventory {

    // The individual cloud commitments (e.g. RIs) to be included in
    // calculating uncovered demand.
    repeated CloudCommitment cloud_commitment = 1;

    message CloudCommitment {

        optional CloudCommitmentType type = 1;
        optional int64 oid = 2;

        // Capacity indicates how much of the RI should be included in calculating uncovered demand.
        // This is mainly applicable in plans, in which the plan scope may include a subset of the
        // total workload demand within the billing family. If this is not specified, the full
        // capacity of the CC is used.
        optional CloudCommitmentCapacity capacity = 3;


    }

    // How to calculate the capacity of a cloud commitment. The calculation supports exclusion (taking
    // the CC capacity minus some out of scope usage) or inclusion (basing CC on some historical usage).
    message CloudCommitmentCapacity {

        // Usage to ignore from the capacity_source. This can be used to simulate the removal
        // of specific entities/accounts from the topology.
        repeated CloudCommitmentUsage ignored_usage = 1;


        oneof capacity_source {
            ExclusionCapacitySource exclusion_capacity_source = 2;
            InclusionCapacitySource inclusion_capacity_source = 3;
        }

        message CloudCommitmentUsage {
            repeated int64 account_oid = 1;
            repeated int64 entity_oid = 2;
        }

        // An exclusion source is based on taking the CC capacity and subtracting some usage, where
        // the specified usage to exclude is expected to be out of scope of the analysis (e.g. in a plan
        // the usage to exclude may represent accounts in the billing family that are not in the plan
        // scope).
        message ExclusionCapacitySource {
            required CloudCommitmentUsage usage_to_exclude = 1;
        }

        // An inclusion source is based on taking historical usage in scope as the source of the CC
        // capacity. This provides a way to specify that the capacity of a CC available to a plan
        // or RT scope is the historical usage of the CCC by entities within the scope.
        message InclusionCapacitySource {
            required CloudCommitmentUsage usage_to_include = 1;

            // Whether any free capacity of the CC should be included in the capacity calculation.
            optional bool include_free_capacity = 2 [default = false];
        }
    }
}

message DebugConfiguration {

    // Determines which entities should selected for debug logging
    repeated DemandScope scope = 1;

    // If true, the selection of demand for entities from the DB will include debug information
    // for the entities above.
    optional bool trace_demand_selection = 2 [default = true];

}

// A representation of an analysis invocation of CCA.
message CloudCommitmentAnalysisInfo {

    // The OID of the analysis, assigned by the CCA in handling a start request.
    required int64 oid = 1;

    optional string analysis_tag = 2 [default = ""];

    required int64 creation_time = 3;

    optional TopologyReference topology_reference = 4;


}


// The status of an analysis
message Status {

    optional State state = 1;
    optional string message = 2;

    enum State {
        READY = 0;
        RUNNING = 1;
        COMPLETED = 2;
        FAILED = 3;
    }
}


