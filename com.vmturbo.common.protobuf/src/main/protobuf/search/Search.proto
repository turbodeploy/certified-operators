syntax = "proto2";
package search;

option java_package = "com.vmturbo.common.protobuf.search";

import "common/EnvironmentTypeEnum.proto";
import "common/Pagination.proto";
import "topology/TopologyDTO.proto";

// A search definition that needs to be performed on a topology, represented as a DAG.
message SearchParameters {

    // The filter on an entity property that will be used as a starting point.
    // Needed to avoid starting with a traversal filter, that will end up applying the traversal
    // to every entity in the topology, causing performance issues.
    optional PropertyFilter starting_filter = 2;

    // After the starting property filter, this is the ordered sequence of filters that needs to
    // be applied to the topology. Every filter will be applied to the result of the previous one.
    repeated SearchFilter search_filter = 3;

    // Source filter from which parameters were created
    optional FilterSpecs source_filter_specs = 4;

    // Specs of filter from which parameters were created
    message FilterSpecs {
        required string expression_type = 1;
        required string expression_value = 2;
        required string filter_type = 3;
        optional bool is_case_sensitive = 4 [default = false];
    }

}

// A filter that needs to be applied to the topology, in order to return a subset of the entities.
message SearchFilter {

    // There are 3 types of filters.
    // - traversal filter: used to traverse graph relationship
    // - property filter: used to specify specific criteria on properties of the element
    // - cluster membership filter: this is a special-case filter that will target members of
    // a cluster or set of clusters. This means storages or pm's. When you combine cluster filters
    // with other filter types, take care to ensure that the input to cluster filters
    // are storages or pm's, or you may get unexpected results (probably no results at all!).
    oneof filterType {
        TraversalFilter traversal_filter = 1;
        PropertyFilter property_filter = 2;
        ClusterMembershipFilter cluster_membership_filter = 3;
    }
}

// Filter used to traverse graph relationship.
message TraversalFilter {

    // Direction used for the traversal.
    optional TraversalDirection traversal_direction = 1;

    // Condition used to stop the graph traversal.
    optional StoppingCondition stopping_condition = 2;

    // Graph traversal stopping condition.
    message StoppingCondition {

        // There are 2 types of stopping condition:
        // - stop when you have reached the number of hops requested
        //      example: if you want to get all the providers of an entity, you can create a
        //      "consumes" traversal with 1 as a number of hop. This is because you want to
        //      traverse the relationship only 1 time. If you want the providers of the providers
        //      you can have 2 hops instead.
        // - Do not care about how many hops you are traversing, but stop only when a property
        //      condition is met, or you reach a leaf.
        oneof stoppingConditionType {
            int32 number_hops = 1;
            PropertyFilter stopping_property_filter = 2;
        }

        // Condition used to check the connected vertices after stop in the graph.
        optional VerticesCondition vertices_condition = 5;

        // Condition used to check the connected vertices after stop in the graph.
        // For example, if we want to get all PMs which host more than 5 VMs, it will traverse
        // from all PMs, stop at VMs and filter each PM based on the number of hosted VMs
        message VerticesCondition {
            // Filter by the number of connected vertices after stop in the graph
            optional PropertyFilter.NumericFilter num_connected_vertices = 1;

            // Filter by entity type of the connected vertices, for example: VM entity type
            optional int32 entity_type = 2;
        }
    }

    // Direction of the traversal along the DAG.
    enum TraversalDirection {
        // Right now we are supporting only one single directed edge/relationship.
        // Host           ---- Produces ---> VirtualMachine
        // VirtualMachine <--- Consumes ---- Host
        // where Consumes is the opposite direction (on the same edge) of Produces and
        // indicates that the Consumer is buying a commodity from the Producer.
        CONSUMES = 0;
        PRODUCES = 1;
        // BusinessAccount ---- ConnectedTo   ---> VirtualMachine
        // VirtualMachine  <--- ConnectedFrom ---- BusinessAccount
        // where ConnectedFrom is the opposite direction (on the same edge) of ConnectedTo
        CONNECTED_TO = 2;
        CONNECTED_FROM = 3;
    }
}

// Filter used to specify specific criteria on a property of the element.
message PropertyFilter {

    // Name of the property that we want to compare
    optional string property_name = 1;

    // Type of the property that we want to compare
    oneof propertyType {
        StringFilter string_filter = 2;
        NumericFilter numeric_filter = 3;
        MapFilter map_filter = 4;
        ListFilter list_filter = 5;
        ObjectFilter object_filter = 6;
    }

    message StringFilter {
        // Regular expression used against the property's value.
        optional string string_property_regex = 1;

        // If true, the regex should match.
        // If false, the regex should NOT match.
        optional bool match = 2 [default = true];

        // If true, the case of the letters should match.
        // False by default (i.e. case insensitive by default)
        optional bool case_sensitive = 3 [default = false];
    }

    message NumericFilter {
        // Operator used to compare the numeric property value and the requested value.
        optional ComparisonOperator comparison_operator = 1;

        // Requested value for the numeric property filtering.
        optional int64 value = 2;
    }

    // this is a filter for properties whose value is a map from strings to strings
    // for example, assume that the tags of an entity map key "user" to values { "peter", "paul" }.
    // then, a map filter with key "user" and value "peter" will accept the entity.
    // on the other hand, (key = "department", value = "paul") or (key = "user", value = "john")
    // will reject the entity.
    // if no value is specified, then the entity will be accepted if and only if the key exists.
    // if multiple values are given, then the entity will be accepted if at least one of the values matches.
    message MapFilter {
        // string checked against the tag key
        // the value in this field must much one of the tag keys of the entity
        optional string key = 1;

        // strings checked against the tag value
        // one of the strings in this field must match one of the tag values of the entity
        // if empty, this field is ignored
        repeated string values = 2;

        // True iff this is a multimap (multiple values per key are possible)
        optional bool is_multimap = 3 [default = true];
    }

    // This is a filter for property whose value is a list of elements. The elements can be one of
    // 3 types: string, number, object. It checks whether the list contains a specific element.
    // for example: if we want to find the entity which sells a "VMem" commodity whose capacity is
    // larger than 1024, then we can use this filter, define the propertyName as
    // "commoditySoldList", and set object_filter which contains two PropertyFilters:
    // one is StringFilter, whose property_name is "type" and value is "VMem"; the other one is
    // NumericFilter, whose property_name is "capacity", operator is ">" and value is "1024"
    message ListFilter {
        // The element of the list is one of three types: object, string or number.
        oneof list_element_type {
            // current list is a list of objects, check whether any object matches
            ObjectFilter object_filter = 1;
            // current list is a list of strings, check whether any string matches
            StringFilter string_filter = 2;
            // current list is a list of numbers, check whether any number matches
            NumericFilter numeric_filter = 3;
        }
    }

    // The filter used to check if an object matches. An object consists of multiple properties, so
    // this filter is made up of multiple property filters, each filter is for one property of the
    // object.
    // for example: filter entities whose displayName contains "abc" and state is "ACTIVE"
    message ObjectFilter {
        // list of property filters to check if the object matches, currently these filters
        // are AND together, we can extend it to OR if needed.
        repeated PropertyFilter filters = 1;
    }
}

// used to check if entities are part of a cluster.
//
// This filter gets special handling in SearchService, where the group information is resolved in a
// separate step from the other filtering mechanisms and then is translated to a String RegEx filter
// for checking if an entity id is part of the cluster.
//
// This is due to the group membership information being stored in a separate arango database from
// the topology information and disallowing "joining" the topology documents with group info
// documents. Perhaps, in the future, we can unify these in a way that allows the group filter to
// be handled in a way that is consistent with the other search filters, e.g. direct graph
// traversals in a single database/context. We could also generalize this to a "Group" filter if
// the need ever arises.
//
message ClusterMembershipFilter {
    // Specifies the group(s) to filter membership based on. NOTE: only string regexes on cluster
    // names are supported right now. We would need to enhance to allow selection on other cluster
    // properties and/or multiple property filter support if this is needed in the future.
    //
    // There is also a NameFilter available in the GroupDTO.proto that is a better modeling fit for
    // this filter's role, but we can't import that without creating a circular reference between
    // the two .proto files.
    optional PropertyFilter cluster_specifier = 1;
}

enum ComparisonOperator {
    // Equal to
    EQ = 0;

    // Not equal to
    NE = 1;

    // Greater than
    GT = 2;

    // Greater or equal than
    GTE = 3;

    // Less than
    LT = 4;

    // Less or equal than
    LTE = 5;
}

// The request to search entity oids based on a list of search parameters. Note that, search entity
// oids not need to perform pagination, because all the request needs to fetch all matched entity
//oids, and the search entity oid query should be finish quickly even in large topology environment.
message SearchEntityOidsRequest {
    repeated SearchParameters searchParameters = 1;

    // If the entity oids list is not empty, it means the search parameters will be only applied to those
    // entity oids, the response will be subset of those entity oids. If the entity oids list is empty,
    // it means the search parameters will be applied to global entities.
    repeated int64 entity_oid = 2;
}

message SearchEntityOidsResponse {
    // The OIDs of entities from the search result
    repeated int64 entities = 1;
}

message Entity {
    required int32 type = 1;

    required int64 oid = 2;

    optional string displayName = 3;

    optional int32 state = 4;

    // ids of the targets from which this entity was discovered
    repeated int64 target_ids = 5;
}

message SearchEntitiesRequest {
    repeated SearchParameters searchParameters = 1;

    // If the entity oids list is not empty, it means the search parameters will be only applied to those
    // entity oids, the response will be subset of those entity oids. If the entity oids list is empty,
    // it means the search parameters will be applied to global entities.
    repeated int64 entity_oid = 2;

    // If not set, use the default instance of PaginationParameters. The backend
    // will enforce a default ordering and limit, and retrieve the first page.
    optional common.PaginationParameters pagination_params = 3;
}

message SearchEntitiesResponse {
    // A list of matched entities.
    repeated Entity entities = 1;

    optional common.PaginationResponse pagination_response = 2;
}

message SearchTopologyEntityDTOsRequest {
    repeated SearchParameters searchParameters = 1;

    // If the entity oids list is not empty, it means the search parameters will be only applied to those
    // entity oids, the response will be subset of those entity oids. If the entity oids list is empty,
    // it means the search parameters will be applied to global entities.
    repeated int64 entity_oid = 2;
}

message SearchTopologyEntityDTOsResponse {
    // A list of matched entities.
    repeated .topology.TopologyEntityDTO topology_entity_dtos = 1;
}

message CountEntitiesRequest {
    repeated SearchParameters searchParameters = 1;
}

// response to CountEntitiesRequest messages
message EntityCountResponse {
    optional int32 entityCount = 1;
}

// request to the repository for existing tags
message SearchTagsRequest {
    // restrict request to tags of the specified entities
    // if this list is empty, there is no restriction on entities
    repeated int64 entities = 1;

    // restrict request to entities of this type
    optional int32 entity_type = 2;

    // environment type of entities to restrict search to
    optional common.EnvironmentType environmentType = 3;
}

// response to a SearchTagsRequest
message SearchTagsResponse {
    // A list of matched tags.
    map<string, topology.TopologyEntityDTO.TagValuesDTO> tags = 1;

    optional common.PaginationResponse pagination_response = 2;
}

// A service responsible for search operations.
service SearchService {
    // Search for entities based on the search parameters and return entity OID
    rpc SearchEntityOids(SearchEntityOidsRequest) returns (SearchEntityOidsResponse);

    // Search for entities based on the search parameters and return entity objects
    rpc SearchEntities(SearchEntitiesRequest) returns (SearchEntitiesResponse);

    // Search for TopologyEntityDTOs based on the search parameters and return TopologyEntityDTO objects
    rpc SearchTopologyEntityDTOs(SearchTopologyEntityDTOsRequest) returns (SearchTopologyEntityDTOsResponse);

    rpc CountEntities(CountEntitiesRequest) returns (EntityCountResponse);

    rpc SearchTags(SearchTagsRequest) returns (SearchTagsResponse);
}
