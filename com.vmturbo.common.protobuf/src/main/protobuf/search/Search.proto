syntax = "proto2";
package search;

option java_package = "com.vmturbo.common.protobuf.search";

import "common/Pagination.proto";

// A search definition that needs to be performed on a topology, represented as a DAG.
message SearchParameters {

    // The filter on an entity property that will be used as a starting point.
    // Needed to avoid starting with a traversal filter, that will end up applying the traversal
    // to every entity in the topology, causing performance issues.
    optional PropertyFilter starting_filter = 2;

    // After the starting property filter, this is the ordered sequence of filters that needs to
    // be applied to the topology. Every filter will be applied to the result of the previous one.
    repeated SearchFilter search_filter = 3;

    // Source filter from which parameters were created
    optional FilterSpecs source_filter_specs = 4;

    // Specs of filter from which parameters were created
    message FilterSpecs {
        required string expression_type = 1;
        required string expression_value = 2;
        required string filter_type = 3;
        optional bool is_case_sensitive = 4 [default = false];
    }

}

// A filter that needs to be applied to the topology, in order to return a subset of the entities.
message SearchFilter {

    // There are 3 types of filters.
    // - traversal filter: used to traverse graph relationship
    // - property filter: used to specify specific criteria on properties of the element
    // - cluster membership filter: this is a special-case filter that will target members of
    // a cluster or set of clusters. This means storages or pm's. When you combine cluster filters
    // with other filter types, take care to ensure that the input to cluster filters
    // are storages or pm's, or you may get unexpected results (probably no results at all!).
    oneof filterType {
        TraversalFilter traversal_filter = 1;
        PropertyFilter property_filter = 2;
        ClusterMembershipFilter cluster_membership_filter = 3;
    }

    // Filter used to traverse graph relationship.
    message TraversalFilter {

        // Direction used for the traversal.
        optional TraversalDirection traversal_direction = 1;

        // Condition used to stop the graph traversal.
        optional StoppingCondition stopping_condition= 2;

        // Graph traversal stopping condition.
        message StoppingCondition {

            // There are 2 types of stopping condition:
            // - stop when you have reached the number of hops requested
            //      example: if you want to get all the providers of an entity, you can create a
            //      "consumes" traversal with 1 as a number of hop. This is because you want to
            //      traverse the relationship only 1 time. If you want the providers of the providers
            //      you can have 2 hops instead.
            // - Do not care about how many hops you are traversing, but stop only when a property
            //      condition is met, or you reach a leaf.
            oneof stoppingConditionType {
                int32 number_hops = 1;
                PropertyFilter stopping_property_filter = 2;
            }
        }

        // Direction of the traversal along the DAG.
        enum TraversalDirection {
            // Right now we are supporting only one single directed edge/relationship.
            // Host           ---- Produces ---> VirtualMachine
            // VirtualMachine <--- Consumes ---- Host
            // where Consumes is the opposite direction (on the same edge) of Produces and
            // indicates that the Consumer is buying a commodity from the Producer.
            CONSUMES = 0;
            PRODUCES = 1;
        }
    }

}

// Filter used to specify specific criteria on a property of the element.
message PropertyFilter {

    // Name of the property that we want to compare
    optional string property_name = 1;

    // Type of the property that we want to compare
    oneof propertyType {
        StringFilter string_filter = 2;
        NumericFilter numeric_filter = 3;
        MapFilter map_filter = 4;
    }

    message StringFilter {
        // Regular expression used against the property's value.
        optional string string_property_regex = 1;

        // If true, the regex should match.
        // If false, the regex should NOT match.
        optional bool match = 2 [default = true];
    }

    message NumericFilter {
        // Operator used to compare the numeric property value and the requested value.
        optional ComparisonOperator comparison_operator = 1;

        // Requested value for the numeric property filtering.
        optional int64 value = 2;
    }

    // this is a filter for properties whose value is a map from strings to strings
    // for example, assume that the tags of an entity map key "user" to values { "peter", "paul" }.
    // then, a map filter with key regex "user" and value regex "pe.*" will accept the entity.
    // on the other hand, (key regex = "department", value regex = "paul") or
    // (key regex = "user", value regex = "john") will reject the entity.
    // currently only entity tags are properties of this type
    message MapFilter {
        // Regular expression used against the key
        optional string key_property_regex = 1;

        // Regular expression used against the value
        optional string value_property_regex = 2;

        // True iff this is a multimap (multiple values per key are possible)
        optional bool is_multimap = 3 [default = true];

        // If true, the regex should match.
        // If false, the regex should NOT match.
        optional bool match = 4 [default = true];
    }

}

// used to check if entities are part of a cluster.
//
// This filter gets special handling in SearchService, where the group information is resolved in a
// separate step from the other filtering mechanisms and then is translated to a String RegEx filter
// for checking if an entity id is part of the cluster.
//
// This is due to the group membership information being stored in a separate arango database from
// the topology information and disallowing "joining" the topology documents with group info
// documents. Perhaps, in the future, we can unify these in a way that allows the group filter to
// be handled in a way that is consistent with the other search filters, e.g. direct graph
// traversals in a single database/context. We could also generalize this to a "Group" filter if
// the need ever arises.
//
message ClusterMembershipFilter {
    // Specifies the group(s) to filter membership based on. NOTE: only string regexes on cluster
    // names are supported right now. We would need to enhance to allow selection on other cluster
    // properties and/or multiple property filter support if this is needed in the future.
    //
    // There is also a NameFilter available in the GroupDTO.proto that is a better modeling fit for
    // this filter's role, but we can't import that without creating a circular reference between
    // the two .proto files.
    optional PropertyFilter cluster_specifier = 1;
}

enum ComparisonOperator {
    // Equal to
    EQ = 0;

    // Not equal to
    NE = 1;

    // Greater than
    GT = 2;

    // Greater or equal than
    GTE = 3;

    // Less than
    LT = 4;

    // Less or equal than
    LTE = 5;
}

// The request to search entity oids based on a list of search parameters. Note that, search entity
// oids not need to perform pagination, because all the request needs to fetch all matched entity
//oids, and the search entity oid query should be finish quickly even in large topology environment.
message SearchEntityOidsRequest {
    repeated SearchParameters searchParameters = 1;

    // If the entity oids list is not empty, it means the search parameters will be only applied to those
    // entity oids, the response will be subset of those entity oids. If the entity oids list is empty,
    // it means the search parameters will be applied to global entities.
    repeated int64 entity_oid = 2;
}

message SearchEntityOidsResponse {
    // The OIDs of entities from the search result
    repeated int64 entities = 1;
}

message Entity {
    required int32 type = 1;

    required int64 oid = 2;

    optional string displayName = 3;

    optional int32 state = 4;
}

message SearchEntitiesRequest {
    repeated SearchParameters searchParameters = 1;

    // If the entity oids list is not empty, it means the search parameters will be only applied to those
    // entity oids, the response will be subset of those entity oids. If the entity oids list is empty,
    // it means the search parameters will be applied to global entities.
    repeated int64 entity_oid = 2;

    // If not set, use the default instance of PaginationParameters. The backend
    // will enforce a default ordering and limit, and retrieve the first page.
    optional common.PaginationParameters pagination_params = 3;
}

message SearchEntitiesResponse {
    // A list of matched entities.
    repeated Entity entities = 1;

    optional common.PaginationResponse pagination_response = 2;
}

message CountEntitiesRequest {
    repeated SearchParameters searchParameters = 1;
}

message EntityCountResponse {
    optional int32 entityCount = 1;
}

// A service responsible for search operations.
service SearchService {
    // Search for entities based on the search parameters and return entity OID
    rpc SearchEntityOids(SearchEntityOidsRequest) returns (SearchEntityOidsResponse);

    // Search for entities based on the search parameters and return entity objects
    rpc SearchEntities(SearchEntitiesRequest) returns (SearchEntitiesResponse);

    rpc CountEntities(CountEntitiesRequest) returns (EntityCountResponse);
}