syntax = "proto2";
package search;

option java_package = "com.vmturbo.common.protobuf.search";

import "common/EnvironmentTypeEnum.proto";
import "common/Pagination.proto";
import "topology/TopologyDTO.proto";
import "tag/Tag.proto";
import "CommonDTO.proto";

enum LogicalOperator {
    AND = 1;
    OR = 2;
    XOR = 3;
}

// A query contains a list of search parameters (which outline the subqueries to perform), and an
// operator that's used to combine the subquery results.
message SearchQuery {

    // The set of search criteria in this query.
    //
    // WARNING - this field is persisted with group definitions. Do not change the type or index.
    repeated SearchParameters search_parameters = 1;

    // Specifies how to combine the search parameters.
    //
    // WARNING - this field is persisted with group definitions. Do not change the type or index.
    optional LogicalOperator logical_operator = 2 [default = AND];
}

// A search definition that needs to be performed on a topology, represented as a DAG.
message SearchParameters {

    // The filter on an entity property that will be used as a starting point.
    // Needed to avoid starting with a traversal filter, that will end up applying the traversal
    // to every entity in the topology, causing performance issues.
    optional PropertyFilter starting_filter = 2;

    // After the starting property filter, this is the ordered sequence of filters that needs to
    // be applied to the topology. Every filter will be applied to the result of the previous one.
    repeated SearchFilter search_filter = 3;

    // Source filter from which parameters were created
    optional FilterSpecs source_filter_specs = 4;

    // Specs of filter from which parameters were created
    message FilterSpecs {
        required string expression_type = 1;
        required string expression_value = 2;
        required string filter_type = 3;
        optional bool is_case_sensitive = 4 [default = false];
    }

}

// A filter that needs to be applied to the topology, in order to return a subset of the entities.
message SearchFilter {

    // There are 3 types of filters.
    // - traversal filter: used to traverse graph relationship
    // - property filter: used to specify specific criteria on properties of the element
    // - group filter: this is a special-case filter that will target members of
    // a group/set of groups or owners of groups
    // - multi traversal filter: used to do handle more than one graph relationships
    oneof filterType {
        TraversalFilter traversal_filter = 1;
        PropertyFilter property_filter = 2;
        GroupFilter group_filter = 3;
        MultiTraversalFilter multi_traversal_filter = 4;
    }
}

// Filter which combines results of the more than one traversal filter
message MultiTraversalFilter {
    // shows the way how results of the traversal filters have to be combined
    optional LogicalOperator operator = 1 [default = OR];
    // Contains filters that are traversing over the graph relationships
    repeated TraversalFilter traversal_filter = 2;
}

// Filter used to traverse graph relationship.
message TraversalFilter {

    // Direction used for the traversal.
    optional TraversalDirection traversal_direction = 1;

    // Condition used to stop the graph traversal.
    optional StoppingCondition stopping_condition = 2;

    // Graph traversal stopping condition.
    message StoppingCondition {

        // There are 2 types of stopping condition:
        // - stop when you have reached the number of hops requested
        //      example: if you want to get all the providers of an entity, you can create a
        //      "consumes" traversal with 1 as a number of hop. This is because you want to
        //      traverse the relationship only 1 time. If you want the providers of the providers
        //      you can have 2 hops instead.
        // - Do not care about how many hops you are traversing, but stop only when a property
        //      condition is met, or you reach a leaf.
        oneof stoppingConditionType {
            int32 number_hops = 1;
            PropertyFilter stopping_property_filter = 2;
        }

        // Condition used to check the connected vertices after stop in the graph.
        optional VerticesCondition vertices_condition = 5;

        // Condition used to check the connected vertices after stop in the graph.
        // For example, if we want to get all PMs which host more than 5 VMs, it will traverse
        // from all PMs, stop at VMs and filter each PM based on the number of hosted VMs
        message VerticesCondition {
            // Filter by the number of connected vertices after stop in the graph
            optional PropertyFilter.NumericFilter num_connected_vertices = 1;

            // Filter by entity type of the connected vertices, for example: VM entity type
            optional int32 entity_type = 2;
        }
    }

    // Direction of the traversal along the DAG.
    enum TraversalDirection {
        // Right now we are supporting only one single directed edge/relationship.
        // Host           ---- Produces ---> VirtualMachine
        // VirtualMachine <--- Consumes ---- Host
        // where Consumes is the opposite direction (on the same edge) of Produces and
        // indicates that the Consumer is buying a commodity from the Producer.
        CONSUMES = 0;
        PRODUCES = 1;
        // BusinessAccount ---- ConnectedTo   ---> VirtualMachine
        // VirtualMachine  <--- ConnectedFrom ---- BusinessAccount
        // where ConnectedFrom is the opposite direction (on the same edge) of ConnectedTo
        // This case includes all connections, i.e, normal, aggregation, and ownership.
        // Owners and aggregators are "connected to" owned and aggregated entities, resp.
        // Owned and aggregated entities are "connected from" owners and aggregators, resp.
        CONNECTED_TO = 2;
        CONNECTED_FROM = 3;
        // BusinessAccount ---- Owns   ---> VirtualMachine
        // VirtualMachine  <--- Owned by ---- BusinessAccount
        // Zone ---- Aggregates   ---> VirtualMachine
        // VirtualMachine  <--- Aggregated by ---- Zone
        // This filter accepts aggregations and ownerships, but not other connections.
        AGGREGATES = 4;
        AGGREGATED_BY = 5;
        // BusinessAccount ---- Owns   ---> VirtualMachine
        // VirtualMachine  <--- Owned by ---- BusinessAccount
        // This filter accepts only ownerships.
        OWNS = 6;
        OWNED_BY = 7;
        // WorkloadController ---- Controls   ---> VirtualMachine/Container/Pod
        // VirtualMachine/Container/Pod  <--- Controlled by ---- WorkloadController
        // This filter accepts only controls connection.
        CONTROLS = 8;
        CONTROLLED_BY = 9;
    }
}

// Filter used to specify specific criteria on a property of the element.
message PropertyFilter {

    // Name of the property that we want to compare
    optional string property_name = 1;

    // Type of the property that we want to compare
    oneof propertyType {
        StringFilter string_filter = 2;
        NumericFilter numeric_filter = 3;
        MapFilter map_filter = 4;
        ListFilter list_filter = 5;
        ObjectFilter object_filter = 6;
    }

    // Property filter for strings. It can be used in two ways:
    // (1) it maps string-valued properties against a regex
    // (2) it checks if a string-valued property is contained in a given list of string
    // Which of the above is used depends on what data is given. A valid message
    // should contain either a regex or a list of options, but not both.
    // The reason this is not implemented with a oneof protobuf message is for
    // backward compatibility
    message StringFilter {
        // Regular expression to be matched used against the property'sGroupMapper value
        // (use (1) of the filter).
        // If set, takes precedence over "options."
        optional string string_property_regex = 1;

        // List of strings: the string-valued property must be contained here
        // (use (2) of the filter)
        // Ignored if string_property_regex is set.
        // If empty, none match.
        repeated string options = 4;

        // If false, then negate the result
        optional bool positive_match = 2 [default = true];

        // If true, the case of the letters should match
        optional bool case_sensitive = 3 [default = false];
    }

    message NumericFilter {
        // Operator used to compare the numeric property value and the requested value.
        optional ComparisonOperator comparison_operator = 1;

        // Requested value for the numeric property filtering.
        optional int64 value = 2;
    }

    // This is a filter for properties whose value is a map from strings to strings
    // (for example, tags).
    // Three kinds of matching are supported:
    // 1. given a key and a set of values an entity matches if and only if it has
    //    an entry with that key and one of the values. The string matching of both
    //    key and value is exact (no regex matching)
    // 2. given a regex, an entity matches if it has an entry with key k and value v
    //    such that k=v match that regex
    // 3. given a key and a regex, a key matches if it has an entry with key k
    //    and value that matches that regex
    // A map that negates the result of the match is also supported
    message MapFilter {
        // If non-empty, string checked against the entry key (cases 1 and 3)
        optional string key = 1;

        // If non-empty, strings checked against the entry value(s) (case 2)
        repeated string values = 2;

        // True iff this is a multimap (multiple values per key are possible)
        // For tags searching, this flag should be set to true
        optional bool is_multimap = 3 [default = true];

        // If non-empty and key is not empty, then match entry value(s)
        // against this regex (case 3)
        // If non-empty and key is empty, then for every entry (key;value)
        // match string key=value against this regex (case 2)
        // If empty, then it is ignored
        optional string regex = 4;

        // If false, then negate the result
        optional bool positive_match = 6 [default = true];
    }

    // This is a filter for property whose value is a list of elements. The elements can be one of
    // 3 types: string, number, object. It checks whether the list contains a specific element.
    // for example: if we want to find the entity which sells a "VMem" commodity whose capacity is
    // larger than 1024, then we can use this filter, define the propertyName as
    // "commoditySoldList", and set object_filter which contains two PropertyFilters:
    // one is StringFilter, whose property_name is "type" and value is "VMem"; the other one is
    // NumericFilter, whose property_name is "capacity", operator is ">" and value is "1024"
    message ListFilter {
        // The element of the list is one of three types: object, string or number.
        oneof list_element_type {
            // current list is a list of objects, check whether any object matches
            ObjectFilter object_filter = 1;
            // current list is a list of strings, check whether any string matches
            StringFilter string_filter = 2;
            // current list is a list of numbers, check whether any number matches
            NumericFilter numeric_filter = 3;
        }
    }

    // The filter used to check if an object matches. An object consists of multiple properties, so
    // this filter is made up of multiple property filters, each filter is for one property of the
    // object.
    // for example: filter entities whose displayName contains "abc" and state is "ACTIVE"
    message ObjectFilter {
        // list of property filters to check if the object matches, currently these filters
        // are AND together, we can extend it to OR if needed.
        repeated PropertyFilter filters = 1;
    }
}

// Used to check if entities are part of a group or group is owned by appropriate owner.
//
// This filter gets special handling in SearchService, where the group information is resolved in a
// separate step from the other filtering mechanisms and then is translated to a String Filter
// for checking if an entity id is part of the group or if this group is owned by certain owner.
//
// This is due to the group membership information being stored in a separate arango database from
// the topology information and disallowing "joining" the topology documents with group info
// documents. Perhaps, in the future, we can unify these in a way that allows the group filter to
// be handled in a way that is consistent with the other search filters, e.g. direct graph
// traversals in a single database/context.
//
message GroupFilter {
    // Specifies the group(s) to filter group membership or owners of groups based on.
    optional PropertyFilter group_specifier = 1;
    // Type of a group requested. If not specified, query will not distinguish between group types.
    optional common_dto.GroupDTO.GroupType group_type = 2;

    // Defines relationship between entity and group.
    optional EntityToGroupType entityToGroupType = 3 [default = MEMBER_OF];

    // Used in GroupFilter for searching entities depending on their relationship to the group.
    enum EntityToGroupType {
        // Check that entities are members of groups.
        MEMBER_OF = 0;

        // Check that entities are owners of groups.
        OWNER_OF = 1;
    }
}

enum ComparisonOperator {
    // Equal to
    EQ = 0;

    // Not equal to
    NE = 1;

    // Greater than
    GT = 2;

    // Greater or equal than
    GTE = 3;

    // Less than
    LT = 4;

    // Less or equal than
    LTE = 5;
}

// The request to search entity oids based on a list of search parameters. Note that, search entity
// oids not need to perform pagination, because all the request needs to fetch all matched entity
//oids, and the search entity oid query should be finish quickly even in large topology environment.
message SearchEntityOidsRequest {
    optional SearchQuery search = 1;

    // If the entity oids list is not empty, it means the search parameters will be only applied to those
    // entity oids, the response will be subset of those entity oids. If the entity oids list is empty,
    // it means the search parameters will be applied to global entities.
    repeated int64 entity_oid = 2;
}

message SearchEntityOidsResponse {
    // The OIDs of entities from the search result
    repeated int64 entities = 1;
}

message SearchEntitiesRequest {
    optional SearchQuery search = 1;

    // If the entity oids list is not empty, it means the search parameters will be only applied to those
    // entity oids, the response will be subset of those entity oids. If the entity oids list is empty,
    // it means the search parameters will be applied to global entities.
    repeated int64 entity_oid = 2;

    // Allows caller to control return type.
    optional .topology.PartialEntity.Type return_type = 5;

    // If not set, use the default instance of PaginationParameters. The backend
    // will enforce a default ordering and limit, and retrieve the first page.
    optional common.PaginationParameters pagination_params = 3;
}

message SearchEntitiesResponse {
    // A list of matched entities.
    repeated .topology.PartialEntity entities = 1;

    optional common.PaginationResponse pagination_response = 2;
}

message CountEntitiesRequest {
    optional SearchQuery search = 1;
}

// response to CountEntitiesRequest messages
message EntityCountResponse {
    optional int32 entityCount = 1;
}

// request to the repository for existing tags
message SearchTagsRequest {
    // restrict request to tags of the specified entities
    // if this list is empty, there is no restriction on entities
    repeated int64 entities = 1;

    // restrict request to entities of this type
    optional int32 entity_type = 2;

    // environment type of entities to restrict search to
    optional common.EnvironmentType environmentType = 3;
    // if pagination_params is not set, then the backend
    // will return all results.
    optional common.PaginationParameters pagination_params = 4;
}

// response to a SearchTagsRequest
message SearchTagsResponse {
    // A list of matched tags.
    optional .tag.Tags tags = 1;

    optional common.PaginationResponse pagination_response = 2;
}

// Request to the repository to get all tag values for defined tagKey.
// Returns a map where: KEY: tag values; VALUE: OIDs of tagged entities.
message SearchTagValuesRequest {
    optional string tag_key = 1;
    optional int32 entity_type = 2;
}

message SearchTagValuesResponse {
    map<string, TaggedEntities> entities_by_tag_value = 1;
}

message TaggedEntities {
    repeated int64 oid = 1;
}

// A service responsible for search operations.
service SearchService {
    // Search for entities based on the search parameters and return entity OID
    rpc SearchEntityOids(SearchEntityOidsRequest) returns (SearchEntityOidsResponse);

    // Search for entities based on the search parameters and return entity objects
    // This method is the non-stream alternative to do pagination.
    rpc SearchEntities(SearchEntitiesRequest) returns (SearchEntitiesResponse);

    // This is meant for internal use between components - streams instead of pagination.
    rpc SearchEntitiesStream(SearchEntitiesRequest) returns (stream .topology.PartialEntityBatch);

    rpc CountEntities(CountEntitiesRequest) returns (EntityCountResponse);

    rpc SearchTags(SearchTagsRequest) returns (SearchTagsResponse);

    rpc SearchTagValues(SearchTagValuesRequest) returns (SearchTagValuesResponse);

    rpc graphSearch(GraphRequest) returns (GraphResponse);
}

message Hop {
    required TraversalFilter.TraversalDirection traversal_direction = 1;
    required int32 target_entity_type = 2;
}

message RequestNode {
    repeated Hop hops = 1;
    optional .topology.PartialEntity.Type return_type = 2;
    map<string, RequestNode> nodes = 3;
}

message GraphRequest {
    repeated int64 oids = 1;
    optional .topology.PartialEntity.Type return_type = 2;
    map<string, RequestNode> nodes = 3;
}

message OidList {
    repeated int64 oids = 1;
}

message ResponseNode {
    map<int64, OidList> oid_map = 1;
    map<int64, .topology.PartialEntity> entities = 2;
    map<string, ResponseNode> nodes = 3;
}

message GraphResponse {
    repeated .topology.PartialEntity entities = 1;
    map<string, ResponseNode> nodes = 2;
}
