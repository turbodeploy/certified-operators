syntax = "proto2";

package logging;

option java_package = "com.vmturbo.common.protobuf.logging";

// Configuration for memory metric collection during a memory walk. We define a memory
// walk as a traversal of the graph of object references reachable from the root set of
// objects in the memory walk request.
message MemoryMetricsConfiguration {
    // Memory walks are generated by traversing the references from the root-set in a
    // breadth-first fashion by using reflection. This is an expensive operation
    // when there are many objects to traverse, so it may not be practical to traverse
    // the entire reachable graph from the root set. This parameter limits the depth
    // of the walk. If not provided or set to a negative number, the walk will attempt
    // to traverse the entire graph.
    //
    // During the memory walk, we traverse TO the walk_depth, but not deeper.
    // ie specifying a depth of zero will result in only the roots being walked
    // but none of their descendants.
    optional int32 walk_depth = 1 [default = -1];

    // Expresses what memory details to capture during the memory walk of the root set.
    oneof walk_type {
        SizeAndCount size_and_count = 11;
        ClassHistogram class_histogram = 12;
        MemoryGraph memory_graph = 13;
    }

    // Compute and log the total size and number of objects reached
    // during the memory walk of the given root set. The size computed is the "deep" size
    // of the root set.
    //
    // Performance: This is the lightest-weight operation with the least overhead
    //              (although computing the class histogram is not much more expensive).
    message SizeAndCount {}

    // Compute and log the class histogram of objects. This results in a histogram similar to
    // the OpenJDK class histogram dump seen in Hotspot JVM thread dumps. Sizes for the classes
    // are computed by summing the "shallow" size of each object of the given class.
    //
    // Performance: This is a slightly more expensive operation than computing just the
    //              size and count but is still much lighter-weight than generating the MemoryGraph.
    message ClassHistogram {}

    // Compute and log a tabular breakdown of the reference graph and the sizes of objects
    // and their ancestor references. This generates a table summarizing the graph by the depth
    // of references reachable from the root set.
    //
    // Performance: This operation has the highest overhead of any of the walk types.
    //
    // IMPORTANT: A note about computed sizes:
    // When performing heap analysis, we often use the terms "shallow size", "retained size",
    // and "deep size" of an object. See https://dzone.com/articles/shallow-retained-and-deep-size
    // for an explanation of all of these terms.
    //
    // The sizes generated by memory walks using the MemoryMetricsService are a mix of retained
    // and deep sizes which is important to keep in mind when interpreting the numbers. When
    // multiple parent objects refer to the same child, we assign the child's size to only
    // one of its parents when computing sizes. Consider the following object graph
    //
    // Foo --> Baz--> Quux
    //                /
    // Bar  ---------
    //
    // Here, if we perform a memory walk with a root set of [Foo, Bar], we see we can reach
    // Quux through both Foo and Bar. As a result, we will report the following sizes in the table
    // generated for the MemoryGraph:
    //
    // TOTAL                             CHILD_COUNT  TYPE                    PATH
    // shalllow(Foo) + shallow(Baz)      2            Foo                     <r1>
    // shallow(Bar) + shallow(Quux)      2            Bar                     <r2>
    // TOTAL                             CHILD_COUNT  TYPE                    PATH
    // shallow(Baz)                      1            Baz                     <r1>.baz
    // shallow(Quux)                     1            Quux                    <r2>.quux
    //
    // This amounts to reporting the deep size for Bar and the retained size for Foo. Note, however,
    // if we remove Bar from the root set, we will generate the following table for the MemoryGraph:
    //
    // TOTAL                                             CHILD_COUNT  TYPE                    PATH
    // shalllow(Foo) + shallow(Baz) + shallow(Quux)      3            Foo
    // TOTAL                                             CHILD_COUNT  TYPE                    PATH
    // shallow(Baz) + shallow(Quux)                      2            Baz                     .baz
    // TOTAL                                             CHILD_COUNT  TYPE                    PATH
    // shallow(Quux)                                     1            Quux                    .baz.quux
    //
    // Thus, if you want the true deep size of all objects in a root set, request repeated memory
    // walks for each member of the root set rather than one request with all members.
    // When a child object is referenced through multiple paths of the same length from the root
    // set, which descendant objects are credited with the size of the child object is not guaranteed,
    // but we will pick only a single path and not mix parents from different paths.
    //
    // We compute sizes in this somewhat convoluted manner because:
    // 1. It simplifies handling of cycles in the memory graph and is much easier to compute
    //    than the retained size of each reachable object from the root set (impossible without
    //    knowing if there are objects outside the root set that also refer to object inside
    //    the root set) and much less expensive to compute than the true deep size of all
    //    objects reachable from the root set.
    // 2. The computed size of the root set will actually be the size of all objects reachable from the root
    //    set. This is often the number you actually care about (although not always).
    message MemoryGraph {
        // How deep into the object hierarchy to log. For legibility and performance, it's often
        // not advisable to log too deep into the graph unless you really need deep details.
        // We log the computed size of obects at or above the log_depth (ie if log_depth is 1,
        // we log all objects at depths 0 and 1).
        optional uint32 log_depth = 1 [default = 4];

        // If provided, only log entries with a calculated size meeting or exceeding this threshold
        // size in bytes.
        optional uint64 minimum_log_size_bytes = 2 [default = 2048]; // Default 2kB
    }
}

// Request dumping heap to file.
message DumpHeapRequest {
    // Filename where the heap dump should be written. Note that this will not be
    // compressed. You can easily run out of memory in the "/tmp" directory in
    // production but this may be the only writeable volume in the container.
    //
    // In OpenJDK, this will generate a heap dump in .hprof format
    // In OpenJ9, this will generate a file in .phd format
    //
    // If no filename is provided we will use a default filename saved in the
    // "/tmp" directory.
    optional string filename = 1;
}

// Response for dumping heap to file.
message DumpHeapResponse {
    // Message describing the outcome of the request.
    optional string response_message = 1;
}

// Request a memory walk.
message WalkRootObjectsRequest {
    // The names of the root set objects to walk. For the list of object names
    // eligible for walking, use the ListWalkableRoots RPC.
    // If multple root objects share the same name, all of them will be walked.
    repeated string root_set_names = 1;

    // How many lines of text to return in the response to the request. The
    // class histogram or memory graph may sometimes be tens of thousands of
    // lines long. Often you are only interested in the top lines of the
    // response. The full response will be included in the logs, this only
    // limits the lines returned in the RPC.
    optional uint32 response_line_count = 2 [default = 100];

    // Many objects in memory have references deep in their object graph to some form of
    // omniscient mega-object (ie a Spring Context) that then has references to many many
    // other objects with dubious relevance to the root object whose memory usage you are
    // attempting to measure.
    //
    // In order to generate a more meaningful and relevant estimate of the memory used
    // by the object you care about, when walking a given root, it is often helpful
    // to skip walking references to the other component root objects. Otherwise you
    // may wind up with an estimate of the entire spring context when you only intended
    // to generate memory metrics for a small portion of particular interest.
    //
    // To get a full measurement of every single object reachable from another, disable
    // this flag, but unless you are directly trying to measure the total size of all
    // spring-managed objects (which may be most easily done via the
    // WalkAllRootObjects rpc), it usually makes sense to use the component's
    // default exclusions.
    optional bool exclude_other_roots = 3 [default = true];

    // The depth at which to start excluding other root objects reachable from
    // the given root set for this walk.  We principally want to exclude very
    // deep references to large objects reachable through things like the Spring
    // Context. If there is a fairly direct reference to a spring-managed object,
    // we will probably want to include that in the measurement.
    //
    // This specifies the maximum depth before we start excluding objects
    // in the exclusion set.
    optional uint32 exclusion_depth = 4 [default = 2];

    // Configuration for the walk.
    optional MemoryMetricsConfiguration walk_configuration = 10;
}

// Request a memory walk of all
message WalkAllRootObjectsRequest {
    // How many lines of text to return in the response to the request. The
    // class histogram or memory graph may sometimes be tens of thousands of
    // lines long. Often you are only interested in the top lines of the
    // response. The full response will be included in the logs, this only
    // limits the lines returned in the RPC.
    optional uint32 response_line_count = 1 [default = 100];

    // Configuration for the walk.
    optional MemoryMetricsConfiguration walk_configuration = 10;
}

// Response to a memory walk request.
message WalkRootObjectResponse {
    // The names of the objects walked in the root set.
    // May be empty in response to a WalkAllRootObjects request.
    repeated string walked_root_names = 1;

    // The names of the objects requested for walking but could not be included
    // (ie if the request asked to walk object "foo" but no object "foo" was found)
    repeated string not_walked_root_names = 2;

    // The top lines generated by the memory walk. Note that the number of lines
    // included here will not exceed the response_line_count provided in the request
    // even if the walk generated more than that number of lines.
    repeated string walk_results = 3;

    // The total number of lines generated for the response.
    // Note that the response_lines parameter may contain fewer lines if
    // response_line_count limited the number returned.
    optional uint32 total_response_lines = 4;

    // The duration taken to fulfill the request.
    optional string request_duration = 5;
}

// Request for listing walkable root objects
message ListWalkableRootsRequest {

}

// Response specifying the list of walkable roots.
message ListWalkableRootsResponse {
    // The names and classes of walkable root objects
    repeated RootObject walkable_roots = 1;

    // A root object reference.
    message RootObject {
        // The name of the object
        optional string name = 1;

        // The name of the class of the object
        optional string class_name = 2;

        // Name of the component that this root object belongs to. Useful
        // in systems where multiple components may run together (ie Voltron).
        optional string owner_component = 3;
    }
}

message FindMemoryPathRequest {
    // We find the memory path to class instances by performing a memory walk.
    //
    // Memory walks are generated by traversing the references from the root-set in a
    // breadth-first fashion by using reflection. This is an expensive operation
    // when there are many objects to traverse, so it may not be practical to traverse
    // the entire reachable graph from the root set. This parameter limits the depth
    // of the walk. If not provided or set to a negative number, the walk will attempt
    // to traverse the entire graph.
    //
    // During the memory walk, we traverse TO the walk_depth, but not deeper.
    // ie specifying a depth of zero will result in only the roots being walked
    // but none of their descendants.
    optional int32 walk_depth = 1 [default = -1];

    // The names of the root set objects to walk. For the list of object names
    // eligible for walking, use the ListWalkableRoots RPC.
    // If multple root objects share the same name, all of them will be walked.
    //
    // If this list is empty, all root set objects will be walked.
    repeated string root_set_names = 2;

    // The names of the classes whose instances we will find the memory path for.
    // Note that this must be the FULL classname and NOT the shortname. ie
    // "com.vmturbo.common.protobuf.memory.AllocatingMemoryWalkerTest$TestSubclass"
    // and NOT "TestSubclass".
    //
    // Providing an interface or superclass of an object will not result in a match
    // for that object.
    repeated string class_names = 3;

    // The maximum number of instances of any of the classes to find.
    // If we reach this maximum, we can stop the memory walk early.
    //
    // Leaving this value empty or providing a negative value will
    // find all instances of the classes.
    optional int32 max_instances = 4 [default = -1];

    // If true, the returned FoundPath messages will contain the result
    // of calling toString() on the instances of the objects.
    optional bool include_string_values = 5 [default = false];

    // The minimum depth to reach before accepting found instances of the search_classes.
    //
    // Usually the default of 0 is fine if any instances will do, but if there are many
    // instances at low depth and you only care to find the ones at deeper depth,
    // pass in a min_instance_depth to exclude the shallower instances from the results.
    optional int32 min_instance_depth = 6 [default = 0];
}

// A path to a found object.
message FoundPath {
    // The in-memory-path to the object from the root set.
    // If there are multiple paths to the object from the root set, we return
    // a shortest path.
    //
    // ie something like "myObject.foo.myInts[3].bar"
    optional string path = 1;

    // The name of the class of the found object.
    optional string class_name = 2;

    // The result of calling the "toString()" on the found object.
    // This field will be absent unless the request specified
    // include_string_values=true
    optional string to_string_value = 3;
}

// Response to a request to find memory paths for a class or set of classes.
message FindMemoryPathResponse {
    // The found paths to instances of the requested classes.
    repeated FoundPath paths = 1;

    // The classes in the request that were successfully resolve to real
    // Java classes.
    repeated string resolved_classes = 2;

    // The classes in the request that could not be resolved to real
    // java classes.
    repeated string unresolved_classes = 3;

    // The duration taken to fulfill the request.
    optional string request_duration = 4;
}

// Service to collect metrics concerning memory usage
service MemoryMetricsService {
    // Perform a memory walk from a root set of objects, collecting information about
    // the memory usage of objects visited along the way.
    //
    // Beware, collecting these memory metrics is an expensive operation,
    // requiring additional compute time and memory to do so.
    //
    // Please note that all computed in-memory sizes are estimates and not
    // guaranteed to be 100% accurate but are usually pretty good.
    rpc WalkRootObjects(WalkRootObjectsRequest) returns (WalkRootObjectResponse);

    // Perform a memory walk from a root set of objects, collecting information about
    // the memory usage of objects visited along the way. The root set walked will
    // be the same as the complete set of objects listed through a call to
    // ListWalkableRoots.
    //
    // Beware, collecting these memory metrics is an expensive operation,
    // requiring additional compute time and memory to do so.
    //
    // Please note that all computed in-memory sizes are estimates and not
    // guaranteed to be 100% accurate but are usually pretty good.
    rpc WalkAllRootObjects(WalkAllRootObjectsRequest) returns (WalkRootObjectResponse);

    // List the names of all walkable root objects that can be given to a
    // WalkRootObjects RPC call.
    rpc ListWalkableRoots(ListWalkableRootsRequest) returns (ListWalkableRootsResponse);

    // Find the in-memory path to instances of a class or set of classes.
    // This rpc is most useful when you suspect a memory leak and want to
    // find out why certain instances of a particular class are being
    // retained when you feel they should be garbage collected.
    //
    // When there are multiple paths to a given object in-memory from the root
    // set, we will always find a shortest path.
    rpc FindMemoryPath(FindMemoryPathRequest) returns (FindMemoryPathResponse);

    // Dump the heap to a file.
    rpc DumpHeap(DumpHeapRequest) returns (DumpHeapResponse);
}