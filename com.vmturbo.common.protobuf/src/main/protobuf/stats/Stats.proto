syntax = "proto2";
package stats;

option java_package = "com.vmturbo.common.protobuf.stats";

import "CommonDTO.proto";
import "common/Pagination.proto";
import "group/GroupDTO.proto";
import "setting/Setting.proto";
import "topology/TopologyDTO.proto";
import "common/EnvironmentTypeEnum.proto";

// Restricts all commodities returned by a request.
message GlobalFilter {
    // If non-empty, return only statistics related to the specified entity types.
    repeated string related_entity_type = 1;

    // If present, return only statistics related to this specific environment type.
    // If not present or UNKNOWN, return statistics related to all environment types.
    optional .common.EnvironmentType environment_type = 2;
}

message GetAveragedEntityStatsRequest {
    // The entities to gather stats for. These could be the IDs of individual entities, a plan,
    // or the global market.
    repeated int64 entities = 1;

    // The filter to apply to the stats. If not set, retrieve all stats.
    optional StatsFilter filter = 2;

    // The global filter to apply to all commodities in the request.
    // This is only relevant when the input is the entire market.
    optional GlobalFilter global_filter = 3;
}

// The scope for an entity stats query.
message EntityStatsScope {
    oneof scope {
        // Scope the entity stats request to a specific list of entities.
        EntityList entity_list = 1;

        // Scope the entity stats request to entities of a specific type.
        int32 entity_type = 2;

        // Scope the entity stats request to a list of entity groups
        EntityGroupList entity_group_list = 3;
    }

    message EntityList {
        // list of entities oids. if empty, return no results.
        repeated int64 entities = 1;
    }

    message EntityGroupList {
        // list of entity groups, each containing seed entity and list of derived entities
        repeated EntityGroup groups = 1;
    }

    // A group of entities, which contains seed entity and derived entities
    // for example: the seed_entity can be a datacenter, and the derived entities can be a list of
    // PMs in that datacenter
    message EntityGroup {
        // oid of the seed entity to get stats for
        optional int64 seed_entity = 1;

        // member entities derived from seed entity, if set it will aggregate stats on members;
        // if empty, it will get stat for seed entity.
        repeated int64 entities = 2;
    }
}

message GetEntityStatsRequest {
    // The entities to gather stats for. If not set, return no results.
    optional EntityStatsScope scope = 1;

    // The filter to apply to the stats. If not set, retrieve all stats.
    optional StatsFilter filter = 2;

    // The pagination parameters outlying the sort order, and previous cursor (if any).
    // If not set, use the default instance of PaginationParameters. The backend
    // will enforce a default ordering and limit, and retrieve the first page.
    optional common.PaginationParameters pagination_params = 10;
}

// Response for per-entity stats from the database.
message GetEntityStatsResponse {
    // Stats for the retrieved entities.
    // The stats are arranged in the order requested in the pagination parameters in
    // the request.
    repeated EntityStats entity_stats = 1;

    // The response containing the cursor to retrieve the next page of results.
    optional common.PaginationResponse pagination_response = 10;
}

message ClusterStatsRequest {
    // The ID of the cluster to retrieve stats from.
    optional int64 cluster_id = 1;

    // The filter to apply to the stats. If not set, retrieve all stats.
    optional StatsFilter stats = 2;
}

// The stats filter represents the restrictions to apply to stats before returning them.
// All the individual filters are AND-ed together.
message StatsFilter {
    // commodities to fetch; if omitted, requests all commoditites
    repeated CommodityRequest commodity_requests = 1;

    // a list of the attributes of the given commodities to extract, e.g. "used" or "peak"; if ommited, requests all
    repeated string commodity_attributes = 2;

    // date range for the request; if omitted, implies "now"; dates are epoch longs
    optional int64 start_date = 3;

    optional int64 end_date = 4;

    // Specify the commodity to fetch along with filters and grouping
    message CommodityRequest {

        // the name of the commodity to fetch
        optional string commodity_name = 1;

        // A list of property/value sub-filters to select which data rows should be returned; multiple
        // filters are 'and'-ed together. The result must match all the given property_value_filters.
        repeated PropertyValueFilter property_value_filter = 2;

        // A list of property names to aggregate stats over, as in an SQL 'group by' clause.
        repeated string group_by = 3;

        // If present, limit the ServiceEntities processed to the given type.
        optional string related_entity_type = 4;
    }

    // a filter to implment the equivalent of 'where <property> = <value>'
    message PropertyValueFilter {

        // the property to filter on
        optional string property = 1;

        // the value of this property to be matched on
        optional string value = 2;
    }
}

// Request for stats from the latest projected topology.
message ProjectedStatsRequest {
    // The entities to gather stats for. If empty, get them for the whole topology!
    repeated int64 entities = 1;

    // The commodities to retrieve.
    repeated string commodity_name = 2;
}

// Request for per-entity stats from the latest projected topology.
message ProjectedEntityStatsRequest {
    // The entities to gather stats for. If empty, get them for the whole topology!
    optional EntityStatsScope scope = 1;

    // The commodities to retrieve.
    repeated string commodity_name = 2;

    // The pagination parameters outlying the sort order, and previous cursor (if any).
    // If not set, use the default instance of PaginationParameters. The backend
    // will enforce a default ordering and limit, and retrieve the first page.
    optional common.PaginationParameters pagination_params = 10;
}

// Response for per-entity stats from the latest projected topology.
message ProjectedEntityStatsResponse {
    // Stats for the retrieved entities.
    // The stats are arranged in the order requested in the pagination parameters in
    // the request.
    repeated EntityStats entity_stats = 1;

    // The response containing the cursor to retrieve the next page of results.
    optional common.PaginationResponse pagination_response = 10;
}

// the top-level response for the snapshot - taken at a given time, for a time range, containing a set of records
// that satisfy the StatsRequest
message StatSnapshot {

    // the actual snapshot_date for this response
    optional uint64 snapshot_date = 1;

    // the individual stat_records collected; if the input was a group, these values will be averaged over the group
    repeated StatRecord stat_records = 4;

    // an individual stats value - e.g. commodies, etc. - from the xx_stats_zz tables.
    message StatRecord {

        // name of the particular stat, e.g. priceIndex, actions, Produces, numVMsand etc.
        optional string name = 1;

        // capacity for the commodities PROVIDED by this entity; null otherwise
        optional StatValue capacity = 2;

        // amount reserved - ?for reservation/deployment functionality?
        optional float reserved = 3;

        // a key for the type of the commodity, e.g.   - see com.vmturbo.platform.common.dto.CommonDTO.proto,
        // the enum {@link CommodityType}, for the known commodity names, e.g.
        //   STORAGE, MEM_ALLOCATION, CPU_ALLOCATION, NUMBER_CONSUMERS, FLOW_ALLOCATION, Q1_VCPU, etc.
        optional string stat_key = 4;

        // for commodities CONSUMED by this entity, the OID of the provider
        optional string provider_uuid = 5;

        // for commodities CONSUMED by this entity, the display_name of the provider
        optional string provider_display_name = 6;

        // units suffix for this commodity
        optional string units = 7;

        // current value for this commodity - for most recent value ???
        optional float current_value = 8;

        // avg for these secondary stats - for rolled-up values
        optional StatValue values = 9;

        // used for these secondary stats - for rolled-up values
        optional StatValue used = 10;

        // max for these secondary stats - for rolled-up values
        optional StatValue peak = 11;

        // relation for the stat: (see RelationType in com.vmturbo.reports.db and
        // StatsMapper in com.vmturbo.api.component))
        // "Commodities", "CommoditiesBought", "CommoditiesFromAttributes"
        //  (e.g., priceIndex, numVCPUs, etc.), and "plan"
        optional string relation = 12;

        // the entity type for the commodity returned; e.g. to distinguish the "CPUAllocation"
        // commodity sold by a VirtualDataCenter from the same commodity name ("CPUAllocation")
        // sold by a PhysicalMachine
        optional string related_entity_type = 13;

        // statistics for a given value over time
        message StatValue {
            optional float max = 1;
            optional float min = 2;
            optional float avg = 3;
            optional float total = 4;

        }
    }
}

message EntityStats {
    optional uint64 oid = 1;
    repeated StatSnapshot statSnapshots = 2;
}

message ProjectedStatsResponse {
    // The response for projected stats contains at most one snapshot,
    // because there is only one projection.
    optional StatSnapshot snapshot = 1;
}

// Request sent to the Stats Service when it is time to compute roll-up stats for clusters.
message ClusterRollupRequest {
    // The list of clusters for which stats roll-up should be calculated.
    repeated .group.Group clustersToRollup = 1;
}

message ClusterRollupResponse {
    // nothing to return
}

message DeletePlanStatsRequest{
    // TODO - karthikt : Maybe should be a list to support bulk deletes
    optional int64 topology_context_id = 1;
}

message DeletePlanStatsResponse{
}

message CommodityHeadroom {
    // Number of VMs that can be accommodated in cluster considering its utilization for given commodity.
    optional int64 headroom = 1;

    // Number of VMs that may accommodate empty cluster for given commodity.
    optional int64 capacity = 2;

    // Number of days to cluster exhaustion for given commodity.
    optional int64 days_to_exhaustion = 3;
}

message SaveClusterHeadroomRequest {
    // The ID of the cluster
    optional int64 cluster_id = 1;

    // The headroom for the cluster at the time of this request.
    optional int64 headroom = 2;

    // The number of VMs in the cluster at the time of this request
    optional int64 numVMs = 3;

    // Headroom information for CPU.
    optional CommodityHeadroom cpu_headroom_info = 4;

    // Headroom information for Memory.
    optional CommodityHeadroom mem_headroom_info = 5;

    // Headroom information for Storage.
    optional CommodityHeadroom storage_headroom_info = 6;

    // The number of Hosts in the cluster at the time of this request.
    optional int64 numHosts = 7;

    // The number of Storages in the cluster at the time of this request.
    optional int64 numStorages = 8;

    // Growth in number of VMs for this cluster project monthly.
    optional int64 monthlyVMGrowth = 9;
}

message SaveClusterHeadroomResponse {
}

message GetStatsDataRetentionSettingsRequest {
}

message SetStatsDataRetentionSettingRequest {
    optional string retentionSettingName = 1;
    optional int32 retentionSettingValue = 2;
}

message SetStatsDataRetentionSettingResponse {
    optional setting.Setting newSetting = 1;
}

message GetAuditLogDataRetentionSettingRequest {
}

message GetAuditLogDataRetentionSettingResponse {
    optional setting.Setting auditLogRetentionSetting = 1;
}

message SetAuditLogDataRetentionSettingRequest {
    optional int32 retentionSettingValue = 1;
}

message SetAuditLogDataRetentionSettingResponse {
    optional setting.Setting newSetting = 1;
}

// The max value of a commodity over the whole stats
// retention period.
message CommodityMaxValue {

    // The type of commodity.
    optional topology.CommodityType commodityType = 1;

    // The max value for the commodity.
    optional double maxValue = 2;
}

// Return the max stats of the commodities sold by the entity.
message EntityCommoditiesMaxValues {
    // entity id
    optional uint64 oid = 1;

    // mapping from the commodity type to their max values
    // Would have been nice to use map here. But float/double
    // map values are not supported by protobuf.
    repeated CommodityMaxValue commodityMaxValues = 2;
}

message GetEntityCommoditiesMaxValuesRequest {
    // List of entity types whose commodity sold max values has to be fetched.
    repeated int32 entityTypes = 1;
}

// Request for system load info.
message SystemLoadInfoRequest {
    // The ID of the cluster
    optional int64 cluster_id = 1;
}

// Response for system load info.
message SystemLoadInfoResponse {
    // List of system load records.
    repeated SystemLoadRecord record = 1;
}

// Request for system load info.
message MultiSystemLoadInfoRequest {
    // A list of "cluster ids" - each cluster id is a request for a list of system load records.
    repeated int64 cluster_id = 1;
}

// Response for system load info.
message MultiSystemLoadInfoResponse {
    // The ID of the cluster this response pertains to.
    optional int64 cluster_id = 1;

    // List of system load records.
    repeated SystemLoadRecord record = 2;

    // If the system load records for this cluster id could not be retrieved, this is a description
    // of the error/reason. We use this instead of the regular error mechanism because
    // the failure for a single cluster id should not fail the entire call.
    optional string error = 10;
}

// Info contained in each record of the table system_load.
// This table contains information about the system load and the commodities
// participating in the calculation of the system load.
// The system load is a value indicating how much "load" exists in a system.
// The related records are calculated and stored to the DB in history component.
// This info are used in the nightly headroom plans to calculate the headroom.
// There are 4 types of records stored in DB:
// Type 1: Used values, peak values and capacities for commodities sold by VMs.
// Type 2: Used values and peak values for commodities bought by VMs.
// Type 3: Sum of capacities per slice for commodities sold by hosts and storages.
// Type 4: System load per slice.
message SystemLoadRecord {
    // Type 1, 2, 3, 4: The id of the cluster.
    optional int64 cluster_id = 1;

    // Type 1, 2, 3, 4: The time of the system load snapshot saved in the DB.
    optional int64 snapshotTime = 2;

    // Type 1, 2: The id of the VM.
    // Type 3, 4: null
    optional int64 uuid = 3;

    // Type 1, 3, 4: null
    // Type 2: The id of the provider of the commodity to the VM.
    optional int64 producer_uuid = 4;

    // Type 1, 2, 3: The name of the type of the commodity.
    // Type 4: "system_load"
    optional string property_type = 5;

    // Type 1, 2: "used"
    // Type 3: "total_capacity"
    // Type 4: The name of the type of the commodity.
    optional string property_subtype = 6;

    // Type 1: The capacity of the commodity.
    // Type 2: null
    // Type 3, 4: The sum of the capacities for the specific commodity type in cluster.
    optional double capacity = 7;

    // Type 1, 2: The used value of the commodity.
    // Type 3: null
    // Type 4: The sum of used values for the specific commodity type in cluster.
    optional double avg_value = 8;

    // Type 1, 2: The used value of the commodity.
    // Type 3: null
    // Type 4: The sum of used values for the specific commodity type in cluster.
    optional double min_value = 9;

    // Type 1, 2: The peak value of the commodity.
    // Type 3: null
    // Type 4: The sum of used values for the specific commodity type in cluster.
    optional double max_value = 10;

    // Type 1, 4: RelationType.COMMODITIES
    // Type 2, 3: RelationType.COMMODITIESBOUGHT
    optional int32 relation_type = 11;

    // Type 1, 2: The key of the commodity type.
    // Type 3, 4: null
    optional string commodity_key = 12;
}

message GetEntityIdToEntityTypeMappingRequest {
}

message GetEntityIdToEntityTypeMappingResponse {
    map<int64, common_dto.EntityDTO.EntityType> entityIdToEntityTypeMap = 1;
}

// Response for the percentile counts request.
// Percentile feature design could be found
// https://vmturbo.atlassian.net/wiki/spaces/PC/pages/592838759/Percentile+Service.
message PercentileCountsResponse {
    // Per-commodity record.
    repeated PercentileRecord percentile_records = 1;

    message PercentileRecord {
        // Container entity oid.
        required int64 oid = 1;

        // Commodity type.
        required topology.CommodityType commodity_type = 2;

        // Commodity provider, if bought, unset if sold.
        optional int64 provider_oid = 3;

        // Utilization counts per percent value - an array of 100 entries.
        // To calculate percentile value we are collecting amount of
        // utilization values in percents met for specified entity/commodity pair.
        repeated int32 utilization = 5;
    }
}

// the gRPC API entry points for the Stats service
service StatsHistoryService {

    //Get stats filtered by certain options and average over all entities listed in the request
    rpc GetAveragedEntityStats(GetAveragedEntityStatsRequest) returns (stream StatSnapshot);

    // Get stats separately for each entity listed in the request
    rpc GetEntityStats(GetEntityStatsRequest) returns (GetEntityStatsResponse);

    //Get stats filtered by certain options and average over all desired entities in the cluser.
    rpc GetClusterStats(ClusterStatsRequest) returns (stream StatSnapshot);

    // Get stats from the latest projected topology.
    // Will return a response with no data if the stats service
    // doesn't have any projected stats.
    rpc GetProjectedStats(ProjectedStatsRequest) returns (ProjectedStatsResponse);

     // Get per-entity stats from the latest projected topology.
    // Will return a response for each entity with no data if the stats service
    // doesn't have any projected stats.
    rpc GetProjectedEntityStats(ProjectedEntityStatsRequest) returns (ProjectedEntityStatsResponse);

    // Trigger a cluster-rollup computation for the given clusters.
    // Will return no significant data.
    rpc ComputeClusterRollup(ClusterRollupRequest) returns (ClusterRollupResponse);

    // Save values computed by the headroom plan in the cluster statistics table, where it can
    // be retrieved alongside other stats.
    //
    // This is an internal call, in the sense that user and external API request should never
    // trigger this method.
    rpc SaveClusterHeadroom(SaveClusterHeadroomRequest) returns (SaveClusterHeadroomResponse);

    // Delete plan stats
    rpc DeletePlanStats(DeletePlanStatsRequest) returns (DeletePlanStatsResponse);

    // Get Stats data Retention settings
    rpc GetStatsDataRetentionSettings(GetStatsDataRetentionSettingsRequest) returns (stream setting.Setting);

    // Set Stats Data Retention settings
    rpc SetStatsDataRetentionSetting(SetStatsDataRetentionSettingRequest) returns (SetStatsDataRetentionSettingResponse);

    // Get audit log data retention setting
    rpc GetAuditLogDataRetentionSetting(GetAuditLogDataRetentionSettingRequest) returns (GetAuditLogDataRetentionSettingResponse);

    // Set audit log data retention setting
    rpc SetAuditLogDataRetentionSetting(SetAuditLogDataRetentionSettingRequest) returns (SetAuditLogDataRetentionSettingResponse);

    // Get the historic max values(within the stats retention period) for all the non-access commodities
    // for all entities of the given entity type.
    rpc GetEntityCommoditiesMaxValues(GetEntityCommoditiesMaxValuesRequest) returns (stream EntityCommoditiesMaxValues);

    // Get the system load information for a specific slice (cluster)
    rpc GetSystemLoadInfo(SystemLoadInfoRequest) returns (SystemLoadInfoResponse);

    // Retrieve multiple lists of system load records in one call.
    // This is equivalent to calling GetSystemLoadInfo multiple times, but it provides an easier way
    // to do it from the client's perspective and allows for optimizations on the server.
    //
    // The response streams back each list of system load records once it's computed.
    rpc GetMultiSystemLoadInfo(MultiSystemLoadInfoRequest) returns (stream MultiSystemLoadInfoResponse);

    // Get the entityId and the corresponding entityType.
    // NOTE: This rpc call is used for a specific upgrade use case. DON'T USE THIS FOR OTHER SCENARIOS.
    rpc GetEntityIdToEntityTypeMapping(GetEntityIdToEntityTypeMappingRequest) returns (GetEntityIdToEntityTypeMappingResponse);

    // Get the historical utilization data for the passed entities scope.
    // Ignore the time range parameter and return 1 point per commodity.
    // Historical utilizations to be returned in current_value field of statistics records.
    rpc GetHistUtilization(GetEntityStatsRequest) returns (GetEntityStatsResponse);

    // Get the percentile scores for the passed entities scope and time range.
    rpc GetPercentileCounts(GetEntityStatsRequest) returns (PercentileCountsResponse);
}
