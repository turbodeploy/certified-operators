syntax = "proto2";
package stats;

option java_package = "com.vmturbo.common.protobuf.stats";

import "CommonDTO.proto";
import "common/Pagination.proto";
import "group/GroupDTO.proto";
import "setting/Setting.proto";
import "topology/TopologyDTO.proto";
import "common/EnvironmentTypeEnum.proto";

// Restricts all commodities returned by a request.
message GlobalFilter {
    // If non-empty, return only statistics related to the specified entity types.
    repeated string related_entity_type = 1;

    // If present, return only statistics related to this specific environment type.
    // If not present or UNKNOWN, return statistics related to all environment types.
    optional .common.EnvironmentType environment_type = 2;
}

message GetAveragedEntityStatsRequest {
    // The entities to gather stats for. These could be the IDs of individual entities, a plan,
    // or the global market.
    repeated int64 entities = 1;

    // The filter to apply to the stats. If not set, retrieve all stats.
    optional StatsFilter filter = 2;

    // The global filter to apply to all commodities in the request.
    // This is only relevant when the input is the entire market.
    optional GlobalFilter global_filter = 3;
}

// The scope for an entity stats query.
message EntityStatsScope {
    oneof scope {
        // Scope the entity stats request to a specific list of entities.
        EntityList entity_list = 1;

        // Scope the entity stats request to entities of a specific type.
        int32 entity_type = 2;

        // Scope the entity stats request to a list of entity groups
        EntityGroupList entity_group_list = 3;
    }

    message EntityList {
        // list of entities oids. if empty, return no results.
        repeated int64 entities = 1;
    }

    message EntityGroupList {
        // list of entity groups, each containing seed entity and list of derived entities
        repeated EntityGroup groups = 1;
    }

    // A group of entities, which contains seed entity and derived entities
    // for example: the seed_entity can be a datacenter, and the derived entities can be a list of
    // PMs in that datacenter
    message EntityGroup {
        // oid of the seed entity to get stats for
        optional int64 seed_entity = 1;

        // member entities derived from seed entity, if set it will aggregate stats on members;
        // if empty, it will get stat for seed entity.
        repeated int64 entities = 2;
    }
}

message GetEntityStatsRequest {
    // The entities to gather stats for. If not set, return no results.
    optional EntityStatsScope scope = 1;

    // The filter to apply to the stats. If not set, retrieve all stats.
    optional StatsFilter filter = 2;

    // The pagination parameters outlying the sort order, and previous cursor (if any).
    // If not set, use the default instance of PaginationParameters. The backend
    // will enforce a default ordering and limit, and retrieve the first page.
    optional common.PaginationParameters pagination_params = 10;
}

// Response for per-entity stats from the database.
message GetEntityStatsResponse {
    // Stats for the retrieved entities.
    // The stats are arranged in the order requested in the pagination parameters in
    // the request.
    repeated EntityStats entity_stats = 1;

    // The response containing the cursor to retrieve the next page of results.
    optional common.PaginationResponse pagination_response = 10;
}

// Request made from the plan component to the history component
// to fetch headroom stats.
message ClusterStatsRequestForHeadroomPlan {
    // The ID of the cluster to retrieve stats from.
    optional int64 cluster_id = 1;

    // The filter to apply to the stats. If not set, retrieve all stats.
    optional StatsFilter stats = 2;
}

// Get cluster stats
message ClusterStatsRequest {
    // The IDs of the cluster to retrieve stats from.
    // If empty, then the request concerns all clusters
    // in the topology
    repeated int64 cluster_ids = 1;

    // The filter to apply to the stats. If not set, retrieve all stats.
    optional StatsFilter stats = 2;

    // The pagination parameters outlying the sort order, and previous cursor (if any).
    // If not set, use the default instance of PaginationParameters. The backend
    // will enforce a default ordering and limit, and retrieve the first page.
    optional common.PaginationParameters pagination_params = 10;
}

// Chunk containing a list of entity stats
message EntityStatsChunk {
    // the stats snapshots requested grouped by cluster
    repeated EntityStats snapshots = 1;
}

// Response with cluster stats
message ClusterStatsResponse {
    oneof type {
        // the stats snapshots requested grouped by cluster
        EntityStatsChunk snapshots_chunk = 1;

        // The response containing the cursor to retrieve the next page of results.
        common.PaginationResponse pagination_response = 10;
    }
}

// The stats filter represents the restrictions to apply to stats before returning them.
// All the individual filters are AND-ed together.
message StatsFilter {
    // commodities to fetch; if omitted, requests all commoditites
    repeated CommodityRequest commodity_requests = 1;

    // a list of the attributes of the given commodities to extract, e.g. "used" or "peak"; if ommited, requests all
    repeated string commodity_attributes = 2;

    // date range for the request; if omitted, implies "now"; dates are epoch longs
    optional int64 start_date = 3;

    optional int64 end_date = 4;

    // force data to be returned only for explicitly specified rollup period (specified in milliseconds)
    // this is not an enum (latest/hourly/daily/monthly) to decouple from history implementation
    optional int64 rollup_period = 5;

    // Request projected headroom or not.
    optional bool requestProjectedHeadroom = 6 [default = false];

    // Specify the commodity to fetch along with filters and grouping
    message CommodityRequest {

        // the name of the commodity to fetch
        optional string commodity_name = 1;

        // A list of property/value sub-filters to select which data rows should be returned; multiple
        // filters are 'and'-ed together. The result must match all the given property_value_filters.
        repeated PropertyValueFilter property_value_filter = 2;

        // A list of property names to aggregate stats over, as in an SQL 'group by' clause.
        repeated string group_by = 3;

        // If present, limit the ServiceEntities processed to the given type.
        optional string related_entity_type = 4;
    }

    // a filter to implment the equivalent of 'where <property> = <value>'
    message PropertyValueFilter {

        // the property to filter on
        optional string property = 1;

        // the value of this property to be matched on
        optional string value = 2;
    }
}

// Request for stats from the latest projected topology.
message ProjectedStatsRequest {
    // The entities to gather stats for. If empty, get them for the whole topology!
    repeated int64 entities = 1;

    // The commodities to retrieve.
    repeated string commodity_name = 2;

    // providerOid
    repeated int64 providers = 3;
}

// Request for GetMostRecentStat rpc
message GetMostRecentStatRequest {
    // name of commodity for which stat is requested. E.g. StorageAmount.
    optional string commodity_name = 1;
    // key of the commodity for which stat is requested. E.g. vol-0d4bca84.
    optional string commodity_key = 2 [deprecated = true];
    // entity type for which the stat is requested. E.g. VirtualMachine.
    optional string entity_type = 3;
    // oid of the provider of the commodity for which the stat is being requested.
    optional string provider_id = 4;
}

// Response for GetMostRecentStat rpc
message GetMostRecentStatResponse {
    // date of the most recent stat
    optional uint64 snapshot_date = 1;
    // historical epoch of the stat
    optional StatHistoricalEpoch epoch = 2;
    // name of the entity to which the stat belongs
    optional string entity_display_name = 3;
    // uuid of the entity to which the stat belongs
    optional uint64 entity_uuid = 4;
}

// Historical epoch to which a stat may belong. For example, if a stat was retrieved from an hourly
// table, then the StatHistoricalEpoch would be HOUR.
enum StatHistoricalEpoch {
    HOUR = 1;
    DAY = 2;
    MONTH = 3;
}

// Request for per-entity stats from the latest projected topology.
message ProjectedEntityStatsRequest {
    // The entities to gather stats for. If empty, get them for the whole topology!
    optional EntityStatsScope scope = 1;

    // The commodities to retrieve.
    repeated string commodity_name = 2;

    // Providers. If empty, get all the providers
    repeated int64 providers = 3;

    // The pagination parameters outlying the sort order, and previous cursor (if any).
    // If not set, use the default instance of PaginationParameters. The backend
    // will enforce a default ordering and limit, and retrieve the first page.
    optional common.PaginationParameters pagination_params = 10;
}

// Response for per-entity stats from the latest projected topology.
message ProjectedEntityStatsResponse {
    // Stats for the retrieved entities.
    // The stats are arranged in the order requested in the pagination parameters in
    // the request.
    repeated EntityStats entity_stats = 1;

    // The response containing the cursor to retrieve the next page of results.
    optional common.PaginationResponse pagination_response = 10;
}

// the top-level response for the snapshot - taken at a given time, for a time range, containing a set of records
// that satisfy the StatsRequest
message StatSnapshot {

    // the actual snapshot_date for this response
    optional uint64 snapshot_date = 1;

    // the individual stat_records collected; if the input was a group, these values will be averaged over the group
    repeated StatRecord stat_records = 4;

    // the type of time period that this snapshot represents
    optional StatEpoch stat_epoch = 5;

    // an individual stats value - e.g. commodies, etc. - from the xx_stats_zz tables.
    message StatRecord {

        // name of the particular stat, e.g. priceIndex, actions, Produces, numVMsand etc.
        optional string name = 1;

        // capacity for the commodities PROVIDED by this entity; null otherwise
        optional StatValue capacity = 2;

        // amount reserved - ?for reservation/deployment functionality?
        optional float reserved = 3;

        // a key for the type of the commodity, e.g.   - see com.vmturbo.platform.common.dto.CommonDTO.proto,
        // the enum {@link CommodityType}, for the known commodity names, e.g.
        //   STORAGE, MEM_ALLOCATION, CPU_ALLOCATION, NUMBER_CONSUMERS, FLOW_ALLOCATION, Q1_VCPU, etc.
        optional string stat_key = 4;

        // for commodities CONSUMED by this entity, the OID of the provider
        optional string provider_uuid = 5;

        // for commodities CONSUMED by this entity, the display_name of the provider
        optional string provider_display_name = 6;

        // units suffix for this commodity
        optional string units = 7;

        // current value for this commodity - for most recent value ???
        optional float current_value = 8;

        // avg for these secondary stats - for rolled-up values
        optional StatValue values = 9;

        // used for these secondary stats - for rolled-up values
        optional StatValue used = 10;

        // max for these secondary stats - for rolled-up values
        optional StatValue peak = 11;

        // relation for the stat: (see RelationType in com.vmturbo.reports.db and
        // StatsMapper in com.vmturbo.api.component))
        // "Commodities", "CommoditiesBought", "CommoditiesFromAttributes"
        //  (e.g., priceIndex, numVCPUs, etc.)
        optional string relation = 12;

        // the entity type for the commodity returned; e.g. to distinguish the "CPUAllocation"
        // commodity sold by a VirtualDataCenter from the same commodity name ("CPUAllocation")
        // sold by a PhysicalMachine
        optional string related_entity_type = 13;

        // hist utilization values of the commodity (e.g. Percentile, Timeslot)
        repeated HistUtilizationValue hist_utilization_value = 14;

        // Describes historical aggregation value of one type
        message HistUtilizationValue {
            // Type of the history utilization value
            // Please, consider com.vmturbo.components.common.HistoryUtilizationType enumeration
            // Its apiParameterName values are potential candidates for this value
            // Right now there are "percentile" and "timeslot" values
            // These strings are passed in from API requests as special "group by"
            // values and get returned in the same form.
            required string type = 1;
            // Aggregated value for that specific history utilization type
            required StatValue usage = 2;
            // Capacity recorded for history utilization value.
            required StatValue capacity = 3;
        }

        // statistics for a given value over time
        message StatValue {
            // The highest observed value within a period. If the StatValue object represents the
            // value of a group of commodities, max is the highest max value within the group.
            optional float max = 1;

            // The smallest observed value within a period. If the StatValue object represents the
            // value of a group of commodities, min is the smallest min value within the group.
            optional float min = 2;

            // The average observed value within a period. If the StatValue object represents the
            // value of a group of commodities, avg is the average of avg values within the group.
            optional float avg = 3;

            // Sum of all avg values within a group.
            // If the StatValue represents the stats of one commodity, total = avg.
            optional float total = 4;

            // Sum of all max values within a group.
            // If the StatValue represents the stats of one commodity, total_max = max.
            optional float total_max = 5;

            // Sum of all min values within a group.
            // If the StatValue represents the stats of one commodity, total_min = min.
            optional float total_min = 6;
        }
    }
}

// Describes a type of time period
enum StatEpoch {
    // Real time historical
    HISTORICAL = 1;
    // Latest real time
    CURRENT = 2;
    // Real time projected
    PROJECTED = 3;
    // Plan source topology.
    PLAN_SOURCE = 4;
    // Plan projected topology.
    PLAN_PROJECTED = 5;
}

message EntityStats {
    optional uint64 oid = 1;
    repeated StatSnapshot statSnapshots = 2;
}

message ProjectedStatsResponse {
    // The response for projected stats contains at most one snapshot,
    // because there is only one projection.
    optional StatSnapshot snapshot = 1;
}

message DeletePlanStatsRequest{
    // TODO - karthikt : Maybe should be a list to support bulk deletes
    optional int64 topology_context_id = 1;
}

message DeletePlanStatsResponse{
}

message CommodityHeadroom {
    // Number of VMs that can be accommodated in cluster considering its utilization for given commodity.
    optional int64 headroom = 1;

    // Number of VMs that may accommodate empty cluster for given commodity.
    optional int64 capacity = 2;

    // Number of days to cluster exhaustion for given commodity.
    optional int64 days_to_exhaustion = 3;
}

message SaveClusterHeadroomRequest {
    // The ID of the cluster
    optional int64 cluster_id = 1;

    // The headroom for the cluster at the time of this request.
    optional int64 headroom = 2;

    // Deprecated - The number of VMs in the cluster at the time of this request
    optional int64 __deprecated_num_vms = 3 [deprecated = true];

    // Headroom information for CPU.
    optional CommodityHeadroom cpu_headroom_info = 4;

    // Headroom information for Memory.
    optional CommodityHeadroom mem_headroom_info = 5;

    // Headroom information for Storage.
    optional CommodityHeadroom storage_headroom_info = 6;

    // Deprecated - The number of Hosts in the cluster at the time of this request.
    optional int64 __deprecated_num_hosts = 7 [deprecated = true];

    // Deprecated - The number of Storages in the cluster at the time of this request.
    optional int64 __deprecated_num_storages = 8 [deprecated = true];

    // Growth in number of VMs for this cluster project monthly.
    optional int64 monthlyVMGrowth = 9;
}

message SaveClusterHeadroomResponse {
}

message GetStatsDataRetentionSettingsRequest {
}

message SetStatsDataRetentionSettingRequest {
    optional string retentionSettingName = 1;
    optional int32 retentionSettingValue = 2;
}

message SetStatsDataRetentionSettingResponse {
    optional setting.Setting newSetting = 1;
}

message GetAuditLogDataRetentionSettingRequest {
}

message GetAuditLogDataRetentionSettingResponse {
    optional setting.Setting auditLogRetentionSetting = 1;
}

message SetAuditLogDataRetentionSettingRequest {
    optional int32 retentionSettingValue = 1;
}

message SetAuditLogDataRetentionSettingResponse {
    optional setting.Setting newSetting = 1;
}

// The max value of a commodity over the whole stats
// retention period.
message CommodityMaxValue {
    // The type of commodity.
    optional topology.CommodityType commodityType = 1;

    // The max value for the commodity.
    optional double maxValue = 2;

    // The uuid of the producer
    optional uint64 producer_oid = 3;
}

// Return the max stats of commodities by entity.
message EntityCommoditiesMaxValues {
    // entity id
    optional uint64 oid = 1;

    // mapping from the commodity type to their max values
    // Would have been nice to use map here. But float/double
    // map values are not supported by protobuf.
    repeated CommodityMaxValue commodityMaxValues = 2;
}

message GetEntityCommoditiesMaxValuesRequest {
    // Entity Type whose commodity sold max value will be fetched.
    optional int32 entityType = 1;

    // List of commodity types whose max used value will be fetched.
    repeated int32 commodityTypes = 2;

    // If this request pertains to commodities bought - false by default
    optional bool is_bought = 3;

    // If uuids are not specified, get values for all entities
    repeated int64 uuids = 4;

    // number of days to look-back
    optional bool use_historical_comm_bought_lookback_days = 5;
}

// Request for commodity capacity values
message GetEntityCommoditiesCapacityValuesRequest {

    required string commodityTypeName = 1;

    repeated EntityUuidAndType entityUuidAndTypeSet = 2;
}

// Entity uuid and type
message EntityUuidAndType {

    required int64 entityUuid = 1;

    required int32 entityType = 2;
}

// Response of commodity capacity values
message GetEntityCommoditiesCapacityValuesResponse {

    repeated EntityToCommodityTypeCapacity entitiesToCommodityTypeCapacity = 1;
}

// Mapping a entity to a commodity type with the capacity
message EntityToCommodityTypeCapacity {

    required int64 entityUuid = 1;

    required topology.CommodityType commodityType = 2;

    required double capacity = 3;
}

// Request for system load info.
message SystemLoadInfoRequest {
    // A list of "cluster ids" - each cluster id is a request for a list of system load records.
    repeated int64 cluster_id = 1;
}

// Response for system load info.
message SystemLoadInfoResponse {
    // The ID of the cluster this response pertains to.
    optional int64 cluster_id = 1;

    // List of system load records.
    repeated SystemLoadRecord record = 2;

    // If the system load records for this cluster id could not be retrieved, this is a description
    // of the error/reason. We use this instead of the regular error mechanism because
    // the failure for a single cluster id should not fail the entire call.
    optional string error = 10;
}

// Info contained in each record of the table system_load.
// This table contains information about the system load and the commodities
// participating in the calculation of the system load.
// The system load is a value indicating how much "load" exists in a system.
// The related records are calculated and stored to the DB in history component.
// This info are used in the nightly headroom plans to calculate the headroom.
// There are 4 types of records stored in DB:
// Type 1: Used values, peak values and capacities for commodities sold by VMs.
// Type 2: Used values and peak values for commodities bought by VMs.
// Type 3: Sum of capacities per slice for commodities sold by hosts and storages.
// Type 4: System load per slice.
message SystemLoadRecord {
    // Type 1, 2, 3, 4: The id of the cluster.
    optional int64 cluster_id = 1;

    // Type 1, 2, 3, 4: The time of the system load snapshot saved in the DB.
    optional int64 snapshotTime = 2;

    // Type 1, 2: The id of the VM.
    // Type 3, 4: null
    optional int64 uuid = 3;

    // Type 1, 3, 4: null
    // Type 2: The id of the provider of the commodity to the VM.
    optional int64 producer_uuid = 4;

    // Type 1, 2, 3: The name of the type of the commodity.
    // Type 4: "system_load"
    optional string property_type = 5;

    // Type 1, 2: "used"
    // Type 3: "total_capacity"
    // Type 4: The name of the type of the commodity.
    optional string property_subtype = 6;

    // Type 1: The capacity of the commodity.
    // Type 2: null
    // Type 3, 4: The sum of the capacities for the specific commodity type in cluster.
    optional double capacity = 7;

    // Type 1, 2: The used value of the commodity.
    // Type 3: null
    // Type 4: The sum of used values for the specific commodity type in cluster.
    optional double avg_value = 8;

    // Type 1, 2: The used value of the commodity.
    // Type 3: null
    // Type 4: The sum of used values for the specific commodity type in cluster.
    optional double min_value = 9;

    // Type 1, 2: The peak value of the commodity.
    // Type 3: null
    // Type 4: The sum of used values for the specific commodity type in cluster.
    optional double max_value = 10;

    // Type 1, 4: RelationType.COMMODITIES
    // Type 2, 3: RelationType.COMMODITIESBOUGHT
    optional int32 relation_type = 11;

    // Type 1, 2: The key of the commodity type.
    // Type 3, 4: null
    optional string commodity_key = 12;
}

message GetEntityIdToEntityTypeMappingRequest {
}

message GetEntityIdToEntityTypeMappingResponse {
    map<int64, common_dto.EntityDTO.EntityType> entityIdToEntityTypeMap = 1;
}

message GetPercentileCountsRequest {
    // unset to request whole observation window
    optional int64 start_timestamp = 1;
    // chunk size for streaming
    required int32 chunk_size = 2;
}

message SetPercentileCountsResponse {
}

message PercentileChunk {
    // these two entries have to be redundant, repeated in each chunk
    // to make use of server and client-side grpc streaming and avoid re-serializing

    // unset to mark whole observation window
    optional int64 start_timestamp = 1;
    // length of a window for which these counts were calculated in seconds
    required int64 period = 2;
    // payload
    required bytes content = 3;
}

// the gRPC API entry points for the Stats service
service StatsHistoryService {

    //Get stats filtered by certain options and average over all entities listed in the request
    rpc GetAveragedEntityStats(GetAveragedEntityStatsRequest) returns (stream StatSnapshot);

    // Get stats separately for each entity listed in the request
    rpc GetEntityStats(GetEntityStatsRequest) returns (GetEntityStatsResponse);

    //Get stats filtered by certain options and average over all desired entities in the cluser.
    rpc GetClusterStats(ClusterStatsRequest) returns (stream ClusterStatsResponse);

    // Get cluster stats for headroom plan, e.g. number of VMs.
    rpc GetClusterStatsForHeadroomPlan(ClusterStatsRequestForHeadroomPlan) returns (stream StatSnapshot);

    // Get stats from the latest projected topology.
    // Will return a response with no data if the stats service
    // doesn't have any projected stats.
    rpc GetProjectedStats(ProjectedStatsRequest) returns (ProjectedStatsResponse);

     // Get per-entity stats from the latest projected topology.
    // Will return a response for each entity with no data if the stats service
    // doesn't have any projected stats.
    rpc GetProjectedEntityStats(ProjectedEntityStatsRequest) returns (ProjectedEntityStatsResponse);

    // Save values computed by the headroom plan in the cluster statistics table, where it can
    // be retrieved alongside other stats.
    //
    // This is an internal call, in the sense that user and external API request should never
    // trigger this method.
    rpc SaveClusterHeadroom(SaveClusterHeadroomRequest) returns (SaveClusterHeadroomResponse);

    // Delete plan stats
    rpc DeletePlanStats(DeletePlanStatsRequest) returns (DeletePlanStatsResponse);

    // Get Stats data Retention settings
    rpc GetStatsDataRetentionSettings(GetStatsDataRetentionSettingsRequest) returns (stream setting.Setting);

    // Set Stats Data Retention settings
    rpc SetStatsDataRetentionSetting(SetStatsDataRetentionSettingRequest) returns (SetStatsDataRetentionSettingResponse);

    // Get audit log data retention setting
    rpc GetAuditLogDataRetentionSetting(GetAuditLogDataRetentionSettingRequest) returns (GetAuditLogDataRetentionSettingResponse);

    // Set audit log data retention setting
    rpc SetAuditLogDataRetentionSetting(SetAuditLogDataRetentionSettingRequest) returns (SetAuditLogDataRetentionSettingResponse);

    // Get the historic max values(within the stats retention period) for all the non-access commodities
    // for all entities of the given entity type.
    rpc GetEntityCommoditiesMaxValues(GetEntityCommoditiesMaxValuesRequest) returns (stream EntityCommoditiesMaxValues);

    // Getting the commodity capacity values from the stats table, the returned capcity vallue is the
    // max value from the last 7 days
    rpc GetEntityCommoditiesCapacityValues(GetEntityCommoditiesCapacityValuesRequest) returns (stream GetEntityCommoditiesCapacityValuesResponse);

    // Get the system load information for a specific slice (cluster)
    rpc GetSystemLoadInfo(SystemLoadInfoRequest) returns (stream SystemLoadInfoResponse);

    // Get the entityId and the corresponding entityType.
    // NOTE: This rpc call is used for a specific upgrade use case. DON'T USE THIS FOR OTHER SCENARIOS.
    rpc GetEntityIdToEntityTypeMapping(GetEntityIdToEntityTypeMappingRequest) returns (GetEntityIdToEntityTypeMappingResponse);

    // Get the historical utilization data for the passed entities scope.
    // Ignore the time range parameter and return 1 point per commodity.
    // Historical utilizations to be returned in current_value field of statistics records.
    rpc GetHistUtilization(GetEntityStatsRequest) returns (GetEntityStatsResponse);

    // Get the percentile counts for the passed start timestamp or entire observation window
    rpc GetPercentileCounts (GetPercentileCountsRequest) returns (stream PercentileChunk);

    // Store the percentile counts for the passed start timestamp or entire observation window
    rpc SetPercentileCounts (stream PercentileChunk) returns (SetPercentileCountsResponse);

    // Get the most recent stat for a commodity from the hourly, daily or monthly tables
    rpc GetMostRecentStat (GetMostRecentStatRequest) returns (GetMostRecentStatResponse);
}
