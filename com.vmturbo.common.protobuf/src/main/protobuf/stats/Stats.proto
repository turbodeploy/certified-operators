syntax = "proto2";
package stats;

option java_package = "com.vmturbo.common.protobuf.stats";

import "common/Pagination.proto";
import "group/GroupDTO.proto";
import "setting/Setting.proto";
import "topology/TopologyDTO.proto";

message GetAveragedEntityStatsRequest {
    // The entities to gather stats for. These could be the IDs of individual entities, a plan,
    // or the global market.
    repeated int64 entities = 1;

    // The filter to apply to the stats. If not set, retrieve all stats.
    optional StatsFilter filter = 2;

    // The entity type to restrict stats to; if not set, include all entity types
    optional string relatedEntityType = 3;
}

// The scope for an entity stats query.
message EntityStatsScope {
    message EntityList {
        // If empty, return no results.
        repeated int64 entities = 1;
    }

    oneof scope {
        // Scope the entity stats request to a specific list of entities.
        EntityList entity_list = 1;

        // Scope the entity stats request to entities of a specific type.
        int32 entity_type = 2;
    }
}

message GetEntityStatsRequest {
    // The entities to gather stats for. If not set, return no results.
    optional EntityStatsScope scope = 1;

    // The filter to apply to the stats. If not set, retrieve all stats.
    optional StatsFilter filter = 2;

    // The pagination parameters outlying the sort order, and previous cursor (if any).
    // If not set, use the default instance of PaginationParameters. The backend
    // will enforce a default ordering and limit, and retrieve the first page.
    optional common.PaginationParameters pagination_params = 10;
}

// Response for per-entity stats from the database.
message GetEntityStatsResponse {
    // Stats for the retrieved entities.
    // The stats are arranged in the order requested in the pagination parameters in
    // the request.
    repeated EntityStats entity_stats = 1;

    // The response containing the cursor to retrieve the next page of results.
    optional common.PaginationResponse pagination_response = 10;
}

message ClusterStatsRequest {
    // The ID of the cluster to retrieve stats from.
    optional int64 cluster_id = 1;

    // The filter to apply to the stats. If not set, retrieve all stats.
    optional StatsFilter stats = 2;
}

// The stats filter represents the restrictions to apply to stats before returning them.
// All the individual filters are AND-ed together.
message StatsFilter {
    // commodities to fetch; if omitted, requests all commoditites
    repeated CommodityRequest commodity_requests = 1;

    // a list of the attributes of the given commodities to extract, e.g. "used" or "peak"; if ommited, requests all
    repeated string commodity_attributes = 2;

    // date range for the request; if omitted, implies "now"; dates are epoch longs
    optional int64 start_date = 3;

    optional int64 end_date = 4;

    // Specify the commodity to fetch along with filters and grouping
    message CommodityRequest {

        // the name of the commodity to fetch
        optional string commodity_name = 1;

        // A list of property/value sub-filters to select which data rows should be returned; multiple
        // filters are 'and'-ed together. The result must match all the given property_value_filters.
        repeated PropertyValueFilter property_value_filter = 2;

        // A list of property names to aggregate stats over, as in an SQL 'group by' clause.
        repeated string group_by = 3;

        // If present, limit the ServiceEntities processed to the given type.
        optional string related_entity_type = 4;
    }

    // a filter to implment the equivalent of 'where <property> = <value>'
    message PropertyValueFilter {

        // the property to filter on
        optional string property = 1;

        // the value of this property to be matched on
        optional string value = 2;
    }
}

// Request for stats from the latest projected topology.
message ProjectedStatsRequest {
    // The entities to gather stats for. If empty, get them for the whole topology!
    repeated int64 entities = 1;

    // The commodities to retrieve.
    repeated string commodity_name = 2;
}

// Request for per-entity stats from the latest projected topology.
message ProjectedEntityStatsRequest {
    // The entities to gather stats for. If empty, get them for the whole topology!
    repeated int64 entities = 1;

    // The commodities to retrieve.
    repeated string commodity_name = 2;

    // The pagination parameters outlying the sort order, and previous cursor (if any).
    // If not set, use the default instance of PaginationParameters. The backend
    // will enforce a default ordering and limit, and retrieve the first page.
    optional common.PaginationParameters pagination_params = 10;
}

// Response for per-entity stats from the latest projected topology.
message ProjectedEntityStatsResponse {
    // Stats for the retrieved entities.
    // The stats are arranged in the order requested in the pagination parameters in
    // the request.
    repeated EntityStats entity_stats = 1;

    // The response containing the cursor to retrieve the next page of results.
    optional common.PaginationResponse pagination_response = 10;
}

// the top-level response for the snapshot - taken at a given time, for a time range, containing a set of records
// that satisfy the StatsRequest
message StatSnapshot {

    // the actual snapshot_date for this response
    optional string snapshot_date = 1;

    // the oldest date of the request time window
    optional uint64 start_date = 2;

    // the most recent date of the request time window
    optional uint64 end_date = 3;

    // the individual stat_records collected; if the input was a group, these values will be averaged over the group
    repeated StatRecord stat_records = 4;

    // an individual stats value - e.g. commodies, etc. - from the xx_stats_zz tables.
    message StatRecord {

        // name of the particular stat, e.g. priceIndex, actions, Produces, numVMsand etc.
        optional string name = 1;

        // capacity for the commodities PROVIDED by this entity; null otherwise
        optional StatValue capacity = 2;

        // amount reserved - ?for reservation/deployment functionality?
        optional float reserved = 3;

        // a key for the type of the commodity, e.g.   - see com.vmturbo.platform.common.dto.CommonDTO.proto,
        // the enum {@link CommodityType}, for the known commodity names, e.g.
        //   STORAGE, MEM_ALLOCATION, CPU_ALLOCATION, NUMBER_CONSUMERS, FLOW_ALLOCATION, Q1_VCPU, etc.
        optional string stat_key = 4;

        // for commodities CONSUMED by this entity, the OID of the provider
        optional string provider_uuid = 5;

        // for commodities CONSUMED by this entity, the display_name of the provider
        optional string provider_display_name = 6;

        // units suffix for this commodity
        optional string units = 7;

        // current value for this commodity - for most recent value ???
        optional float current_value = 8;

        // avg for these secondary stats - for rolled-up values
        optional StatValue values = 9;

        // used for these secondary stats - for rolled-up values
        optional StatValue used = 10;

        // max for these secondary stats - for rolled-up values
        optional StatValue peak = 11;

        // relation for the stat: (see RelationType in com.vmturbo.reports.db and
        // StatsMapper in com.vmturbo.api.component))
        // "Commodities", "CommoditiesBought", "CommoditiesFromAttributes"
        //  (e.g., priceIndex, numVCPUs, etc.), and "plan"
        optional string relation = 12;

        // statistics for a given value over time
        message StatValue {
            optional float max = 1;
            optional float min = 2;
            optional float avg = 3;
            optional float total = 4;

        }
    }
}

message EntityStats {
    optional uint64 oid = 1;
    repeated StatSnapshot statSnapshots = 2;
}

message ProjectedStatsResponse {
    // The response for projected stats contains at most one snapshot,
    // because there is only one projection.
    optional StatSnapshot snapshot = 1;
}

// Request sent to the Stats Service when it is time to compute roll-up stats for clusters.
message ClusterRollupRequest {
    // The list of clusters for which stats roll-up should be calculated.
    repeated .group.Group clustersToRollup = 1;
}

message ClusterRollupResponse {
    // nothing to return
}

message DeletePlanStatsRequest{
    // TODO - karthikt : Maybe should be a list to support bulk deletes
    optional int64 topology_context_id = 1;
}

message DeletePlanStatsResponse{
}

message SaveClusterHeadroomRequest {
    // The ID of the cluster
    optional int64 cluster_id = 1;

    // The headroom for the cluster at the time of this request.
    optional int64 headroom = 2;

    // The number of VMs in the cluster at the time of this request
    optional int64 numVMs = 3;
}

message SaveClusterHeadroomResponse {
}

message GetStatsDataRetentionSettingsRequest {
}

message SetStatsDataRetentionSettingRequest {
    optional string retentionSettingName = 1;
    optional int32 retentionSettingValue = 2;
}

message SetStatsDataRetentionSettingResponse {
    optional setting.Setting newSetting = 1;
}

message GetAuditLogDataRetentionSettingRequest {
}

message GetAuditLogDataRetentionSettingResponse {
    optional setting.Setting auditLogRetentionSetting = 1;
}

message SetAuditLogDataRetentionSettingRequest {
    optional int32 retentionSettingValue = 1;
}

message SetAuditLogDataRetentionSettingResponse {
    optional setting.Setting newSetting = 1;
}

// The max value of a commodity over the whole stats
// retention period.
message CommodityMaxValue {

    // The type of commodity.
    optional topology.CommodityType commodityType = 1;

    // The max value for the commodity.
    optional double maxValue = 2;
}

// Return the max stats of the commodities sold by the entity.
message EntityCommoditiesMaxValues {
    // entity id
    optional uint64 oid = 1;

    // mapping from the commodity type to their max values
    // Would have been nice to use map here. But float/double
    // map values are not supported by protobuf.
    repeated CommodityMaxValue commodityMaxValues = 2;
}

message GetEntityCommoditiesMaxValuesRequest {
    // List of entity types whose commodity sold max values has to be fetched.
    repeated int32 entityTypes = 1;
}

// the gRPC API entry points for the Stats service
service StatsHistoryService {

    //Get stats filtered by certain options and average over all entities listed in the request
    rpc GetAveragedEntityStats(GetAveragedEntityStatsRequest) returns (stream StatSnapshot);

    // Get stats separately for each entity listed in the request
    rpc GetEntityStats(GetEntityStatsRequest) returns (GetEntityStatsResponse);

    //Get stats filtered by certain options and average over all desired entities in the cluser.
    rpc GetClusterStats(ClusterStatsRequest) returns (stream StatSnapshot);

    // Get stats from the latest projected topology.
    // Will return a response with no data if the stats service
    // doesn't have any projected stats.
    rpc GetProjectedStats(ProjectedStatsRequest) returns (ProjectedStatsResponse);

     // Get per-entity stats from the latest projected topology.
    // Will return a response for each entity with no data if the stats service
    // doesn't have any projected stats.
    rpc GetProjectedEntityStats(ProjectedEntityStatsRequest) returns (ProjectedEntityStatsResponse);

    // Trigger a cluster-rollup computation for the given clusters.
    // Will return no significant data.
    rpc ComputeClusterRollup(ClusterRollupRequest) returns (ClusterRollupResponse);

    // Save values computed by the headroom plan in the cluster statistics table, where it can
    // be retrieved alongside other stats.
    //
    // This is an internal call, in the sense that user and external API request should never
    // trigger this method.
    rpc SaveClusterHeadroom(SaveClusterHeadroomRequest) returns (SaveClusterHeadroomResponse);

    // Delete plan stats
    rpc DeletePlanStats(DeletePlanStatsRequest) returns (DeletePlanStatsResponse);

    // Get Stats data Retention settings
    rpc GetStatsDataRetentionSettings(GetStatsDataRetentionSettingsRequest) returns (stream setting.Setting);

    // Set Stats Data Retention settings
    rpc SetStatsDataRetentionSetting(SetStatsDataRetentionSettingRequest) returns (SetStatsDataRetentionSettingResponse);

    // Get audit log data retention setting
    rpc GetAuditLogDataRetentionSetting(GetAuditLogDataRetentionSettingRequest) returns (GetAuditLogDataRetentionSettingResponse);

    // Set audit log data retention setting
    rpc SetAuditLogDataRetentionSetting(SetAuditLogDataRetentionSettingRequest) returns (SetAuditLogDataRetentionSettingResponse);

    // Get the historic max values(within the stats retention period) for all the non-access commodities
    // for all entities of the given entity type.
    rpc GetEntityCommoditiesMaxValues(GetEntityCommoditiesMaxValuesRequest) returns (stream EntityCommoditiesMaxValues);
}
