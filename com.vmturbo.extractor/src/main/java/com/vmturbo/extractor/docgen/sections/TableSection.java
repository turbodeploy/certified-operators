package com.vmturbo.extractor.docgen.sections;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import com.fasterxml.jackson.core.JsonPointer;
import com.fasterxml.jackson.databind.JsonNode;
import com.google.common.collect.ImmutableList;

import org.jooq.Configuration;
import org.jooq.DataType;
import org.jooq.Field;
import org.jooq.Record;
import org.jooq.SQLDialect;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.UniqueKey;
import org.jooq.impl.DefaultConfiguration;

import com.vmturbo.extractor.docgen.Section;

/**
 * Documentation section generator for a schema table.
 *
 * @param <R> Record type of table
 */
public class TableSection<R extends Record> extends Section<TableField<R, ?>> {

    private static final Configuration POSTGRES_CONFIG
            = new DefaultConfiguration().set(SQLDialect.POSTGRES);

    private final Table<R> table;

    /**
     * Create a new instance.
     *
     * @param table   an instance of the table to be documented
     * @param docTree JSON structure containing document snippets
     */
    public TableSection(Table<R> table, final JsonNode docTree) {
        super(table.getName(), "/tables/" + table.getName(), docTree);
        this.table = table;
    }

    @Override
    public List<TableField<R, ?>> getItems() {
        return Arrays.stream(table.fields())
                .map(f -> (TableField<R, ?>)f)
                .collect(Collectors.toList());
    }

    @Override
    public List<String> getFieldNames() {
        return ImmutableList.of("Type", "Nullable", "Primary", "Description");
    }

    @Override
    public Optional<String> getFieldValue(final TableField<R, ?> field, final String fieldName) {
        switch (fieldName) {
            case "Type":
                return Optional.of(getTypeSpec(field));
            case "Nullable":
                final boolean nullable = field.getDataType().nullability().nullable();
                return Optional.of(Boolean.valueOf(nullable).toString());
            case "Primary":
                final UniqueKey<?> primaryKey = table.getPrimaryKey();
                if (primaryKey != null) {
                    final boolean isPrimary = primaryKey.getFields().contains(field);
                    return Optional.of(Boolean.valueOf(isPrimary).toString());
                } else {
                    return Optional.of(Boolean.FALSE.toString());
                }
            default:
                return super.getFieldValue(field, fieldName);
        }
    }

    private String getTypeSpec(final Field<?> field) {
        final DataType<?> type = field.getDataType(POSTGRES_CONFIG);
        final String name = type.getTypeName(POSTGRES_CONFIG);
        String lenPrecScale = "";
        if (type.hasLength()) {
            lenPrecScale = "(" + type.length() + ")";
        } else if (type.hasPrecision() && !(type.isTemporal() && type.precision() == 0)) {
            lenPrecScale = "(" + type.precision();
            if (type.hasScale()) {
                lenPrecScale += ", " + type.scale();
            }
            lenPrecScale += ")";
        }
        String identity = type.identity() ? " GENERATED BY DEFAULT AS IDENTITY" : "";
        return name + lenPrecScale + identity;
    }

    @Override
    public JsonPointer getItemDocPath(final TableField<R, ?> field) {
        return docPathPrefix.append(JsonPointer.compile("/columns/" + field.getName()));
    }

    @Override
    public String getItemName(final TableField<R, ?> field) {
        return field.getName();
    }

    @Override
    public String getType() {
        return "table";
    }
}
