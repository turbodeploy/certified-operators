package com.vmturbo.components.test.utilities.alert.jira;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;

import javax.annotation.Nonnull;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.google.common.annotations.VisibleForTesting;

import com.vmturbo.components.test.utilities.alert.RuleSignature;
import com.vmturbo.components.test.utilities.alert.TriggeredAlert;
import com.vmturbo.components.test.utilities.alert.jira.JiraIssue.JiraTransition.Type;
import com.vmturbo.components.test.utilities.alert.report.ResultsTabulator;

/**
 * Handles alerts triggered by performance tests.
 *
 * Responsible for creating or reopening issues in Jira related to performance regressions
 * identified by {@link TriggeredAlert}s.
 */
public class AlertProcessorForJira {
    public static final String ALERT_METRIC_PREFIX = "__";
    public static final String AUTOMATION_ISSUE_LABEL = ALERT_METRIC_PREFIX + "xl_performance_regression";
    public static final String TARGET_XL_VERSION = "XL 2.0";
    public static final String DEFAULT_METRICS_DASHBOARD_URL = "http://10.10.173.17:3000/";

    private static final String metricsDashboardUrl =
        System.getProperty("alert.rule.metrics.dashboard.url", DEFAULT_METRICS_DASHBOARD_URL);

    /**
     * If this system property is set to true, permit creating and updating jira issues
     * on increasing alerts.
     */
    public static final String CREATE_JIRA_ISSUES_PROPERTY = "create.jira.issues";

    private static final Logger logger = LogManager.getLogger();

    private final JiraCommunicator jira;

    private final boolean createIssuesOnAlerts;

    public AlertProcessorForJira(@Nonnull final JiraCommunicator jira) {
        this.jira = Objects.requireNonNull(jira);
        this.createIssuesOnAlerts = Boolean.getBoolean(CREATE_JIRA_ISSUES_PROPERTY);
    }

    /**
     * Process the alerts generated by the test run, potentially generating
     * or re-opening tickets in Jira for performance regressions.
     *
     * @param alerts The performance alerts that were triggered by tests.
     */
    public void processAlerts(@Nonnull final Collection<TriggeredAlert> alerts) {
        List<TriggeredAlert> increasingAlerts = alerts.stream()
            .filter(TriggeredAlert::isRegressionOrSlaViolation)
            .collect(Collectors.toList());

        if (!createIssuesOnAlerts) {
            if (!increasingAlerts.isEmpty()) {
                logger.info("Jira issue creation is disabled. " +
                    "Skipping Jira issue creation even though there are relevant alerts.");
            }
            return;
        }

        try {
            final Map<RuleSignature, List<TriggeredAlert>> alertsBySignature = increasingAlerts.stream()
                .collect(Collectors.groupingBy(alert ->
                    new RuleSignature(alert.getTestClassName(), alert.getMetric())));

            alertsBySignature.forEach((ruleSignature, alertsForSignature) -> {
                final Optional<JiraIssue> existingIssue = jira.exactSearch(queryFor(ruleSignature));
                if (existingIssue.isPresent()) {
                    processAlertsForIssue(existingIssue.get(), alertsForSignature);
                } else {
                    createIssue(ruleSignature, alertsForSignature);
                }
            });
        } catch (RuntimeException e) {
            logger.error("Error when processing alerts: ", e);
        }
    }

    /**
     * If the issue is closed, reopen it.
     * Post a comment containing details about the alert's triggering reason(s).
     *
     * @param issue The existing issue related to the alert.
     * @param alerts The alerts that was triggered for the recent test run.
     */
    private void processAlertsForIssue(@Nonnull final JiraIssue issue,
                                       @Nonnull final List<TriggeredAlert> alerts) {
        if (issue.isClosed()) {
            jira.transitionIssue(issue.getKey(), Type.REOPEN);
        }
        jira.commentOnIssue(issue.getKey(), commentsFor(alerts));
    }

    /**
     * Create an issue for an alert.
     * Should only be called when no issue for the alert already exists.
     *
     * @param ruleSignature The signature for the rule or set of rules that triggered the alert.
     * @param alerts An alert that was triggered for the recent test run.
     */
    private void createIssue(@Nonnull final RuleSignature ruleSignature,
                             @Nonnull final List<TriggeredAlert> alerts) {
        final JiraIssue issue = JiraIssue.xlBugBuilder()
            .labels(AUTOMATION_ISSUE_LABEL)
            .summary(summaryFor(ruleSignature))
            .version(TARGET_XL_VERSION)
            .fixVersion(TARGET_XL_VERSION)
            .description(descriptionFor(alerts))
            .build();

        final JiraIssue createdIssue = jira.createIssue(issue);
        jira.commentOnIssue(createdIssue.getKey(), commentsFor(alerts));
    }

    @Nonnull
    private String descriptionFor(@Nonnull final List<TriggeredAlert> alerts) {
        final String alertsDetails = alerts.stream()
            .map(TriggeredAlert::ruleDescription)
            .distinct()
            .collect(Collectors.joining("\n"));

        return "The XL Performance testing framework has detected a performance regression. Alerts details:\n\n" +
            alertsDetails + "\n\nSee comments for additional details or visit " + metricsDashboardUrl + " " +
            "to view performance trends.";
    }

    @VisibleForTesting
    @Nonnull
    String summaryFor(@Nonnull final RuleSignature ruleSignature) {
        return "Performance regression on " +
            ruleSignature.testClassName + " " +
            ruleSignature.metricsDescription()
                .replace("{", "(")              // Replace braces with parens because SpringFramework RestTemplate
                .replace("}", ")");             // will try to interpret '{}' as a vararg to be substituted.
    }

    @Nonnull
    private String commentsFor(@Nonnull final List<TriggeredAlert> alerts) {
        final ResultsTabulator tabulator = new ResultsTabulator();
        // Place inside noformat tags to ensure jira does not attempt to improperly format our tables.
        return tabulator.renderMeasurements(alerts.stream()
            .map(TriggeredAlert::getMeasurement))
            .collect(Collectors.joining("\n\n", "{noformat}\n", "\n{noformat}"));
    }

    @Nonnull
    private JiraIssue.Query queryFor(@Nonnull final RuleSignature ruleSignature) {
        return JiraIssue.Query.newBuilder()
            .creator(JiraCommunicator.DEFAULT_USERNAME)
            .labels(AUTOMATION_ISSUE_LABEL)
            .summarySearch(summaryFor(ruleSignature))
            .build();
    }
}
