package com.vmturbo.protoc.grpc.moles;

import org.stringtemplate.v4.ST;

/**
 * Templates for the code generated by {@link MoleCodeGenerator}.
 */
class MoleTemplateFactory {

    static ST service() {
        return new ST(SERVICE_TEMPLATE);
    }

    static ST serviceMethod(final boolean clientStream) {
        return new ST(clientStream ?
                CLIENT_STREAM_SERVICE_METHOD_TEMPLATE : NO_CLIENT_STREAM_SERVICE_METHOD_TEMPLATE);
    }

    private static final String SERVICE_TEMPLATE =
            "\n/**\n" +
            "* This class is a spy-able implementation of <serviceName>.\n" +
            "*/\n" +
            "public static class <serviceName>Mole extends <package>.<serviceName>Grpc.<serviceName>ImplBase {" +
                // Individual method definitions
                "<methodDefinitions>" +
            "}";

    // We keep it simple - this interface is very restless, and no frills.
    // POST <service name>/<method name>
    private static final String NO_CLIENT_STREAM_SERVICE_METHOD_TEMPLATE =
            "<if(isServerStream)>" +
                 "\n/**\n" +
                 "* Use this method (use Mockito.when() to return the right value) to control the return of the real <methodName>.\n" +
                 "* Each element in the returned list will become a stream element in the response.\n" +
                 "*/\n" +
                "public List\\<<outputType>> <methodName>(<inputType> input) { " +
                    "return Collections.emptyList();" +
                "}" +
            "<else>" +
                "\n/**\n" +
                "* Use this method (use Mockito.when() to return the right value) to control the return of the real <methodName>.\n" +
                "*/\n" +
                "public <outputType> <methodName>(<inputType> input) { " +
                    "return <outputType>.getDefaultInstance();" +
                "}" +
            "<endif>" +
                "\n/**\n" +
                "* Use this method (use Mockito.when() to return a non-empty optional) to return an error from the real <methodName>.\n" +
                "*/\n" +
                "public Optional\\<Throwable> <methodName>Error(<inputType> input) { " +
                    "return Optional.empty();" +
                "}" +
                " @Override " +
                "public void <methodName> (<inputType> input, StreamObserver\\<<outputType>> responseObserver) {" +
                    "Optional\\<Throwable> error = <methodName>Error(input);" +
                    "if (error.isPresent()) { " +
                        "responseObserver.onError(error.get());" +
                        "return;" +
                    "} else {" +
                        "<if(isServerStream)>" +
                            "<methodName>(input).forEach(responseObserver::onNext);" +
                        "<else>" +
                            "responseObserver.onNext(<methodName>(input));" +
                        "<endif>" +
                            "responseObserver.onCompleted();" +
                    "}"  +
                "}";

    private static final String CLIENT_STREAM_SERVICE_METHOD_TEMPLATE =
            "<if(isServerStream)>" +
                "\n/**\n" +
                "* Use this method (use Mockito.when() to return the right value) to control the return of the real <methodName>.\n" +
                "* Each element in the returned list will become a stream element in the response.\n" +
                "*/\n" +
                "public List\\<<outputType>> <methodName>(List\\<<inputType>> input) { " +
                    "return Collections.emptyList();" +
                "}" +
            "<else>" +
                "\n/**\n" +
                "* Use this method (use Mockito.when() to return the right value) to control the return of the real <methodName>.\n" +
                "*/\n" +
                "public <outputType> <methodName>(List\\<<inputType>> input) { " +
                    "return <outputType>.getDefaultInstance();" +
                "}" +
            "<endif>" +
                "\n/**\n" +
                "* Use this method (use Mockito.when() to return a non-empty optional) to return an error from the real <methodName>.\n" +
                "*/\n" +
                "public Optional\\<Throwable> <methodName>Error(List\\<<inputType>> input) { " +
                    "return Optional.empty();" +
                "}" +
                " @Override " +
                "public StreamObserver\\<<inputType>> <methodName> (StreamObserver\\<<outputType>> responseObserver) {" +
                    "// Return a stream observer that waits until it receives all the input before returning the result (or error).\n" +
                    "return new StreamObserver\\<<inputType>>() {" +
                        "private List\\<<inputType>> combinedInput = new LinkedList\\<<inputType>>();" +
                        " @Override " +
                        "public void onNext(<inputType> input) { " +
                            "combinedInput.add(input);" +
                        "}" +
                        " @Override " +
                        "public void onError(Throwable t) { " +
                            "// Re-throw any errors back to client.\n" +
                            "responseObserver.onError(t);" +
                        "}" +
                        " @Override " +
                        "public void onCompleted() { " +
                            "Optional\\<Throwable> error = <methodName>Error(combinedInput);" +
                            "if (error.isPresent()) { " +
                                "responseObserver.onError(error.get());" +
                                "return;" +
                            "} else {" +
                                "<if(isServerStream)>" +
                                    "<methodName>(combinedInput).forEach(responseObserver::onNext);" +
                                "<else>" +
                                    "responseObserver.onNext(<methodName>(combinedInput));" +
                                "<endif>" +
                                    "responseObserver.onCompleted();" +
                            "}" +
                        "}" +
                    "};" +
                "}";
}
