syntax = "proto2";
package com.vmturbo.topology.processor.api;

import "topology/TopologyDTO.proto";
import "action/ActionNotificationDTO.proto";

message TargetSpec {
    // Probe identifier.
    required int64 probe_id = 1;
    // Account values, used for this target.
    repeated AccountValue account_value = 2;
    // This field has been deprecated as it is made redundant by derived_target_ids.
    optional int64 parent_id = 3 [deprecated = true];
    // This field indicates whether the target should be show on UI.
    optional bool is_hidden = 4 [default = false];
    // This field indicates whether the target cannot be changed through public APIs.
    optional bool read_only = 5 [default = false];
    // This field stores the derived target IDs associated with this target.
    repeated int64 derived_target_ids = 6;
    // This field is used to constrain a target to communicate over a single channel. A target with
    // a channel can only be discovered by probes on the same channel.
    optional string communicationBindingChannel = 7;
    // The last editing user.
    optional string last_editing_user = 8;
    // The last edit time.
    optional int64 last_edit_time = 9;
}

message TargetInfo {
    // Target identifier.
    required int64 id = 1;

    optional TargetSpec spec = 2;

    // The target display name, used for the UI and for logging.
    optional string display_name = 3;
}

// Messages, sent by server side of API
message TopologyProcessorNotification {

    // The ID of the notification broadcast this notification belongs to.
    // Each notification's broadcast has a unique ID for logging/debugging purposes.
    required int64 broadcast_id = 1;

    oneof type {
        // Error message shows, that client side could not process the request.
        string error = 2;

        // Notification of validation result.
        OperationStatus validation_notification = 7;

        // Notification of validation result.
        OperationStatus discovery_notification = 8;

        // Notification of target is removed event.
        int64 target_removed_notification = 9;

        // Notification of target has been changed event.
        TargetInfo target_changed_notification = 10;

        // Notification of new target has been added event.
        TargetInfo target_added_notification = 11;

        // Notification of an update about action execution progress.
        .action.ActionProgress action_progress = 12;

        // Notification of an action completing successfully.
        .action.ActionSuccess action_success = 13;

        // Notification of an action completing unsuccessfully.
        .action.ActionFailure action_failure = 14;

        // Notifications that some actions got lost - the Topology Processor no longer knows
        // whether they are still in progress, succeeded, or failed. It's up to the listener
        // to decide how to treat these actions.
        ActionsLost actions_lost = 15;

        // Notification of a probe having successfully registered.
        ProbeInfo probe_registration_notification = 20;
    }
}

// Describes actions the Topology Processor lost state for.
// This is not together with the other action notificatons - "ActionProgress", "ActionSuccess", and
// "ActionFailure" - because this one doesn't need to be shared across multiple component APIs.
message ActionsLost {

    oneof type {
        // Specific actions were lost. This could happen if one of the probes goes down -
        // the probes are stateless, so even if it comes back up it will not know if the request
        // it triggered before restart is still in progress, has succeeded, or has failed.
        ActionIds lost_action_id = 1;

        // All in-progress actions started before this time were lost.
        // The topology processor doesn't know their IDs.
        // This will happen during a topology processor restart.
        // The time is a unix timestamp.
        //
        // Note - because clocks can be out of sync between services (especially if services are
        // on different nodes) we should be careful when comparing this timestamp to other
        // timestamps across component instances. However, it's reasonable to expect that the
        // times across containers are roughly in sync (e.g. not hours apart).
        int64 before_time = 2;
    }

    message ActionIds {
        // The IDs of the lost actions.
        // An empty list means no actions were lost. We use ActionsLost.all_lost = true to indicate
        // when ALL actions were lost.
        repeated int64 action_ids = 1;
    }
}

// Status of operation (validation, discovery, action execution)
message OperationStatus {
    // Unique id of the operation
    required int64 id = 1;
    // start time of the operation
    required int64 start_time = 2;
    // completion time of the operation
    optional int64 end_time = 3;
    // Id of the target the operation has been associated with
    required int64 target_id = 4;
    // Overall status of the operation. If status is IN_PROGRESS, end_time should not be set
    required Status status = 5;
    // error messages, if any
    repeated string error_messages = 6;

    // The status of a operation.
    enum Status {
        // Indicates the operation is in progress.
        IN_PROGRESS = 0;
        // Indicates the operation has completed and succeeded.
        SUCCESS = 1;
        // Indicates the operation has completed and failed.
        FAILED = 2;
    }
}

// Structure to hold account parameters, passed to probe to connect and authenticate
// to target.
message AccountValue {
    // Name of the parameter. Should refer to the "name" field of AccountDefEntry message,
    // which is returned by the probe in registration phase, for example "userName",
    // "password" and so on.
    required string key = 1;

    // String representation of the parameter value, for example "secretpassword",
    // "192.168.111.3" and so on.
    optional string string_value = 2;

    // Set of property value lists
    repeated PropertyValueList group_scope_property_values = 3;

    message PropertyValueList {
        repeated string value = 1;
    }
}

// The AccountDefinitionEntry class defines a single field that is part of the account credentials
// a user must specify to connect to a target of this probe type. Note that for every probe, the
// 'TARGET_IDENTIFIER' is a mandatory field.
//
// It's the responsibility of your probe to define the credentials it needs to attach to a target. When adding an associated target to
// Operations Manager via the REST API, the API call includes parameters for each of the credentials defined here.
// When attaching via the Operations Manager GUI, the credentials defined here appear in the GUI as individual fields.
// For a given probe, you define the credentials as a Set of AccountDefinitionEntry objects.
message AccountDefEntry {
    // The name of this entry field. The name must be unique for all of the entries you
    // define for this probe.
    required string name = 1;

    // The display name of this entry. This is the name that appears in the user interface.
    required string display_name = 2;
    // Description of what this entry represents.
    required string description = 3;

    // A regular expression to validate a field. If the user's input matches the
    // regular expression, then the entry is valid.
    // For example, you can validate that the entered text is only numbers and period characters
    // for an IP address. To disable validation (allow any text), pass {@code ".*"}.
    optional string verification_regex = 4 [default = ".*"];

    // Entry type
    optional AccountDefEntryType type = 5 [default = MANDATORY];

    // Specifies if the value for the entry can be disclosed (in the log file or wherever else).
    optional bool isSecret = 6 [default = false];

    // Field type
    optional AccountDefEntryFieldType field_type = 7 [default = STRING];

    // Set of entities, that will be sent to the probe as account value
    optional GroupScopePropertySet group_scope_property_set = 8;

    enum AccountDefEntryType {
        OPTIONAL = 0;
        MANDATORY = 1;
    }

    // Entry type
    enum AccountDefEntryFieldType {
        STRING = 0;
        GROUP_SCOPE = 1;
    }

    // Entity type with a set of properties for group scope account definition
    message GroupScopePropertySet {
        // Entity type
        required int32 entity_type = 1;

        // Set of property names
        repeated string property_name = 2;
    }
}

// Represents probe information.
message ProbeInfo {
    // Probe identifier.
    required int64 id = 1;

    // type of the probe.
    optional string type = 2;

    // Category of the probe (ie hypervisor, storage, etc).
    optional string category = 3;

    // account definitions list for this probe.
    repeated AccountDefEntry accountDefinitions = 4;

    // List of fields, that can identify the target. All the field names, specified in the list must
    // be present in accountDefinitions. For example, if the probe is uniquely identified by field
    // named "nameOrAddress", this list should be filled with only one element - "nameOrAddress",
    // if probe is identified by "address" and "port", this list should be {"address", "port"}
    repeated string identifyingFields = 5;
}
