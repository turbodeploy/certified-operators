package com.vmturbo.action.orchestrator.execution;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.Executor;
import java.util.concurrent.RejectedExecutionException;
import java.util.stream.Collectors;

import javax.annotation.Nonnull;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Sets;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.vmturbo.action.orchestrator.action.Action;
import com.vmturbo.action.orchestrator.action.ActionEvent.AutomaticAcceptanceEvent;
import com.vmturbo.action.orchestrator.action.ActionEvent.FailureEvent;
import com.vmturbo.action.orchestrator.action.ActionEvent.QueuedEvent;
import com.vmturbo.action.orchestrator.action.ActionSchedule;
import com.vmturbo.action.orchestrator.execution.ActionTargetSelector.ActionTargetInfo;
import com.vmturbo.action.orchestrator.execution.ConditionalSubmitter.ConditionalFuture;
import com.vmturbo.action.orchestrator.state.machine.UnexpectedEventException;
import com.vmturbo.action.orchestrator.store.ActionStore;
import com.vmturbo.action.orchestrator.store.EntitiesAndSettingsSnapshotFactory;
import com.vmturbo.action.orchestrator.translation.ActionTranslator;
import com.vmturbo.action.orchestrator.workflow.store.WorkflowStore;
import com.vmturbo.auth.api.auditing.AuditLogUtils;
import com.vmturbo.common.protobuf.action.ActionDTO.ActionMode;
import com.vmturbo.common.protobuf.action.ActionDTO.ActionState;
import com.vmturbo.common.protobuf.workflow.WorkflowDTO;
import com.vmturbo.topology.processor.api.ActionExecutionListener;

/**
 * Manages initiating the execution of actions.
 */
public class AutomatedActionExecutor {

    private static final Logger logger = LogManager.getLogger();

    @VisibleForTesting
    static final String TARGET_RESOLUTION_MSG = "Action %d has no resolvable target "
        + "and cannot be executed.";

    // A set of eligible action state. Actions recommended from previous market cycle with those states
    // will be retained and added into action lists generated by new market cycle.
    private static final Set<ActionState> PREVIOUS_CYCLE_ELIGIBLE_ACTION_STATE = Sets.newHashSet(ActionState.PRE_IN_PROGRESS,
            ActionState.IN_PROGRESS, ActionState.POST_IN_PROGRESS, ActionState.QUEUED, ActionState.FAILING);

    /**
     * To execute actions (by sending them to Topology Processor).
     */
    private final ActionExecutor actionExecutor;

    /**
     * To schedule actions for asynchronous execution.
     */
    private final Executor submitter;

    /**
     * For selecting which target/probe to execute each action against.
     */
    private final ActionTargetSelector actionTargetSelector;

    private final EntitiesAndSettingsSnapshotFactory entitySettingsCache;

    /**
     * The store for all the known {@link WorkflowDTO.Workflow} items.
     */
    private final WorkflowStore workflowStore;
    private final ActionTranslator actionTranslator;
    private final ActionCombiner actionCombiner;
    private final ActionExecutionListener actionExecutionListener;

    /**
     * Creates a AutomatedActionExecutor that talks will all the provided services.
     *
     * @param actionExecutor to execute actions (by sending them to Topology Processor)
     * @param submitter to schedule actions for asynchronous execution
     * @param workflowStore to determine if any workflows should be used to execute actions
     * @param actionTargetSelector to select which target/probe to execute each action against
     * @param entitySettingsCache an entity snapshot factory used for creating entity snapshot.
     * @param actionTranslator the action translator.
     * @param actionCombiner the bean to combine related actions for a single execution.
     * @param actionExecutionListener the action execution listener
     */
    public AutomatedActionExecutor(@Nonnull final ActionExecutor actionExecutor,
            @Nonnull final Executor submitter, @Nonnull final WorkflowStore workflowStore,
            @Nonnull final ActionTargetSelector actionTargetSelector,
            @Nonnull final EntitiesAndSettingsSnapshotFactory entitySettingsCache,
            @Nonnull final ActionTranslator actionTranslator,
            @Nonnull final ActionCombiner actionCombiner,
            @Nonnull final ActionExecutionListener actionExecutionListener) {
        this.actionExecutor = Objects.requireNonNull(actionExecutor);
        this.submitter = Objects.requireNonNull(submitter);
        this.workflowStore = Objects.requireNonNull(workflowStore);
        this.actionTargetSelector = Objects.requireNonNull(actionTargetSelector);
        this.entitySettingsCache = Objects.requireNonNull(entitySettingsCache);
        this.actionTranslator = Objects.requireNonNull(actionTranslator);
        this.actionCombiner = Objects.requireNonNull(actionCombiner);
        this.actionExecutionListener = Objects.requireNonNull(actionExecutionListener);
    }

    /**
     * Finds the target associated with all entities involved in each action.
     * Does not include actions with no resolvable target
     *
     * @param allActions action objects
     * @return map of target id to the set of action ids directed at the target
     */
    private Map<Long, Set<ActionExecutionReadinessDetails>> mapActionsToTarget(
            Map<Long, ActionExecutionReadinessDetails> allActions) {
        final Map<Long, Set<ActionExecutionReadinessDetails>> result = new HashMap<>();
        final Map<Long, Long> workflowExecutionTargetsForActions =
                getWorkflowExecutionTargetsForActions(allActions.values()
                        .stream()
                        .map(ActionExecutionReadinessDetails::getAction)
                        .collect(Collectors.toList()));
        final Map<Long, ActionTargetInfo> targetIdsForActions =
                actionTargetSelector.getTargetsForActions(
                        allActions.values().stream().map(el -> el.getAction().getRecommendation()),
                        entitySettingsCache.emptySnapshot(), workflowExecutionTargetsForActions);
        for (Entry<Long, ActionTargetInfo> targetIdForActionEntry : targetIdsForActions.entrySet()) {
            final Long actionId = targetIdForActionEntry.getKey();
            final ActionTargetInfo targetInfo = targetIdForActionEntry.getValue();
            if (targetInfo.targetId().isPresent()) {
                final Long targetId = targetInfo.targetId().get();
                final Set<ActionExecutionReadinessDetails> targetActions = result.computeIfAbsent(
                        targetId, tgt -> new HashSet<>());
                targetActions.add(allActions.get(actionId));
                result.put(targetId, targetActions);
            }
        }
        return result;
    }

    private Map<Long, Long> getWorkflowExecutionTargetsForActions(
            @Nonnull Collection<Action> actions) {
        final Map<Long, Long> workflowExecutionTargetsForActions = new HashMap<>();
        for (Action action : actions) {
            final Optional<Long> workflowExecutionTarget =
                    action.getWorkflowExecutionTarget(workflowStore);
            workflowExecutionTarget.ifPresent(
                    discoveredTarget -> workflowExecutionTargetsForActions.put(action.getId(),
                            discoveredTarget));
        }
        return workflowExecutionTargetsForActions;
    }

    /**
     * Execute all actions in store that are in Automatic mode or manually
     * accepted (MANUAL mode) with activated execution schedule. Subject to
     * queueing and/or throttling.
     *
     * @param store ActionStore containing all actions
     * @return list of futures sent for execution
     */
    public List<ConditionalFuture> executeAutomatedFromStore(ActionStore store) {
        printSubmitterState();

        if (!store.allowsExecution()) {
            return Collections.emptyList();
        }
        final Map<Long, ActionExecutionReadinessDetails> autoActions = store.getActions().values().stream()
                .map(this::getActionExecutionReadinessDetails)
                .filter(ActionExecutionReadinessDetails::isReadyForExecution)
                .collect(Collectors.toMap(k -> k.getAction().getId(), v -> v));

        final Map<Long, Set<ActionExecutionReadinessDetails>> actionsByTarget = mapActionsToTarget(autoActions);

        //remove any actions for which target retrieval failed
        List<Long> toRemove = new ArrayList<>();
        Set<Long> validActions = actionsByTarget.values().stream()
                .flatMap(Set::stream)
                .map(a -> a.getAction().getId())
                .collect(Collectors.toSet());
        autoActions.entrySet().stream()
                .filter(entry -> !validActions.contains(entry.getKey()))
                .map(Entry::getValue)
                .forEach(failed -> {
                    final Action action = failed.getAction();
                    String errorMsg = String.format(TARGET_RESOLUTION_MSG, action.getId());
                    action.receive(new FailureEvent(errorMsg));
                    toRemove.add(action.getId());
                });
        toRemove.forEach(autoActions::remove);

        List<ConditionalFuture> futures = new ArrayList<>();
        final String userNameAndUuid = AuditLogUtils.getUserNameAndUuidFromGrpcSecurityContext();


        // We want to distribute actions across targets. If we have 5 targets, 10 actions each,
        // and a threadpool of size 10, we don't want to queue 10 actions for target 1.
        // It's better to queue 2 actions for targets 1-5 - so that we can minimize the impact
        // of execution on any particular probe/backend service.
        //
        // So what we do is:
        //   1) Build a map from (target id) -> (iterator over actions to execute for the target)
        //   2) Do a breadth-first traversal over the map (i.e. looping over the target ids
        //      multiple times, taking one action id every time) and queue the actions.

        // Build up a map from (target id) -> (iterator over actions to execute for the target).
        final Map<Long, Iterator<Set<ActionExecutionReadinessDetails>>> actionItsByTargetId = new HashMap<>();
        actionsByTarget.forEach((targetId, actionSet) ->
                actionItsByTargetId.put(targetId, actionCombiner.combineActions(actionSet).iterator()));

        // Breadth-first traversal over the (target id) -> (iterator over action ids) map.
        while (!actionItsByTargetId.isEmpty()) {
            final Iterator<Entry<Long, Iterator<Set<ActionExecutionReadinessDetails>>>> actionItsByTargetIdIt = actionItsByTargetId.entrySet().iterator();
            while (actionItsByTargetIdIt.hasNext()) {
                final Entry<Long, Iterator<Set<ActionExecutionReadinessDetails>>> targetToActionIt = actionItsByTargetIdIt.next();
                final Long targetId = targetToActionIt.getKey();
                final Iterator<Set<ActionExecutionReadinessDetails>> actionIt = targetToActionIt.getValue();
                if (!actionIt.hasNext()) {
                    // We're done processing all actions associated with this target.
                    // Remove the (target, iterator) entry from the outer map.
                    actionItsByTargetIdIt.remove();
                    continue;
                }

                final List<Action> actionList = new ArrayList<>();
                for (final ActionExecutionReadinessDetails actionDetails : actionIt.next()) {
                    final Long actionId = actionDetails.getAction().getId();
                    final ActionExecutionReadinessDetails actionExecutionReadinessDetails = autoActions.get(actionId);
                    final Action action = actionExecutionReadinessDetails.getAction();
                    try {
                        // In the UpdateReRecommendedActionsStage.categorizeAction, actions generated
                        // in previous market cycles will be retained. Those actions already received
                        // event to change their state(see ActionStateMachine.java), so they can by
                        // pass the logic below, as there is no need give them an AutomaticAcceptanceEvent
                        // or QueuedEvent again.
                        // TODO: OM-76246 will improve the handling for actions stuck in execution so that
                        // they dont go through executeAutomatedFromStore() repeatedly.
                        if (PREVIOUS_CYCLE_ELIGIBLE_ACTION_STATE.contains(action.getState())) {
                            continue;
                        }
                        if (actionExecutionReadinessDetails.isAutomaticallyAccepted()) {
                            action.receive(new AutomaticAcceptanceEvent(userNameAndUuid, targetId));
                        }
                        action.receive(new QueuedEvent());
                        actionList.add(action);
                    } catch (UnexpectedEventException ex) {
                        // log the error and continue with the execution of next action.
                        logger.error("Illegal state transition for action {}", action, ex);
                    }
                }

                // We don't need to refresh severity cache because we will refresh it
                // in the ActionStorehouse after calling this method.
                //
                // TODO (roman, July 30 2019): OM-49079 - Submit an asynchronous callable to
                // the threadpool, and use a different mechanism than the size of the threadpool
                // to limit concurrent actions.
                try {
                    ConditionalFuture future = new ConditionalFuture(
                            new AutomatedActionTask(targetId, actionList, workflowStore,
                                    actionTranslator, actionExecutor, actionExecutionListener));
                    submitter.execute(future);
                    futures.add(future);
                } catch (RejectedExecutionException ex) {
                    final String actionIdsString = actionList.stream()
                            .map(Action::getId)
                            .map(String::valueOf)
                            .collect(Collectors.joining(", "));
                    logger.error("Failed to submit actions {} to executor.", actionIdsString, ex);
                }
            }
        }

        logger.info("TotalExecutableActions={}, SubmittedActionsCount={}",
                autoActions.size(), futures.size());
        return futures;
    }

    private void printSubmitterState() {
        if (!(submitter instanceof ConditionalSubmitter)) {
            return;
        }

        ConditionalSubmitter conditionalSubmitter = (ConditionalSubmitter)submitter;

        int queuedFuturesCount = conditionalSubmitter.getQueuedFuturesCount();
        if (queuedFuturesCount != 0) {
            logger.warn("Submitter queue is not empty: {}", queuedFuturesCount);
        }

        int runningFuturesCount = conditionalSubmitter.getRunningFuturesCount();
        if (runningFuturesCount != 0) {
            logger.warn("Submitter has running futures: {}", runningFuturesCount);
        }
    }


    /**
     * Handle is action ready for execution or not and if it's ready than how action was accepted
     * (automatically or manually).
     *
     * @param action action
     * @return wrapper for action with information about execution readiness detail.
     */
    private ActionExecutionReadinessDetails getActionExecutionReadinessDetails(
            @Nonnull Action action) {
        boolean isReadyForExecution = false;
        boolean isAutomaticallyAccepted = false;
        final ActionMode actionMode = action.getMode();
        final Optional<ActionSchedule> scheduleOpt = action.getSchedule();
        if (actionMode == ActionMode.AUTOMATIC) {
            isReadyForExecution = true;
            isAutomaticallyAccepted = true;
        }
        if (scheduleOpt.isPresent() && (actionMode == ActionMode.MANUAL
                || actionMode == ActionMode.EXTERNAL_APPROVAL) && scheduleOpt.get()
                .isActiveSchedule() && scheduleOpt.get().getAcceptingUser() != null) {
            isReadyForExecution = true;
        }
        return new ActionExecutionReadinessDetails(action, isReadyForExecution,
                isAutomaticallyAccepted);
    }

    /**
     * Helper class contains information about action, execution readiness status and acceptor
     * mode (automatically accepted by system or manually by user).
     */
    public static class ActionExecutionReadinessDetails {

        private final Action action;
        private final boolean isReadyForExecution;
        private final boolean isAutomaticallyAccepted;

        /**
         * Constructor of {@link ActionExecutionReadinessDetails}.
         *
         * @param action the action representation
         * @param isReadyForExecution status of readiness for execution
         * @param isAutomaticallyAccepted defines action accepted automatically or manual by user
         */
        public ActionExecutionReadinessDetails(@Nonnull Action action, boolean isReadyForExecution,
                boolean isAutomaticallyAccepted) {
            this.action = Objects.requireNonNull(action);
            this.isReadyForExecution = isReadyForExecution;
            this.isAutomaticallyAccepted = isAutomaticallyAccepted;
        }

        /**
         * Return action.
         *
         * @return {@link Action}
         */
        @Nonnull
        public Action getAction() {
            return action;
        }

        /**
         * Return execution readiness status for action.
         *
         * @return true if action is ready for execution, otherwise false.
         */
        public boolean isReadyForExecution() {
            return isReadyForExecution;
        }

        /**
         * Return information about action acceptance mode.
         *
         * @return true if action accepted automatically, otherwise false (accepted manually)
         */
        public boolean isAutomaticallyAccepted() {
            return isAutomaticallyAccepted;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            final ActionExecutionReadinessDetails that = (ActionExecutionReadinessDetails)o;
            return action.getId() == that.action.getId();
        }

        @Override
        public int hashCode() {
            return Objects.hash(action.getId());
        }

        @Override
        public String toString() {
            return this.getClass().getSimpleName() + " [action=" + action + ", isReadyForExecution="
                    + isReadyForExecution + ", isAutomaticallyAccepted=" + isAutomaticallyAccepted
                    + "]";
        }
    }
}
