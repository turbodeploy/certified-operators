package com.vmturbo.action.orchestrator.stats.aggregator;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Stream;

import javax.annotation.Nonnull;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.google.common.collect.HashBasedTable;
import com.google.common.collect.Table;

import com.vmturbo.action.orchestrator.db.tables.records.ActionStatsLatestRecord;
import com.vmturbo.action.orchestrator.stats.ActionStat;
import com.vmturbo.action.orchestrator.stats.LiveActionsStatistician;
import com.vmturbo.action.orchestrator.stats.ManagementUnitType;
import com.vmturbo.action.orchestrator.stats.StatsActionViewFactory.StatsActionView;
import com.vmturbo.action.orchestrator.stats.aggregator.ActionAggregatorFactory.ActionAggregator;
import com.vmturbo.action.orchestrator.stats.groups.ActionGroup;
import com.vmturbo.action.orchestrator.stats.groups.ActionGroup.ActionGroupKey;
import com.vmturbo.action.orchestrator.stats.groups.MgmtUnitSubgroup;
import com.vmturbo.action.orchestrator.stats.groups.MgmtUnitSubgroup.MgmtUnitSubgroupKey;

/**
 * A factory class for new {@link ActionAggregator}s. Each {@link ActionAggregator} should have an
 * associacted {@link ActionAggregatorFactory}.
 *
 * @param <AGGREGATOR_TYPE> The type of {@link ActionAggregator}.
 */
public interface ActionAggregatorFactory<AGGREGATOR_TYPE extends ActionAggregator> {

    /**
     * Create a new {@link ActionAggregator} for a particular action snapshot time.
     *
     * @param snapshotTime The time of the action snapshot. All records generated by the aggregator
     *                     should have this snapshot time.
     * @return The {@link ActionAggregator} subclass.
     */
    AGGREGATOR_TYPE newAggregator(@Nonnull final LocalDateTime snapshotTime);


    /**
     * An {@link ActionAggregator} is responsible for aggregating all actions involving management
     * units of a particular {@link ManagementUnitType} in a particular snapshot.
     * <p>
     * For example, all cluster-related actions would be handled by one {@link ActionAggregator}.
     * <p>
     * The {@link ActionAggregator} lifecycle is:
     * 1. Creation
     * 2. {@link ActionAggregator#start()} to initialize
     * 3. for each action recorded by the {@link LiveActionsStatistician}:
     *     - {@link ActionAggregator#processAction(StatsActionView, Set)}
     * 4. {@link ActionAggregator#createRecords(Map, Map)} ()} to retrieve the aggregated records.
     */
    abstract class ActionAggregator {

        /**
         * Logger for the aggregator. Using getClass() so we get the extending class,
         * not {@link ActionAggregator}
         */
        protected final Logger logger = LogManager.getLogger(getClass());

        private final LocalDateTime snapshotTime;

        /**
         * The action stats aggregated for this management unit type, organized by
         * {@link MgmtUnitSubgroupKey} and {@link ActionGroupKey}.
         */
        protected final Table<MgmtUnitSubgroupKey, ActionGroupKey, ActionStat> actionStats =
                HashBasedTable.create();

        protected ActionAggregator(@Nonnull final LocalDateTime snapshotTime) {
            this.snapshotTime = snapshotTime;
        }

        /**
         * This method must be called before any calls to
         * {@link ActionAggregator#processAction(StatsActionView, Set)}.
         *
         * The aggregator can override this to get any information it needs to process actions -
         * e.g. members of the management unit.
         */
        public void start() {}

        /**
         * Process a single action, adding it to any {@link ActionStat}
         *
         * @param action The action to process.
         * @param newActionIds the IDs for all actions that are "new", i.e.
         *                     not previously recommended
         */
        public abstract void processAction(@Nonnull final StatsActionView action,
                                           @Nonnull final Set<Long> newActionIds);

        /**
         * Check if a given action is "new", i.e. not previously recommended, given a set of
         * action IDs for new actions.
         *
         * @param action the action to be checkted
         * @param newActionIds the set of IDs of new actions
         * @return true iff the action is "new", i.e. the ID is contained in the newActionIds set
         */
        protected boolean actionIsNew(@Nonnull final StatsActionView action,
                                      @Nonnull final Set<Long> newActionIds) {
            return newActionIds.contains(action.recommendation().getId());
        }

        /**
         * @return The {@link ManagementUnitType} handled by this aggregator.
         */
        @Nonnull
        protected abstract ManagementUnitType getManagementUnitType();

        /**
         * @return The {@link ActionStat} associated with a particular {@link MgmtUnitSubgroupKey} and
         * {@link ActionGroupKey}. Inserts an empty one if none exist.
         */
        @Nonnull
        protected ActionStat getStat(@Nonnull final MgmtUnitSubgroupKey unitKey,
                                     @Nonnull final ActionGroupKey groupKey) {
            ActionStat stat = actionStats.get(unitKey, groupKey);
            if (stat == null) {
                stat = new ActionStat();
                actionStats.put(unitKey, groupKey, stat);
            }
            return stat;
        }

        /**
         * This method should only be called after all calls to
         * {@link ActionAggregator#processAction(StatsActionView, Set)}.
         *
         * Return the {@link ActionStat}s this aggregator processed -
         * organized by {@link MgmtUnitSubgroupKey} and {@link ActionGroupKey} - as a stream of
         * database records.
         *
         * @return An iterator over {@link ActionStatsLatestRecord}s aggregated by this aggregator
         *         that can be inserted into the database.
         */
        @Nonnull
        public Stream<ActionStatsLatestRecord> createRecords(
                @Nonnull final Map<MgmtUnitSubgroupKey, MgmtUnitSubgroup> mgmtUnitSubgroups,
                @Nonnull final Map<ActionGroupKey, ActionGroup> actionGroups) {
            logger.info("Returning stream of {} records.", actionStats.cellSet().size());
            return actionStats.cellSet().stream()
                .map(cell -> {
                    final ActionStatsLatestRecord record = new ActionStatsLatestRecord();
                    record.setActionSnapshotTime(snapshotTime);
                    final MgmtUnitSubgroup mgmtUnitSubgroupId = mgmtUnitSubgroups.get(cell.getRowKey());
                    if (mgmtUnitSubgroupId == null) {
                        // This shouldn't happen if the user of the aggregator collects the subgroup
                        // keys and makes sure they exist.
                        logger.error("Failed to find subgroup {}.", cell.getRowKey());
                        return Optional.<ActionStatsLatestRecord>empty();
                    } else {
                        record.setMgmtUnitSubgroupId(mgmtUnitSubgroupId.id());
                    }

                    final ActionGroup actionGroup = actionGroups.get(cell.getColumnKey());
                    if (actionGroup == null) {
                        return Optional.<ActionStatsLatestRecord>empty();
                    } else {
                        record.setActionGroupId(actionGroup.id());
                    }
                    cell.getValue().addToRecord(record);
                    return Optional.of(record);
                })
                .filter(Optional::isPresent)
                .map(Optional::get);
        }

        @Nonnull
        public Set<MgmtUnitSubgroupKey> getMgmtUnitSubgroupKeys() {
            return Collections.unmodifiableSet(actionStats.rowKeySet());
        }

        @Nonnull
        public Set<ActionGroupKey> getActionGroupKeys() {
            return Collections.unmodifiableSet(actionStats.columnKeySet());
        }

        @Override
        public String toString() {
            return getClass().getSimpleName() + " (aggregating " + getManagementUnitType() + ")";
        }
    }
}
