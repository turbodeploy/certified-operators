package com.vmturbo.market.topology.conversions.action;

import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import com.vmturbo.common.protobuf.action.ActionDTO;
import com.vmturbo.common.protobuf.action.ActionDTO.Explanation.ResizeExplanation;
import com.vmturbo.common.protobuf.action.ActionDTO.Resize;
import com.vmturbo.common.protobuf.topology.ApiEntityType;
import com.vmturbo.common.protobuf.topology.TopologyDTO.CommodityAttribute;
import com.vmturbo.common.protobuf.topology.TopologyDTO.CommoditySoldDTO;
import com.vmturbo.common.protobuf.topology.TopologyDTO.CommodityType;
import com.vmturbo.common.protobuf.topology.TopologyDTO.ProjectedTopologyEntity;
import com.vmturbo.common.protobuf.topology.TopologyDTO.TopologyEntityDTO;
import com.vmturbo.common.protobuf.topology.UICommodityType;
import com.vmturbo.market.topology.conversions.CommodityConverter;
import com.vmturbo.market.topology.conversions.CommodityIndex;
import com.vmturbo.market.topology.conversions.TopologyConverter;
import com.vmturbo.platform.analysis.protobuf.ActionDTOs.ResizeTO;
import com.vmturbo.platform.analysis.protobuf.ActionDTOs.ResizeTriggerTraderTO;
import com.vmturbo.platform.analysis.protobuf.CommodityDTOs.CommoditySoldTO;
import com.vmturbo.platform.analysis.protobuf.CommodityDTOs.CommoditySpecificationTO;
import com.vmturbo.platform.analysis.protobuf.EconomyDTOs.TraderTO;
import com.vmturbo.platform.common.dto.CommonDTO.EntityDTO.EntityType;

/**
 * Responsible for turning a {@link ResizeTO} generated by the market into a {@link Resize} and
 * {@link ResizeExplanation} expected by the rest of the XL platform.
 */
public class ResizeInterpreter extends ActionInterpretationAdapter<ResizeTO, Resize, ResizeExplanation> {

    private final Map<Long, TopologyEntityDTO> originalTopology;

    /**
     * Create a new interpreter in the context of a specific topology.
     *
     * @param commodityConverter The {@link CommodityConverter}.
     * @param commodityIndex THe {@link CommodityIndex}.
     * @param oidToProjectedTraderTOMap The {@link TraderTO}s arranged by oid.
     * @param originalTopology The {@link TopologyEntityDTO}s in the original topology[
     */
    public ResizeInterpreter(@Nonnull final CommodityConverter commodityConverter,
            @Nonnull final CommodityIndex commodityIndex,
            @Nonnull final Map<Long, TraderTO> oidToProjectedTraderTOMap,
            @Nonnull final Map<Long, TopologyEntityDTO> originalTopology) {
        super(commodityConverter, commodityIndex, oidToProjectedTraderTOMap);
        this.originalTopology = originalTopology;
    }

    @Nonnull
    @Override
    public Optional<Resize> interpret(@Nonnull final ResizeTO resizeTO,
            @Nonnull final Map<Long, ProjectedTopologyEntity> projectedTopology) {
        final long entityId = resizeTO.getSellingTrader();
        final CommoditySpecificationTO cs = resizeTO.getSpecification();
        final CommodityType topologyCommodityType =
                commodityConverter.marketToTopologyCommodity(cs)
                        .orElseThrow(() -> new IllegalArgumentException(
                                "Resize commodity can't be converted to topology commodity format! "
                                        + cs));
        // Determine if this is a remove limit or a regular resize.
        final TopologyEntityDTO projectedEntity = projectedTopology.get(entityId).getEntity();

        // Find the CommoditySoldDTO for the resize commodity.
        final Optional<CommoditySoldDTO> resizeCommSold =
                projectedEntity.getCommoditySoldListList().stream()
                        .filter(commSold -> commSold.getCommodityType().equals(topologyCommodityType))
                        .findFirst();
        final Optional<CommoditySoldDTO> originalCommoditySold =
                commodityIndex.getCommSold(projectedEntity.getOid(), topologyCommodityType);
        double oldCapacity = TopologyConverter.reverseScaleComm(resizeTO.getOldCapacity(), originalCommoditySold, CommoditySoldDTO::getScalingFactor);
        double newCapacity = TopologyConverter.reverseScaleComm(resizeTO.getNewCapacity(), originalCommoditySold, CommoditySoldDTO::getScalingFactor);

        if (topologyCommodityType.getType() == UICommodityType.VCPU.typeNumber()) {
            final TopologyEntityDTO originalEntity = originalTopology.get(entityId);
            double cpuSpeedMhz = 0.0;
            if (originalEntity != null && projectedEntity.getEntityType() == EntityType.VIRTUAL_MACHINE.getNumber()) {
                // We don't have to find the sold commodities on the original entities, because it
                // should be identical to the "old" capacity.
                final int numCores = Math.max(originalEntity.getTypeSpecificInfo().getVirtualMachine().getNumCpus(), 1);
                cpuSpeedMhz = oldCapacity / numCores;
            } else if (originalEntity != null && originalEntity.getEntityType() == EntityType.CONTAINER_VALUE) {
                // TODO: Remove this when switching container vCPU to millicores end-to-end.
                TopologyEntityDTO vm = getVmFromContainer(originalEntity);
                // Containers are in millicores, which is number of cores / 1000.
                cpuSpeedMhz = getVmCpuSpeedMhz(vm) / 1000;
            }

            // Resizing VM CPU
            if (cpuSpeedMhz == 0.0) {
                // If we can't get the CPU speed we can't interpret the resize, so discard it.
                return Optional.empty();
            }
            oldCapacity = Math.round(oldCapacity / cpuSpeedMhz);
            newCapacity = Math.ceil(newCapacity / cpuSpeedMhz);
            // double comparison normally applies epsilon, but in this case both capacities are
            // result of Math.round and Math.ceil so the values are actually integers.
            if (Double.compare(oldCapacity, newCapacity) == 0) {
                // If the from and to end up being the same number of CPUs, this action is not
                // really meaningful.
                return Optional.empty();
            }
        }

        final Resize removeLimit = interpretRemoveLimit(projectedEntity, resizeTO, topologyCommodityType, resizeCommSold);
        if (removeLimit != null) {
            return Optional.of(removeLimit);
        }

        if (!validResizeTrigger(oldCapacity, newCapacity, resizeTO)) {
            return Optional.empty();
        }

        final ActionDTO.Resize.Builder resizeBuilder = ActionDTO.Resize.newBuilder()
                .setTarget(createActionEntity(entityId, projectedEntity.getEntityType(), projectedEntity.getEnvironmentType()))
                .setNewCapacity((float)newCapacity)
                .setOldCapacity((float)oldCapacity)
                .setCommodityType(topologyCommodityType);
        if (resizeTO.hasReasonCommodity()) {
            final CommodityType reasonCommodityType =
                    commodityConverter.marketToTopologyCommodity(resizeTO.getReasonCommodity())
                            .orElseThrow(() -> new IllegalArgumentException(
                                    "Resize commodity can't be converted to topology commodity format! "
                                            + cs));
            resizeBuilder.setReason(reasonCommodityType);

        }
        setHotAddRemove(resizeBuilder, resizeCommSold);
        if (resizeTO.hasScalingGroupId()) {
            resizeBuilder.setScalingGroupId(resizeTO.getScalingGroupId());
        }
        return Optional.of(resizeBuilder.build());
    }

    @Nullable
    private Resize interpretRemoveLimit(@Nonnull final TopologyEntityDTO projectedEntity,
            @Nonnull final ResizeTO resize,
            @Nonnull final CommodityType topologyCommodityType,
            final Optional<CommoditySoldDTO> resizeCommSold) {
        // If this is a VM and has a restricted capacity, we are going to assume it's a limit
        // removal. This logic seems like it could be fragile, in that limit may not be the
        // only way VM capacity could be restricted in the future, but this is consistent
        // with how classic makes the same decision.
        if (projectedEntity.getEntityType() == EntityType.VIRTUAL_MACHINE.getNumber()) {
            TraderTO traderTO = oidToProjectedTraderTOMap.get(projectedEntity.getOid());
            // find the commodity on the trader and see if there is a limit?
            for (CommoditySoldTO commoditySold : traderTO.getCommoditiesSoldList()) {
                if (commoditySold.getSpecification().equals(resize.getSpecification())) {
                    // We found the commodity sold.  If it has a utilization upper bound < 1.0,
                    // then the commodity is restricted, and according to our VM-rule, we will
                    // treat this as a limit removal.
                    float utilizationPercentage = commoditySold.getSettings().getUtilizationUpperBound();
                    if (utilizationPercentage < 1.0) {
                        // The "limit removal" is actually a resize on the commodity's "limit"
                        // attribute that effectively sets it to zero.
                        //
                        // Ideally we would set the "old capacity" to the current limit
                        // value, but as noted above, we don't have access to the limit here. We
                        // only have the utilization percentage, which we expect to be based on
                        // the limit and raw capacity values. Since we do have the utilization %
                        // and raw capacity here, we can _approximate_ the current limit by
                        // reversing the math used to determine the utilization %.
                        //
                        // We will grudgingly do that here. Note that this may be subject to
                        // precision and rounding errors. In addition, if in the future we have
                        // factors other than "limit" that could drivef the VM resource
                        // utilization threshold to below 100%, then this approximation would
                        // likely be wrong and misleading in those cases.
                        float approximateLimit = commoditySold.getCapacity() * utilizationPercentage;
                        logger.debug("The commodity {} has util% of {}, so treating as limit"
                                        + " removal (approximate limit: {}).",
                                topologyCommodityType.getKey(), utilizationPercentage, approximateLimit);

                        ActionDTO.Resize.Builder resizeBuilder = ActionDTO.Resize.newBuilder()
                                .setTarget(createActionEntity(projectedEntity.getOid(),
                                        projectedEntity.getEntityType(), projectedEntity.getEnvironmentType()))
                                .setOldCapacity(approximateLimit)
                                .setNewCapacity(0)
                                .setCommodityType(topologyCommodityType)
                                .setCommodityAttribute(CommodityAttribute.LIMIT);
                        setHotAddRemove(resizeBuilder, resizeCommSold);
                        return resizeBuilder.build();
                    }
                    break;
                }
            }
        }
        return null;
    }

    private boolean validResizeTrigger(final double oldCapacity, final double newCapacity, @Nonnull final ResizeTO resizeTO) {
        if (!resizeTO.getResizeTriggerTraderList().isEmpty()) {
            // Scale Up: Show relevant vSan resizes when hosts are provisioned due to
            // the commodity type being scaled.
            if (newCapacity > oldCapacity) {
                Optional<ResizeTriggerTraderTO> resizeTriggerTraderTO = resizeTO.getResizeTriggerTraderList().stream()
                        .filter(resizeTriggerTrader -> resizeTriggerTrader.getRelatedCommoditiesList()
                                .contains(resizeTO.getSpecification().getBaseType())).findFirst();
                return resizeTriggerTraderTO.isPresent();
                // Scale Down: Pick related vSan host being suspended that has no reason commodities
                // since it is suspension due to low roi.
            } else if (newCapacity < oldCapacity) {
                Optional<ResizeTriggerTraderTO> resizeTriggerTraderTO = resizeTO.getResizeTriggerTraderList().stream()
                        .filter(resizeTriggerTrader -> resizeTriggerTrader.getRelatedCommoditiesList()
                                .isEmpty()).findFirst();
                return resizeTriggerTraderTO.isPresent();
            }
        }
        return true;
    }

    @Nonnull
    @Override
    public ResizeExplanation interpretExplanation(@Nonnull final ResizeTO resizeTO) {
        ResizeExplanation.Builder builder = ResizeExplanation.newBuilder()
                .setDeprecatedStartUtilization(resizeTO.getStartUtilization())
                .setDeprecatedEndUtilization(resizeTO.getEndUtilization());
        if (resizeTO.hasScalingGroupId()) {
            builder.setScalingGroupId(resizeTO.getScalingGroupId());
        }
        return builder.build();
    }

    /**
     * Set the hot add / hot remove flag on the resize action. This is needed for the resize
     * action execution of probes like VMM.
     *
     * @param resizeBuilder Resize builder
     * @param commoditySold Commodity sold.
     */
    private void setHotAddRemove(@Nonnull ActionDTO.Resize.Builder resizeBuilder,
            @Nonnull Optional<CommoditySoldDTO> commoditySold) {
        commoditySold.filter(CommoditySoldDTO::hasHotResizeInfo)
            .map(CommoditySoldDTO::getHotResizeInfo)
            .ifPresent(hotResizeInfo -> {
                if (hotResizeInfo.hasHotAddSupported()) {
                    resizeBuilder.setHotAddSupported(hotResizeInfo.getHotAddSupported());
                }
                if (hotResizeInfo.hasHotRemoveSupported()) {
                    resizeBuilder.setHotRemoveSupported(hotResizeInfo.getHotRemoveSupported());
                }
            });
    }

    @Nullable
    private TopologyEntityDTO getVmFromContainer(final TopologyEntityDTO container) {
        return container.getCommoditiesBoughtFromProvidersList().stream()
            .filter(c -> c.getProviderEntityType() == ApiEntityType.CONTAINER_POD.typeNumber())
            .map(boughtFromPod -> originalTopology.get(boughtFromPod.getProviderId()))
            .filter(Objects::nonNull)
            .flatMap(containerPod -> containerPod.getCommoditiesBoughtFromProvidersList().stream())
            .filter(c -> c.getProviderEntityType() == ApiEntityType.VIRTUAL_MACHINE.typeNumber())
            .map(boughtFromVm -> originalTopology.get(boughtFromVm.getProviderId()))
            .filter(Objects::nonNull)
            .findFirst()
            .orElse(null);
    }

    private double getVmCpuSpeedMhz(@Nullable final TopologyEntityDTO vm) {
        if (vm == null) {
            return 0.0;
        }

        return vm.getCommoditySoldListList().stream()
            .filter(commoditySoldDTO -> commoditySoldDTO.getCommodityType().getType() == UICommodityType.VCPU .typeNumber())
            .findFirst()
            .map(vcpuSold -> {
                // The total vCPU capacity in MhZ / num vCPUS = MhZ per vCPU.
                final double capacityMhz = vcpuSold.getCapacity();
                final int numCores = Math.max(vm.getTypeSpecificInfo().getVirtualMachine().getNumCpus(), 1);
                return capacityMhz / numCores;
            }).orElse(0.0);
    }
}
