#!/bin/bash

# Generate the keystore
# The ${KEYPASS} is used to protect the private keys in the JKS keystore.
# It is also being used to convert the keystore generated by openssl from PKCS#12 to JKS format.
KEYPASS="jumpy-crazy-experience"
if [[ ! -f "/home/turbonomic/data/keystore.p12" ]]; then
  keytool -genkey -alias vmt -storetype PKCS12 -sigalg SHA256withRSA -keyalg RSA \
  -keysize 2048 -keystore /home/turbonomic/data/keystore.p12 -validity 3650 -storepass ${KEYPASS} \
  -keypass ${KEYPASS} -noprompt -dname "CN=turbonomic.com,OU=RND,O=TRB,L=NYC,S=NY,C=US"
  # Allow for development environment, where noone creates the openssl keys.
  if [[ -f "/tmp/certs/key.pkcs12" ]]; then
    keytool -delete -alias vmt -keystore /home/turbonomic/data/keystore.p12 -storepass ${KEYPASS} -keypass ${KEYPASS}
    keytool -v -importkeystore -srckeystore /tmp/certs/key.pkcs12 -srcstoretype PKCS12 \
    -destkeystore /home/turbonomic/data/keystore.p12 -deststoretype JKS -alias 1 -destalias vmt -srcstorepass ${KEYPASS} -srckeypass ${KEYPASS} \
    -deststorepass ${KEYPASS} -destkeypass ${KEYPASS}
  fi
fi

GC_LOG_DIR="/home/turbonomic/data/gclog"
# this is a new entrypoint.sh
# The Djava.security.egd=file:/dev/./urandom configuration significantly speeds up start-up time
# for the components using the SecureRandom class (see
# http://stackoverflow.com/questions/25660899/spring-boot-actuator-application-wont-start-on-ubuntu-vps)
COMMON_JAVA_OPTS="-XX:+UseG1GC -XX:CompileThreshold=1500 -XX:OnOutOfMemoryError=\"/dump_histogram.sh\" -XX:+ExitOnOutOfMemoryError"
COMMON_JAVA_OPTS="-verbose:gc -XX:+PrintGCDateStamps -Xloggc:${GC_LOG_DIR}/gc.log $COMMON_JAVA_OPTS"
COMMON_JAVA_OPTS="-XX:SoftRefLRUPolicyMSPerMB=0 -XX:+PrintConcurrentLocks -XX:+PrintClassHistogram $COMMON_JAVA_OPTS"
COMMON_JAVA_OPTS="-XX:+PrintCommandLineFlags -XX:+UseStringDeduplication -XX:StringDeduplicationAgeThreshold=1 $COMMON_JAVA_OPTS"
COMMON_JAVA_OPTS="-Djava.security.egd=file:/dev/./urandom -Djava.net.preferIPv4Stack=true -XX:-OmitStackTraceInFastThrow $COMMON_JAVA_OPTS"
COMMON_JAVA_OPTS="-Dnetworkaddress.cache.ttl=0 -Dnetworkaddress.cache.negative.ttl=0 $COMMON_JAVA_OPTS"
COMMON_JAVA_OPTS="-DLog4jContextSelector=${LOG4J_CONTEXT_SELECTOR:-org.apache.logging.log4j.core.async.AsyncLoggerContextSelector} $COMMON_JAVA_OPTS"
export STARTUP_COMMAND="java $COMMON_JAVA_OPTS $JAVA_OPTS $MORE_JAVA_OPTS -jar $@"
mkdir -p "${GC_LOG_DIR}"

# Roll the logs as needed

# Rotate the log before we start.
# That way, the startup sequence will only work with the current logs and
# will see the startup messages that are current.
LOG_FILE="${GC_LOG_DIR}/gc.log"
if [ -f "${LOG_FILE}" ]; then
    LOG_FILE_ARCH=${LOG_FILE}_$(date +"%Y%m%d_%H%M%S")
    mv ${LOG_FILE} ${LOG_FILE_ARCH}
    # We can afford to compress the archive in background
    # in order to speed up the startup.
    /usr/bin/nohup xz ${LOG_FILE_ARCH} >/dev/null &
fi

# If LOG_TO_STDOUT is defined in the environment, tee the output so that it is also logged to stdout.
# This is generally desirable in a development setup where you want to see the output on the console when
# starting a component, but not in production where we do not want logging to be captured by Docker
# and consume disk space (Docker JSON log driver captures and saves them then docker logs shows them).
# In a production environment, get the logs from the rsyslog component instead.
if [[ -z ${LOG_TO_STDOUT} ]]; then
  export LOGGER_COMMAND="logger --tag ${instance_id:-vmt_component} -u /tmp/log.sock"
else
  export LOGGER_COMMAND="eval tee >(logger --tag ${instance_id:-vmt_component} -u /tmp/log.sock)"
fi

# Start up the http server
/usr/bin/nohup /diags.py >/tmp/diags.log &

# GC logs rotate
/usr/bin/nohup /logrotate.sh >/tmp/logrotate.log 2>&1 &

# rsyslog
/usr/sbin/rsyslogd -f /etc/rsyslog.conf -i /tmp/rsyslog.pid

echo "Executing startup command: \"$STARTUP_COMMAND\"" 2>&1 | ${LOGGER_COMMAND}
exec $STARTUP_COMMAND > >($LOGGER_COMMAND) 2>&1
