#!/bin/bash

# if there isn't at least 16 gb of memory, log a warning and don't start any more components
MIN_VMEM=16

# http port to use for SSL connections
SSL_PORT=443

# Source and destination base for the install process
SOURCE_BASE="/media/cdrom"
DEST_BASE="/etc/docker"

# docker-compose.yml file path; also base path for docker-compose.yml.nnk files
DOCKER_COMPOSE_DEST_BASE=${DEST_BASE}/docker-compose.yml

export HOST_IP=$(/sbin/ip route get 1 | awk '{print $NF;exit}')

# list of "component" images to start (not including support containers). "api" should be last on this list
#    so that other components will all be running before the user-facing UI comes up
XL_COMPONENTS="auth topology-processor market repository plan-orchestrator action-orchestrator group \
        history cost mediation-hyperv mediation-vcenter mediation-netapp mediation-ucs mediation-udt \
        mediation-vmax mediation-vmm mediation-hpe3par mediation-pure mediation-oneview api"
# list of "support" containers to start
BASE_IMAGES="nginx rsyslog consul clustermgr db arangodb"
# how many docker images to start, XL components and nginx
# the dependent base images are started automatically due to the dependencies.
N_IMAGES=$(($(echo ${XL_COMPONENTS} | wc -w) + 1))

# log a message; also write it to the one-line file read by the status monitor webpage
function log_message() {
    line_no=${BASH_LINENO[*]}
    echo $(date +"%Y-%m-%d %T") ${line_no} $@
    echo $@ > /tmp/status/load_status
}

function get_component_ip_address() {
    local component_name="$1"
    local ipaddress=`docker inspect docker_"${component_name}"_1 | grep '"IPAddress": "[0-9]+*' | awk '{print $NF}' | tr -d '",'`
    echo $ipaddress
}

# Start the XL component and verify that it has started up successfully
function start_and_verify_xl_component() {
    component="$1"
    start_xl_component ${component}
    # Now wait until it's started correctly
    echo "Waiting for $component to be READY"
    # For XL native components, we query the /state REST endpoint
    ipaddress=$(get_component_ip_address $component)
    while true
    do
        state=`curl -sS --stderr /tmp/vmtctl_stderr.out http://$ipaddress:8080/state | tr -d '"'`
        if [ "$state" == "RUNNING" ]; then
            return
        fi
        sleep 5
    done
}

# Start an XL component without waiting for the startup to complete;
#     will stop & recreate the container if image has changed
function start_xl_component() {
    component="$1"
    log_message "Starting $component component ($n_started of $N_IMAGES)"
    n_started=$(($n_started+1))
    /usr/local/bin/docker-compose -f /etc/docker/docker-compose.yml up -d --no-color "${component}"
}

# Stop an XL component
function stop_xl_component() {
    component="$1"
    log_message "Stopping ${component} component"
    /usr/local/bin/docker-compose -f /etc/docker/docker-compose.yml stop "${component}"
}

# Copy a file from source to dest, if found, making a copy of the old file
function copy_cdrom_source() {
    filename=$1
    if [ -f ${SOURCE_BASE}/${filename} ]; then
      mv ${DEST_BASE}/${filename} ${DEST_BASE}/${filename}$(date +"%Y_%M_%d") >/dev/null 2>&1
      cp ${SOURCE_BASE}/${filename} ${DEST_BASE}/${filename}
    fi
}

# If the current vmem is between the lower & upper bounds then add a symlink & return 0; else return 1
function set_max_load() {
    vmem=$1
    suffix=$2
    lower=$3
    upper=$4
    if [ ${vmem} -ge ${lower} ]; then
        if [ .${upper} == . ] ||  [ ${vmem} -lt ${upper} ]; then
           ln -sf ${DOCKER_COMPOSE_DEST_BASE}.${suffix}k ${DOCKER_COMPOSE_DEST_BASE}
           log_message "Maximum load of ${suffix}K entities is set up with ${vmem}GB"
           # pause so this message may be seen on the progress monitor webpage
           sleep 10
           return 0
        fi
    fi
    return 1
}

# Master start script.
# Starts Consul, followed by the Cluster manager, followed by everything else
function start_xl() {

    # Verify that we did identify a docker-compose file to link to
    if [ ! -f "${DOCKER_COMPOSE_DEST_BASE}" ]; then
       log_message "!! No component configuration available"
       return
    fi

    # Sanity-check that the correct number of docker images are available
    NUM=$(docker images | grep latest | wc -l)
    if [ ${NUM} -lt ${N_IMAGES} ]; then
       log_message "!! No component images are available"
       return
    fi

    # Chose the yml file based on the size
    vmem=$(cat /proc/meminfo | grep MemTotal | awk '{total=$2/1024/1024} {if(total-int(total)>0) {total=int(total)+1}}{print total}')

    # if there isn't sufficient memory, log a warning and don't start any more components
    if [ ${vmem} -lt ${MIN_VMEM} ]; then
       log_message "!! Insufficient memory available with ${vmem}GB"
       return
    fi

    # 15K config applies to memory sizes under 24 mb
    set_max_load ${vmem} 15 1 24
    if [ $? -eq 1 ]; then
        # 25K
        set_max_load ${vmem} 25 24 32
    fi
    if [ $? -eq 1 ]; then
        # 50K
        set_max_load ${vmem} 50 32 48
    fi
    if [ $? -eq 1 ]; then
        # 100K
        set_max_load ${vmem} 100 48 63
    fi
    if [ $? -eq 1 ]; then
        # 200K - no upper limit
        set_max_load ${vmem} 200 63
    fi

    # Progress feedback for starting components; how many started so far
    n_started=1

    # start nginx; if was already running (and container hasn't changed) will not stop previous image
    log_message "Starting web server"
    start_xl_component nginx

    # Start the remaining XL components. It is assumed that "api" is last on the list so that
    # API component starts last. Thus when we connect, all other components are already running.
    log_message "Starting XL components"

    # start all components; the API component should be last so other components are all "ready"
    #    when the UI comes up
    for component in ${XL_COMPONENTS}; do
        start_and_verify_xl_component ${component}
    done

    log_message "System was successfully started."

    # wait a bit, then set one last status
    sleep 30
    log_message "Turbonomic is running."
}

if [[ "$1" == "init" ]]; then
  # Configure the admin user, if this wasn't already done
  if [[ -d /root/initial_setup ]]; then
    log_message "Setting up master admin"
    pushd /root/initial_setup >/dev/null
    chmod +x setup
    /usr/bin/nohup ./setup >/tmp/setup_nohup.txt &
    popd >/dev/null
    while true
    do
        # Part of establishing the admin account involves removing the neteditor account.
        /usr/bin/getent passwd neteditor >/dev/null 2>&1
        if [ $? -ne 0 ]; then
            break
        fi
        echo "The initial admin account is being created"
        sleep 30
    done
    log_message "Master admin has been set up"
    # Make sure the initial_setup scripts are terminated and deleted.
    # Sleep for 10 seonds to allow the initial setup GUI to pick up the status.
    # The initial setupGUI checks every 5 seconds.
    sleep 10
    # Kill the https
    # The initial setup python script is stateless, so this won't break anything.
    curl -k "https://${HOST_IP}:${SSL_PORT}/exit" >/dev/null 2>&1
    kill -9 $(ps -e -o pid,cmd | grep [p]ython | grep httpd | awk '{print $1}') >/dev/null 2>&1
    rm -rf /root/initial_setup
  fi

  log_message "Starting nginx"
  n_started=1
  start_xl_component nginx

  # Start the product
  start_xl
elif [[ "$1" == "info" ]]; then
  echo "Turbonomic distribution"
  echo "-----------------------"
  cat ${DEST_BASE}/turbonomic_info.txt
  echo ""
  echo "Images distributed"
  echo "------------------"
  cat ${DEST_BASE}/turbonomic_sums.txt
elif [[ "$1" == "stats" ]]; then
  if [[ $UID == 0 ]]; then
    exec docker stats $(docker ps --format '{{.Names}}')
  else
    exec docker stats $(sudo docker ps --format '{{.Names}}')
  fi
elif [[ "$1" == "shell" ]]; then
  exec docker exec -it "${@:2}" /bin/bash
elif [[ "$1" == "logs" ]]; then
  exec /usr/local/bin/docker-compose -f ${DEST_BASE}/docker-compose.yml logs -f "${@:2}"
elif [[ "$1" == "up" ]]; then
  # discard the command "up"
  shift
  if [[ $# -gt 0 ]]; then
    exec /usr/local/bin/docker-compose -f ${DEST_BASE}/docker-compose.yml up -d --no-color "$@"
  else
    start_xl
  fi
elif [[ "$1" == "stop" ]]; then
  if [[ $# -gt 1 ]]; then
    exec /usr/local/bin/docker-compose -f ${DEST_BASE}/docker-compose.yml stop "${@:2}"
  else
    echo "Usage: vmtctl stop <container>"
  fi
else
  echo "Usage: vmtctl <command> [arguments]"
  echo ""
  echo "  info  - Print Turbonomic XL install information"
  echo "  stats - Displays container information in a /bin/top style"
  echo "  shell <component> - Connects to a running connector"
  echo "                      and runs the /bin/bash on that container"
  echo "  logs <component>  - Displays logs for a running container, "
  echo "                      in a tail -f style"
  echo "  up <component>   - Starts an individual component"
  echo "  stop <component> - Stops an individual component"
fi
