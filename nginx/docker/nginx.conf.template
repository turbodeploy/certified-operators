# include any additional config files for the main http block
include /etc/nginx/userconf/*.conf;

# keep process alive so docker container doesn't exit
daemon off;

worker_processes $WORKER_PROCESSES;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections $WORKER_CONNECTIONS;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '[$time_local] $remote_addr - $remote_user "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    log_format upstream_ws '[$time_local] $remote_addr - $remote_user - $server_name to: $upstream_addr: $request upstream_response_time $upstream_response_time msec $msec request_time $request_time';

    access_log  /var/log/nginx/access.log  main;

    # START: NGINX HARDENING
    # Hide Nginx version
    server_tokens off;

    # Prevent VERB tampering, and only allow supported VERBS GET,
    # POST, OPTIONS, PUT, DELETE and HEAD.
    # Removed TRACE AND DEBUG
    map $request_method $bad_method {
        default 1;
        ~(?i)(GET|POST|OPTIONS|PUT|DELETE|HEAD) 0;
    }

    # Hardening of timeouts to mitigate DoS attacks
    reset_timedout_connection on;
    keepalive_requests  100;
    client_header_timeout 10s;
    client_body_timeout 10s;
    send_timeout        10s;
    lingering_timeout   5s;
    # END: NGINX HARDENING


    # turn off proxy buffering due to read-only fs
    proxy_buffering off;

    proxy_temp_path /tmp/proxy 1 2;
    fastcgi_temp_path /tmp/fastcgi 1 2;
    uwsgi_temp_path /tmp/uwsgi 1 2;
    scgi_temp_path /tmp/scgi 1 2;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  300; # may need to increase for idle websockets

    # These two should be the same or nginx will start writing
    #  large request bodies to temp files
    client_body_temp_path /tmp/client_body 1 2;
    client_body_buffer_size 10m;
    client_max_body_size    10m;


    ## gzip settings
    # enable gzip
    gzip on;
    # tells proxies to cache both gzipped and regular versions of a resource
    gzip_vary on;
    #  do not compress anything smaller than this size
    gzip_min_length 1024;
    # compress data even for clients that are connecting via proxies
    gzip_proxied any;
    #  disable compression for Internet Explorer versions 4-6
    gzip_disable "msie6";
    # gzip also 1.0 requests. this is because nginx is proxying requests on http 1.0 by default (and otherwise they will not be gzipped)
    gzip_http_version 1.0;
    # compression level, from 1 to 9
    gzip_comp_level 5;
    # enable gzip responses for specific MIME types
    gzip_types text/plain text/css application/json text/javascript application/x-javascript application/javascript text/xml application/xml application/xml+rss font/truetype font/opentype application/vnd.ms-fontobject image/svg+xml;


    # for passing the _crsf header for spring security
    underscores_in_headers on;

    # force nginx to re-resolve dns entries every 5 seconds, otherwise it will cache old entries
    # and fail to detect or recover from upstream server outages. To do this, we need to explicitly
    # set the resolver to the docker name resolver and set the valid time appropriately.
    resolver $DNS_RESOLVER valid=5s ipv6=off;

    # for websocket upgrades
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    # set up for security-related response headers that we always supply if they're not
    # present from upstream processing
    include /etc/nginx/includes/security-headers-setup.conf;

    server {
        listen 8000;

        set $disable_https_redirect "$DISABLE_HTTPS_REDIRECT";

        if ($disable_https_redirect != "true") {
            rewrite ^(/.*)$ /https-redirect$1;
            rewrite ^/https-redirect/healthz/ready$ /healthz/ready last;
        }

        location /https-redirect/ {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;
            rewrite ^/https-redirect(/.*) https://$host$1 permanent;
        }

        include /tmp/nginx/includes/normal-processing.conf;

        # include any additional server config files for the insecure port
        include /etc/nginx/userconf/insecure/*.conf;
    }

    server {
        listen 8443 ssl http2;
        ssl on;
        ssl_certificate /etc/nginx/certs/tls.crt;
        ssl_certificate_key /etc/nginx/certs/tls.key;
        ssl_protocols "$SSL_PROTOCOLS";
        ssl_ciphers "$SSL_CIPHERS";

        include /etc/nginx/includes/security-headers.conf;

        include /tmp/nginx/includes/normal-processing.conf;
    }

    # include any additional config files for the main http block
    include /etc/nginx/userconf/http/*.conf;
}

