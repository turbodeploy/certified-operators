        #### Following rules are intended to support the following URLS:
        #### * API methods:
        ####     /api/v3/<method>  (PREFERRED)
        ####     /api/<method>
        #### * Swagger-UI:
        ####     /apidoc/v3/index.html, /apidoc/v3/, /apidoc/v3  (PREFERRED)
        ####     /apidoc/index.html, /apidoc/, /apidoc
        ####     /swagger/external/index.html, /swagger/external/, /swagger/external
        ####     /swagger/index.html, /swagger/, /swagger
        #### * Swagger File as JSON (replace ".json" with ".yaml" to get YAML version)
        ####     /apidoc/v3/swagger.json  (PREFERRED)
        ####     /apidoc/swagger.json, /swagger/external/swagger.json, /swagger/swagger.json
        ####
        #### Note: the preferred paths lay a foundation for an evolving, versioned API, with
        #### the ability to support multiple versions simultaneously. Non-preferred paths
        #### may be dropped without notice and should not be communicated to customers.
        ####
        #### Internal API component paths to which the above should be mapped:
        #### * Swagge-UI URLs: /swagger/external/{index.html, swagger.json, swagger.yaml}
        #### * API URLs: /api/v3/<method> or /api/<method> (no rewrites required)

        # swagger-ui paths without trailing slash do 302 redirect to add the slash
        rewrite ^/(apidoc(/v3)?)$ $scheme://$host/$1/ redirect;
        rewrite ^/(swagger(/external)?)$ $scheme://$host/$1/ redirect;

        # swagger-ui paths without index.html get it added on (internal, no redirect)
        rewrite ^(/apidoc(/v3)?)/$ $1/index.html;
        rewrite ^(/swagger(/external)?)/$ $1/index.html;

        # all swagger-ui paths (including requests for swagger.json or swagger.yaml)
        # are routed to /swagger/external
        rewrite ^/apidoc(/v3)?(.+)$ /swagger/external$2;
        rewrite ^/swagger(/external)?(.+)$ /swagger/external$2;

        # proxying API paths
        location ~ ^/(api|vmturbo/rest|vmturbo/saml2|vmturbo/oauth2) {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            # $api_servers must be declared before api-proxy.conf
            set $api_servers $API;
            include /etc/nginx/includes/api-proxy.conf;
        }

        # proxying UI paths
        location ~ ^(/$|/app|/assets|/doc) {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            # $ui_servers must be declared before ui-proxy.conf
            set $ui_servers $UI;
            include /etc/nginx/includes/ui-proxy.conf;
        }

        # UI Proxy Failover in case the UI Pod has not been deployed b/c of old tc8-operator
        # This is temporary until the latest version of tc8-operator has been fully adopted in the wild
        # Note: This failover LACKS proper cache response headers for UI assets.  To resolving browser
        # caching issues, we need to deploy the ui component.
        location @ui_upstream_failover {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            # $api_servers must be declared before api-proxy.conf
            set $api_servers $API;
            include /etc/nginx/includes/api-proxy.conf;
            include /etc/nginx/includes/content-security-policy.conf;
        }

        # Internal route to check that the current session is authenticated.
        # See: https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-subrequest-authentication/
        location /iam/auth {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            internal;
            set $api_servers $API;
            proxy_pass              http://$api_servers:8080/api/v3/users/me/checkpermissions?feature=custom_reports;
            proxy_pass_request_body off;
            proxy_set_header        Content-Length "";
            proxy_set_header        X-Original-URI $request_uri;
        }

        # Named location for use for unauthorized access to the /reports endpoint.
        location @unauthenticatedReport {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            # We return a redirect to the login screen, with a continuation back to the
            # /reports sub-route that triggered the redirect. That way the user gets taken to the
            # desired URL after they log in.
            return 307 https://$host/app/index.html#/authentication/login?continue=/reports$uri;
        }

        location @unauthorizedReport {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            # We return a redirect to a 403 error page.
            return 403;
        }

        # Proxying the report-related route, and redirecting to Grafana.
        location /reports {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            set $grafana_servers $GRAFANA;

            # If grafana's URL is not provider, return a 404. This should never happen in a
            # real deployment.
            #
            # The "unset" string is specified in entrypoint.sh string as the value when no grafana
            # environment variable is present.
            if ($grafana_servers = unset) {
                return 404;
            }

            # Verify that the user is authenticated.
            auth_request /iam/auth;
            # Extract the reporting (grafana) username and display name from the authentication
            # request.
            auth_request_set $webauth_user $upstream_http_x_report_user_name;
            auth_request_set $webauth_name $upstream_http_x_report_user_display_name;

            # If the request is not authorized, (e.g. if a user goes to the /reports
            # endpoint directly) re-route to the main app login screen.
            error_page 401 @unauthenticatedReport;

            # If the user is scoped, (e.g. if a user goes to the /reports
            # endpoint directly) re-route to a 403 error page.
            error_page 403 @unauthorizedReport;

            # If it is set, then pass through to grafana.
            proxy_pass         http://$grafana_servers:3000;
            proxy_set_header   Host $http_host;
            proxy_set_header   X-Real-IP $remote_addr;
            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header   X-WEBAUTH-USER $webauth_user;
            proxy_set_header   X-WEBAUTH-NAME $webauth_name;
            rewrite       ^/reports/?(.*) /$1 break;
            proxy_connect_timeout 10s;
            proxy_read_timeout 6000s;
            proxy_intercept_errors on;

            ## Include all add_header directives for the report location block since we need to override the defaults.
            ## IMPORTANT: any "add_headers" for this location block must be placed inside this inclusion file directly
            include /etc/nginx/includes/report-headers.conf;

            access_log  /var/log/nginx/access.log  upstream_ws;
        }

        location /swagger/external {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            # $api_servers must be declared before api-proxy.conf
            set $api_servers $API;
            include /etc/nginx/includes/api-proxy.conf;

            ## Include all add_header directives for the swagger location block since we need to override the defaults
            ## IMPORTANT: any "add_headers" for this location block must be placed inside this inclusion file directly
            include /etc/nginx/includes/external-swagger-headers.conf;
        }

        # For proxying websockets
        location = /ws/messages {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            # we are using variables for the upstream servers instead of an upstream entry because
            # of the DNS caching problem -- only nginx plus will dynamically resolve the upstream
            # servers
            set $api_servers $API;
            # For proxying of websockets to API SSL port
            #proxy_pass         https://$api_servers:9443/ws/messages;
            # For proxying to non-SSL API
            proxy_pass        http://$api_servers:8080/ws/messages;

            proxy_set_header   Host $http_host;
            proxy_set_header   X-Real-IP $remote_addr;
            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header   X-Forwarded-Host $server_name;

            proxy_set_header   X-Forwarded-Proto $scheme;
            proxy_set_header   X-NginX-Proxy true;
            proxy_redirect     off;

            # pass websocket upgrade headers
            include /etc/nginx/includes/websocket-upgrade-headers.conf;

            # for spring security -- we don't seem to need this though.
            # proxy_pass_header X-XSRF-TOKEN;

            # long timeout to allow for WS connections idle for longer than the default 60s
            proxy_read_timeout 6000s;

            proxy_intercept_errors on;
            proxy_cache_bypass $http_upgrade;

            access_log  /var/log/nginx/access.log  upstream_ws;

        }

        # For proxying websockets
        location = /vmturbo/remoteMediation {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            $WHITE_LIST_IPS

            # Disable reverse proxy in environments that don't need it for increased security.
            set $block_external_probes $BLOCK_REMOTE_PROBES;
            if ($block_external_probes ~* "TRUE") { return 403; }

            set $topology_processor_servers $TOPOLOGY;

            # For proxying of websockets to topology processor SSL port
            #proxy_pass https://$topology_processor_servers:9443/remoteMediation;
            # For proxying to non-SSL topology processor
            # ?source=external is added so that the topology processor can find this parameter
            # in the Session object and identify it as an external probe container reaching
            # the topology processor through nginx. The topology processor may then close the
            # Session if the probe container supports probe types that are not allowed in
            # external containers.
            proxy_pass http://$topology_processor_servers:8080/remoteMediation?source=external;

            proxy_set_header   Host $http_host;
            proxy_set_header   X-Real-IP $remote_addr;
            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header   X-Forwarded-Host $server_name;

            proxy_set_header   X-Forwarded-Proto $scheme;
            proxy_set_header   X-NginX-Proxy true;
            proxy_redirect     off;

            # pass websocket upgrade headers
            include /etc/nginx/includes/websocket-upgrade-headers.conf;

            # for spring security -- we don't seem to need this though.
            # proxy_pass_header X-XSRF-TOKEN;

            # long timeout to allow for WS connections idle for longer than the default 60s
            proxy_read_timeout 600s;

            proxy_intercept_errors on;
            proxy_cache_bypass $http_upgrade;


            access_log  /var/log/nginx/access.log  upstream_ws;

        }

        # the maintenance page -- show "server temporarily unavailable" page
        location ^~ /maintenance/ {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            root /var/www;
            index monitor.html;
        }

        # /status will show the load_status contents, if they exist -- static text o/w
        location /status {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            root /var/www;
            try_files /status/load_status /maintenance/default_status;
        }

        # Diags download can take a long time. So we set the read timeout to a
        # higher value.
        location = /api/v3/cluster/diagnostics {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            set $api_servers $API;
            proxy_pass         http://$api_servers:8080;
            proxy_set_header   Host $http_host;
            proxy_set_header   X-Real-IP $remote_addr;
            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_connect_timeout 10s;
            proxy_read_timeout 7200s; # 2 hours
            proxy_intercept_errors on;

            # Ensure the proxy-side redirect from API gets rewritten to the gateway address
            proxy_set_header   X-Forwarded-Proto $scheme;
            proxy_redirect     http://$http_host/ $scheme://$http_host/;

            # Send 503 "service unavailable" on gateway issues, where API may be down or unavailable
            error_page 502 503 504 =503 /maintenance/;

            access_log  /var/log/nginx/access.log  upstream_ws;
        }

        location /healthz/ready {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            return 200 OK;
        }

        location = /vmturbo/auth/exchange {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            # Disable this endpoint when probe authentication is not enabled.
            set $tp_probe_security $ENABLE_TP_PROBE_SECURITY;
            if ($tp_probe_security !~* "TRUE") { return 403; }

            set $auth_servers $AUTH;
            proxy_pass http://$auth_servers:8080/services/authorizeService;

            proxy_set_header   Host $http_host;
            proxy_set_header   X-Real-IP $remote_addr;
            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header   X-Forwarded-Host $server_name;

            proxy_set_header   X-Forwarded-Proto $scheme;
            proxy_set_header   X-NginX-Proxy true;
            proxy_redirect     off;

            # for spring security -- we don't seem to need this though.
            # proxy_pass_header X-XSRF-TOKEN;

            proxy_read_timeout 600s;

            proxy_intercept_errors on;
            proxy_cache_bypass $http_upgrade;

            access_log  /var/log/nginx/access.log  upstream_ws;
        }

        location = /vmturbo/hydra/token {
            # ensure security headers
            include /etc/nginx/includes/security-headers.conf;

            # Disable this endpoint when probe authentication is not enabled.
            set $tp_probe_security $ENABLE_TP_PROBE_SECURITY;
            if ($tp_probe_security !~* "TRUE") { return 403; }

            set $hydra_public $HYDRA_PUBLIC;
            proxy_pass http://$hydra_public:4444/oauth2/token;

            proxy_set_header   Host $http_host;
            proxy_set_header   X-Real-IP $remote_addr;
            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header   X-Forwarded-Host $server_name;

            proxy_set_header   X-Forwarded-Proto $scheme;
            proxy_set_header   X-NginX-Proxy true;
            proxy_redirect     off;

            # for spring security -- we don't seem to need this though.
            # proxy_pass_header X-XSRF-TOKEN;

            proxy_read_timeout 600s;

            proxy_intercept_errors on;
            proxy_cache_bypass $http_upgrade;

            access_log  /var/log/nginx/access.log  upstream_ws;
        }

        # include any additional server config files for the secured block
        include /etc/nginx/userconf/secure/*.conf;
